/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Logger, MatterFlowError, NoResponseTimeoutError, UnexpectedDataError } from "#general";
import { Specification } from "#model";
import {
  Status,
  StatusCode,
  StatusResponseError,
  TlvAny,
  TlvDataReport,
  TlvDataReportForSend,
  TlvDataVersionFilter,
  TlvInvokeRequest,
  TlvInvokeResponse,
  TlvReadRequest,
  TlvStatusResponse,
  TlvSubscribeRequest,
  TlvSubscribeResponse,
  TlvTimedRequest,
  TlvWriteRequest,
  TlvWriteResponse
} from "#types";
import { SessionType } from "../codec/MessageCodec.js";
import { ChannelNotConnectedError } from "../protocol/ExchangeManager.js";
import {
  RetransmissionLimitReachedError,
  UnexpectedMessageError
} from "../protocol/MessageExchange.js";
import {
  canAttributePayloadBeChunked,
  chunkAttributePayload,
  encodeAttributePayload,
  encodeEventPayload
} from "./AttributeDataEncoder.js";
var MessageType = /* @__PURE__ */ ((MessageType2) => {
  MessageType2[MessageType2["StatusResponse"] = 1] = "StatusResponse";
  MessageType2[MessageType2["ReadRequest"] = 2] = "ReadRequest";
  MessageType2[MessageType2["SubscribeRequest"] = 3] = "SubscribeRequest";
  MessageType2[MessageType2["SubscribeResponse"] = 4] = "SubscribeResponse";
  MessageType2[MessageType2["ReportData"] = 5] = "ReportData";
  MessageType2[MessageType2["WriteRequest"] = 6] = "WriteRequest";
  MessageType2[MessageType2["WriteResponse"] = 7] = "WriteResponse";
  MessageType2[MessageType2["InvokeRequest"] = 8] = "InvokeRequest";
  MessageType2[MessageType2["InvokeResponse"] = 9] = "InvokeResponse";
  MessageType2[MessageType2["TimedRequest"] = 10] = "TimedRequest";
  return MessageType2;
})(MessageType || {});
const logger = Logger.get("InteractionMessenger");
class InteractionMessenger {
  constructor(exchange) {
    this.exchange = exchange;
  }
  calculateMaximumPeerResponseTime(expectedProcessingTimeMs) {
    return this.exchange.calculateMaximumPeerResponseTime(expectedProcessingTimeMs);
  }
  send(messageType, payload, options) {
    return this.exchange.send(messageType, payload, options);
  }
  sendStatus(status) {
    return this.send(
      1 /* StatusResponse */,
      TlvStatusResponse.encode({ status, interactionModelRevision: Specification.INTERACTION_MODEL_REVISION })
    );
  }
  async waitForSuccess(expectedProcessingTimeMs) {
    await this.nextMessage(1 /* StatusResponse */, expectedProcessingTimeMs);
  }
  async nextMessage(expectedMessageType, expectedProcessingTimeMs) {
    const message = await this.exchange.nextMessage(expectedProcessingTimeMs);
    const messageType = message.payloadHeader.messageType;
    this.throwIfErrorStatusMessage(message);
    if (expectedMessageType !== void 0 && messageType !== expectedMessageType) {
      throw new UnexpectedDataError(
        `Received unexpected message type: ${messageType}, expected: ${expectedMessageType}`
      );
    }
    return message;
  }
  async close() {
    await this.exchange.close();
  }
  throwIfErrorStatusMessage(message) {
    const {
      payloadHeader: { messageType },
      payload
    } = message;
    if (messageType !== 1 /* StatusResponse */) return;
    const { status } = TlvStatusResponse.decode(payload);
    if (status !== StatusCode.Success) throw new StatusResponseError(`Received error status: ${status}`, status);
  }
  getExchangeChannelName() {
    return this.exchange.channel.name;
  }
}
class InteractionServerMessenger extends InteractionMessenger {
  async handleRequest(recipient) {
    let continueExchange = true;
    let isGroupSession = false;
    try {
      while (continueExchange) {
        const message = await this.exchange.nextMessage();
        isGroupSession = message.packetHeader.sessionType === SessionType.Group;
        continueExchange = false;
        switch (message.payloadHeader.messageType) {
          case 2 /* ReadRequest */: {
            if (isGroupSession) {
              throw new StatusResponseError(
                `ReadRequest is not supported in group sessions`,
                Status.InvalidAction
              );
            }
            const readRequest = TlvReadRequest.decode(message.payload);
            await this.sendDataReport(
              await recipient.handleReadRequest(this.exchange, readRequest, message),
              readRequest.isFabricFiltered
            );
            break;
          }
          case 6 /* WriteRequest */: {
            const writeRequest = TlvWriteRequest.decode(message.payload);
            const { suppressResponse } = writeRequest;
            const writeResponse = await recipient.handleWriteRequest(this.exchange, writeRequest, message);
            if (!suppressResponse && !isGroupSession) {
              await this.send(7 /* WriteResponse */, TlvWriteResponse.encode(writeResponse));
            }
            break;
          }
          case 3 /* SubscribeRequest */: {
            const subscribeRequest = TlvSubscribeRequest.decode(message.payload);
            await recipient.handleSubscribeRequest(this.exchange, subscribeRequest, this, message);
            break;
          }
          case 8 /* InvokeRequest */: {
            const invokeRequest = TlvInvokeRequest.decode(message.payload);
            await recipient.handleInvokeRequest(this.exchange, invokeRequest, this, message);
            break;
          }
          case 10 /* TimedRequest */: {
            const timedRequest = TlvTimedRequest.decode(message.payload);
            recipient.handleTimedRequest(this.exchange, timedRequest, message);
            await this.sendStatus(StatusCode.Success);
            continueExchange = true;
            break;
          }
          default:
            throw new StatusResponseError(
              `Unsupported message type ${message.payloadHeader.messageType}`,
              Status.InvalidAction
            );
        }
      }
    } catch (error) {
      let errorStatusCode = StatusCode.Failure;
      if (error instanceof StatusResponseError) {
        logger.info(`Sending status response ${error.code} for interaction error: ${error.message}`);
        errorStatusCode = error.code;
      } else if (error instanceof NoResponseTimeoutError) {
        logger.info(error);
      } else {
        logger.warn(error);
      }
      if (!isGroupSession && !(error instanceof NoResponseTimeoutError)) {
        await this.sendStatus(errorStatusCode);
      }
    } finally {
      await this.exchange.close();
    }
  }
  /**
   * Handle DataReportPayload with the content of a DataReport to send, split them into multiple DataReport
   * messages and send them out based on the size.
   */
  async sendDataReport(dataReportPayload, forFabricFilteredRead) {
    const {
      subscriptionId,
      attributeReportsPayload,
      eventReportsPayload,
      suppressResponse,
      interactionModelRevision
    } = dataReportPayload;
    const dataReport = {
      subscriptionId,
      suppressResponse,
      interactionModelRevision,
      attributeReports: void 0,
      eventReports: void 0
    };
    if (attributeReportsPayload !== void 0 || eventReportsPayload !== void 0) {
      const attributeReportsToSend = [...attributeReportsPayload ?? []];
      const eventReportsToSend = [...eventReportsPayload ?? []];
      dataReport.moreChunkedMessages = true;
      const emptyDataReportBytes = TlvDataReportForSend.encode(dataReport);
      let firstAttributeAddedToReportMessage = false;
      let firstEventAddedToReportMessage = false;
      const sendAndResetReport = async () => {
        await this.sendDataReportMessage(dataReport);
        dataReport.attributeReports = void 0;
        dataReport.eventReports = void 0;
        messageSize = emptyDataReportBytes.length;
        firstAttributeAddedToReportMessage = false;
        firstEventAddedToReportMessage = false;
      };
      let messageSize = emptyDataReportBytes.length;
      while (true) {
        if (attributeReportsToSend.length > 0) {
          const attributeReport = attributeReportsToSend.shift();
          if (attributeReport !== void 0) {
            if (!firstAttributeAddedToReportMessage) {
              firstAttributeAddedToReportMessage = true;
              messageSize += 3;
            }
            const allowMissingFieldsForNonFabricFilteredRead = !forFabricFilteredRead && attributeReport.hasFabricSensitiveData;
            const encodedAttribute = encodeAttributePayload(attributeReport, {
              allowMissingFieldsForNonFabricFilteredRead
            });
            const attributeReportBytes = TlvAny.getEncodedByteLength(encodedAttribute);
            if (messageSize + attributeReportBytes > this.exchange.maxPayloadSize) {
              if (canAttributePayloadBeChunked(attributeReport)) {
                attributeReportsToSend.unshift(...chunkAttributePayload(attributeReport));
                continue;
              }
              await sendAndResetReport();
            }
            messageSize += attributeReportBytes;
            if (dataReport.attributeReports === void 0) dataReport.attributeReports = [];
            dataReport.attributeReports.push(encodedAttribute);
          }
        } else if (eventReportsToSend.length > 0) {
          const eventReport = eventReportsToSend.shift();
          if (eventReport === void 0) {
            delete dataReport.moreChunkedMessages;
            break;
          }
          if (!firstEventAddedToReportMessage) {
            firstEventAddedToReportMessage = true;
            messageSize += 3;
          }
          const allowMissingFieldsForNonFabricFilteredRead = !forFabricFilteredRead && eventReport.hasFabricSensitiveData;
          const encodedEvent = encodeEventPayload(eventReport, {
            allowMissingFieldsForNonFabricFilteredRead
          });
          const eventReportBytes = TlvAny.getEncodedByteLength(encodedEvent);
          if (messageSize + eventReportBytes > this.exchange.maxPayloadSize) {
            await sendAndResetReport();
          }
          messageSize += eventReportBytes;
          if (dataReport.eventReports === void 0) dataReport.eventReports = [];
          dataReport.eventReports.push(encodedEvent);
        } else {
          delete dataReport.moreChunkedMessages;
          break;
        }
      }
    }
    await this.sendDataReportMessage(dataReport);
  }
  async sendDataReportMessage(dataReport) {
    const dataReportToSend = {
      ...dataReport,
      suppressResponse: dataReport.moreChunkedMessages ? false : dataReport.suppressResponse
      // always false when moreChunkedMessages is true
    };
    const encodedMessage = TlvDataReportForSend.encode(dataReportToSend);
    if (encodedMessage.length > this.exchange.maxPayloadSize) {
      throw new MatterFlowError(
        `DataReport is too long to fit in a single chunk, This should not happen! Data: ${Logger.toJSON(
          dataReportToSend
        )}`
      );
    }
    logger.debug(
      `Sending DataReport chunk with ${dataReportToSend.attributeReports?.length ?? 0} attributes and ${dataReportToSend.eventReports?.length ?? 0} events: ${encodedMessage.length} bytes (moreChunkedMessages: ${dataReportToSend.moreChunkedMessages ?? false}, suppressResponse: ${dataReportToSend.suppressResponse})`
    );
    if (dataReportToSend.suppressResponse) {
      try {
        await this.exchange.send(5 /* ReportData */, encodedMessage, {
          expectAckOnly: true
        });
      } catch (e) {
        UnexpectedMessageError.accept(e);
        const { receivedMessage } = e;
        this.throwIfErrorStatusMessage(receivedMessage);
      }
    } else {
      await this.exchange.send(5 /* ReportData */, encodedMessage);
      await this.waitForSuccess();
    }
  }
}
class IncomingInteractionClientMessenger extends InteractionMessenger {
  async waitFor(messageType, timeoutMs) {
    const message = await this.nextMessage(timeoutMs);
    const {
      payloadHeader: { messageType: receivedMessageType }
    } = message;
    if (receivedMessageType !== messageType) {
      if (receivedMessageType === 1 /* StatusResponse */) {
        const statusCode = TlvStatusResponse.decode(message.payload).status;
        throw new StatusResponseError(`Received status response ${statusCode}`, statusCode);
      }
      throw new MatterFlowError(
        `Received unexpected message type ${receivedMessageType.toString(16)}. Expected ${messageType.toString(
          16
        )}`
      );
    }
    return message;
  }
  // TODO: Adjust to use callbacks or events to push put received data to allow parallel processing
  async readDataReports(expectedSubscriptionIds) {
    let subscriptionId;
    const attributeValues = [];
    const eventValues = [];
    while (true) {
      const dataReportMessage = await this.waitFor(5 /* ReportData */);
      const report = TlvDataReport.decode(dataReportMessage.payload);
      if (expectedSubscriptionIds !== void 0) {
        if (report.subscriptionId === void 0 || !expectedSubscriptionIds.includes(report.subscriptionId)) {
          await this.sendStatus(StatusCode.InvalidSubscription);
          throw new UnexpectedDataError(
            report.subscriptionId === void 0 ? "Invalid Data report without Subscription ID" : `Invalid Data report with unexpected subscription ID ${report.subscriptionId}`
          );
        }
      }
      if (subscriptionId === void 0 && report.subscriptionId !== void 0) {
        subscriptionId = report.subscriptionId;
      } else if ((subscriptionId !== void 0 || report.subscriptionId !== void 0) && report.subscriptionId !== subscriptionId) {
        throw new UnexpectedDataError(`Invalid subscription ID ${report.subscriptionId} received`);
      }
      logger.debug(
        `Received DataReport chunk with ${report.attributeReports?.length ?? 0} attributes and ${report.eventReports?.length ?? 0} events, suppressResponse: ${report.suppressResponse}, moreChunkedMessages: ${report.moreChunkedMessages}${report.subscriptionId !== void 0 ? `, subscriptionId: ${report.subscriptionId}` : ""}`
      );
      if (Array.isArray(report.attributeReports) && report.attributeReports.length > 0) {
        attributeValues.push(...report.attributeReports);
      }
      if (Array.isArray(report.eventReports) && report.eventReports.length > 0) {
        eventValues.push(...report.eventReports);
      }
      if (report.moreChunkedMessages) {
        await this.sendStatus(StatusCode.Success);
      } else if (!report.suppressResponse) {
        this.sendStatus(StatusCode.Success).catch(
          (error) => logger.info("Error while sending final Success after receiving all DataReport chunks", error)
        );
      }
      if (!report.moreChunkedMessages) {
        report.attributeReports = attributeValues;
        report.eventReports = eventValues;
        return report;
      }
    }
  }
}
class InteractionClientMessenger extends IncomingInteractionClientMessenger {
  constructor(exchange, exchangeProvider) {
    super(exchange);
    this.exchangeProvider = exchangeProvider;
  }
  static async create(exchangeProvider) {
    const exchange = await exchangeProvider.initiateExchange();
    return new this(exchange, exchangeProvider);
  }
  /** Implements a send method with an automatic reconnection mechanism */
  async send(messageType, payload, options) {
    try {
      if (this.exchange.channel.closed) {
        throw new ChannelNotConnectedError("The exchange channel is closed. Please connect the device first.");
      }
      return await this.exchange.send(messageType, payload, options);
    } catch (error) {
      if (error instanceof RetransmissionLimitReachedError || error instanceof ChannelNotConnectedError) {
        logger.debug(
          `${error instanceof RetransmissionLimitReachedError ? "Retransmission limit reached" : "Channel not connected"}, trying to reconnect and resend the message.`
        );
        await this.exchange.close();
        if (await this.exchangeProvider.reconnectChannel()) {
          this.exchange = await this.exchangeProvider.initiateExchange();
          return await this.exchange.send(messageType, payload, options);
        }
      } else {
        throw error;
      }
    }
  }
  async sendReadRequest(readRequest) {
    await this.send(2 /* ReadRequest */, this.#encodeReadingRequest(TlvReadRequest, readRequest));
    return this.readDataReports();
  }
  #encodeReadingRequest(schema, request) {
    const encoded = schema.encode(request);
    if (encoded.length <= this.exchange.maxPayloadSize) {
      return encoded;
    }
    const originalDataVersionFilters = [...request.dataVersionFilters ?? []];
    const requestWithoutDataVersionFilters = schema.encode({
      ...request,
      dataVersionFilters: []
    });
    if (requestWithoutDataVersionFilters.length > this.exchange.maxPayloadSize) {
      throw new MatterFlowError(
        `Request is too long to fit in a single chunk, This should not happen! Data: ${Logger.toJSON(request)}`
      );
    }
    return schema.encode({
      ...request,
      dataVersionFilters: this.#shortenDataVersionFilters(
        originalDataVersionFilters,
        this.exchange.maxPayloadSize - requestWithoutDataVersionFilters.length
      )
    });
  }
  #shortenDataVersionFilters(originalDataVersionFilters, availableBytes) {
    const dataVersionFilters = new Array();
    while (availableBytes > 0 && originalDataVersionFilters.length > 0) {
      const dataVersionFilter = originalDataVersionFilters.shift();
      if (dataVersionFilter === void 0) {
        break;
      }
      const encodedDataVersionFilter = TlvDataVersionFilter.encode(dataVersionFilter);
      const encodedDataVersionFilterLength = encodedDataVersionFilter.length;
      if (encodedDataVersionFilterLength > availableBytes) {
        originalDataVersionFilters.unshift(dataVersionFilter);
        break;
      }
      dataVersionFilters.push(dataVersionFilter);
      availableBytes -= encodedDataVersionFilterLength;
    }
    logger.debug(
      `Removed ${originalDataVersionFilters.length} DataVersionFilters from Request to fit into a single message`
    );
    return dataVersionFilters;
  }
  async sendSubscribeRequest(subscribeRequest) {
    const request = this.#encodeReadingRequest(TlvSubscribeRequest, subscribeRequest);
    await this.send(3 /* SubscribeRequest */, request);
    const report = await this.readDataReports();
    const { subscriptionId } = report;
    if (subscriptionId === void 0) {
      throw new UnexpectedDataError(`Subscription ID not provided in report`);
    }
    const subscribeResponseMessage = await this.nextMessage(4 /* SubscribeResponse */);
    const subscribeResponse = TlvSubscribeResponse.decode(subscribeResponseMessage.payload);
    if (subscribeResponse.subscriptionId !== subscriptionId) {
      throw new MatterFlowError(
        `Received subscription ID ${subscribeResponse.subscriptionId} instead of ${subscriptionId}`
      );
    }
    return {
      subscribeResponse,
      report
    };
  }
  async sendInvokeCommand(invokeRequest, expectedProcessingTimeMs) {
    if (invokeRequest.suppressResponse) {
      await this.requestWithSuppressedResponse(
        8 /* InvokeRequest */,
        TlvInvokeRequest,
        invokeRequest,
        expectedProcessingTimeMs
      );
    } else {
      return await this.request(
        8 /* InvokeRequest */,
        TlvInvokeRequest,
        9 /* InvokeResponse */,
        TlvInvokeResponse,
        invokeRequest,
        expectedProcessingTimeMs
      );
    }
  }
  async sendWriteCommand(writeRequest) {
    if (writeRequest.suppressResponse) {
      await this.requestWithSuppressedResponse(6 /* WriteRequest */, TlvWriteRequest, writeRequest);
    } else {
      return await this.request(
        6 /* WriteRequest */,
        TlvWriteRequest,
        7 /* WriteResponse */,
        TlvWriteResponse,
        writeRequest
      );
    }
  }
  sendTimedRequest(timeoutSeconds) {
    return this.request(10 /* TimedRequest */, TlvTimedRequest, 1 /* StatusResponse */, TlvStatusResponse, {
      timeout: timeoutSeconds,
      interactionModelRevision: Specification.INTERACTION_MODEL_REVISION
    });
  }
  async requestWithSuppressedResponse(requestMessageType, requestSchema, request, expectedProcessingTimeMs) {
    await this.send(requestMessageType, requestSchema.encode(request), {
      expectAckOnly: true,
      expectedProcessingTimeMs
    });
  }
  async request(requestMessageType, requestSchema, responseMessageType, responseSchema, request, expectedProcessingTimeMs) {
    await this.send(requestMessageType, requestSchema.encode(request), {
      expectAckOnly: false,
      expectedProcessingTimeMs
    });
    const responseMessage = await this.nextMessage(responseMessageType, expectedProcessingTimeMs);
    return responseSchema.decode(responseMessage.payload);
  }
}
export {
  IncomingInteractionClientMessenger,
  InteractionClientMessenger,
  InteractionServerMessenger,
  MessageType
};
//# sourceMappingURL=InteractionMessenger.js.map
