/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  Bytes,
  ChannelType,
  Diagnostic,
  DnsCodec,
  DnsMessageType,
  DnsRecordClass,
  DnsRecordType,
  ImplementationError,
  Logger,
  MAX_MDNS_MESSAGE_SIZE,
  Time,
  UdpMulticastServer,
  createPromise,
  isIPv6
} from "#general";
import { NodeId, VendorId } from "#types";
import {
  MATTER_COMMISSION_SERVICE_QNAME,
  MATTER_SERVICE_QNAME,
  getCommissioningModeQname,
  getDeviceInstanceQname,
  getDeviceMatterQname,
  getDeviceTypeQname,
  getLongDiscriminatorQname,
  getShortDiscriminatorQname,
  getVendorQname
} from "./MdnsConsts.js";
import { MDNS_BROADCAST_IPV4, MDNS_BROADCAST_IPV6, MDNS_BROADCAST_PORT } from "./MdnsServer.js";
const logger = Logger.get("MdnsScanner");
const MDNS_EXPIRY_GRACE_PERIOD_FACTOR = 1.05;
const START_ANNOUNCE_INTERVAL_SECONDS = 1.5;
class MdnsScanner {
  get type() {
    return ChannelType.UDP;
  }
  static async create(network, options) {
    const { enableIpv4, netInterface } = options ?? {};
    return new MdnsScanner(
      await UdpMulticastServer.create({
        network,
        netInterface,
        broadcastAddressIpv4: enableIpv4 ? MDNS_BROADCAST_IPV4 : void 0,
        broadcastAddressIpv6: MDNS_BROADCAST_IPV6,
        listeningPort: MDNS_BROADCAST_PORT
      }),
      enableIpv4
    );
  }
  #activeAnnounceQueries = /* @__PURE__ */ new Map();
  #queryTimer;
  #nextAnnounceIntervalSeconds = START_ANNOUNCE_INTERVAL_SECONDS;
  #operationalDeviceRecords = /* @__PURE__ */ new Map();
  #commissionableDeviceRecords = /* @__PURE__ */ new Map();
  #recordWaiters = /* @__PURE__ */ new Map();
  #periodicTimer;
  #closing = false;
  #multicastServer;
  #enableIpv4;
  constructor(multicastServer, enableIpv4) {
    multicastServer.onMessage(
      (message, remoteIp, netInterface) => this.#handleDnsMessage(message, remoteIp, netInterface)
    );
    this.#multicastServer = multicastServer;
    this.#enableIpv4 = enableIpv4;
    this.#periodicTimer = Time.getPeriodicTimer(
      "Discovered node expiration",
      60 * 1e3,
      () => this.#expire()
    ).start();
  }
  #effectiveTTL(ttl) {
    return Math.ceil(ttl * MDNS_EXPIRY_GRACE_PERIOD_FACTOR);
  }
  /**
   * Sends out one DNS-SD query for all collected announce records and start a timer for the next query with doubled
   * interval, maximum 60min, as per MDNS specs. The already known answers are tried to be sent in the query as long
   * as they fit into a maximum 1500 byte long packet (as defined in MDNS specs), else they are split into more
   * packets and the query is sent as Truncated query.
   */
  async #sendQueries() {
    this.#queryTimer?.stop();
    const allQueries = Array.from(this.#activeAnnounceQueries.values());
    const queries = allQueries.flatMap(({ queries: queries2 }) => queries2);
    const answers = allQueries.flatMap(({ answers: answers2 }) => answers2);
    this.#queryTimer = Time.getTimer(
      "MDNS discovery",
      this.#nextAnnounceIntervalSeconds * 1e3,
      () => this.#sendQueries()
    ).start();
    logger.debug(
      `Sending ${queries.length} query records for ${this.#activeAnnounceQueries.size} queries with ${answers.length} known answers. Re-Announce in ${this.#nextAnnounceIntervalSeconds} seconds`
    );
    const nextAnnounceInterval = this.#nextAnnounceIntervalSeconds * 2;
    this.#nextAnnounceIntervalSeconds = Math.min(
      nextAnnounceInterval,
      60 * 60
      /* 1 hour */
    );
    const answersToSend = [...answers];
    const dnsMessageDataToSend = {
      messageType: DnsMessageType.TruncatedQuery,
      transactionId: 0,
      queries,
      authorities: [],
      answers: [],
      additionalRecords: []
    };
    const emptyDnsMessage = DnsCodec.encode(dnsMessageDataToSend);
    let dnsMessageSize = emptyDnsMessage.length;
    while (true) {
      if (answersToSend.length > 0) {
        const nextAnswer = answersToSend.shift();
        if (nextAnswer === void 0) {
          break;
        }
        const nextAnswerEncoded = DnsCodec.encodeRecord(nextAnswer);
        dnsMessageSize += nextAnswerEncoded.length;
        if (dnsMessageSize > MAX_MDNS_MESSAGE_SIZE) {
          if (dnsMessageDataToSend.answers.length === 0) {
            logger.warn(
              `MDNS Query with ${Logger.toJSON(
                queries
              )} is too big to fit into a single MDNS message. Send anyway, but please report!`
            );
          }
          await this.#multicastServer.send(DnsCodec.encode(dnsMessageDataToSend));
          dnsMessageDataToSend.queries.length = 0;
          dnsMessageDataToSend.answers.length = 0;
          dnsMessageSize = emptyDnsMessage.length + nextAnswerEncoded.length;
        }
        dnsMessageDataToSend.answers.push(nextAnswerEncoded);
      } else {
        break;
      }
    }
    await this.#multicastServer.send(
      DnsCodec.encode({ ...dnsMessageDataToSend, messageType: DnsMessageType.Query })
    );
  }
  /**
   * Set new DnsQuery records to the list of active queries to discover devices in the network and start sending them
   * out. When entry already exists the query is overwritten and answers are always added.
   */
  #setQueryRecords(queryId, queries, answers = []) {
    const activeExistingQuery = this.#activeAnnounceQueries.get(queryId);
    if (activeExistingQuery) {
      const { queries: existingQueries } = activeExistingQuery;
      const newQueries = queries.filter(
        (query) => !existingQueries.some(
          (existingQuery) => existingQuery.name === query.name && existingQuery.recordType === query.recordType && existingQuery.recordClass === query.recordClass
        )
      );
      if (newQueries.length === 0) {
        logger.debug(
          `No new query records for query ${queryId}, keeping existing queries and do not re-announce.`
        );
        return;
      }
      queries = [...newQueries, ...existingQueries];
      answers = [...activeExistingQuery.answers, ...answers];
    }
    this.#activeAnnounceQueries.set(queryId, { queries, answers });
    logger.debug(`Set ${queries.length} query records for query ${queryId}: ${Logger.toJSON(queries)}`);
    this.#queryTimer?.stop();
    this.#nextAnnounceIntervalSeconds = START_ANNOUNCE_INTERVAL_SECONDS;
    this.#queryTimer = Time.getTimer("MDNS discovery", 0, () => this.#sendQueries()).start();
  }
  #getActiveQueryEarlierAnswers() {
    return Array.from(this.#activeAnnounceQueries.values()).flatMap(({ answers }) => answers);
  }
  /**
   * Remove a query from the list of active queries because discovery has finished or timed out and stop sending it
   * out. If it was the last query announcing will stop completely.
   */
  #removeQuery(queryId) {
    this.#activeAnnounceQueries.delete(queryId);
    if (this.#activeAnnounceQueries.size === 0) {
      logger.debug(`Removing last query ${queryId} and stopping announce timer`);
      this.#queryTimer?.stop();
      this.#nextAnnounceIntervalSeconds = START_ANNOUNCE_INTERVAL_SECONDS;
    } else {
      logger.debug(`Removing query ${queryId}`);
    }
  }
  /**
   * Returns the list of all targets (IP/port) discovered for a queried operational device record.
   */
  #getOperationalDeviceRecords(deviceMatterQname) {
    const device = this.#operationalDeviceRecords.get(deviceMatterQname);
    if (device === void 0) {
      return void 0;
    }
    const { addresses } = device;
    if (addresses.size === 0) {
      return void 0;
    }
    return {
      ...device,
      addresses: this.#sortServerEntries(Array.from(addresses.values())).map(({ ip, port }) => ({
        ip,
        port,
        type: "udp"
      }))
    };
  }
  /**
   * Sort the list of found IP/ports and make sure link-local IPv6 addresses come first, IPv6 next and IPv4 last.
   *
   * @param entries
   */
  #sortServerEntries(entries) {
    return entries.sort((a, b) => {
      const aIsIPv6 = isIPv6(a.ip);
      const bIsIPv6 = isIPv6(b.ip);
      if (aIsIPv6 && !bIsIPv6) {
        return -1;
      } else if (!aIsIPv6 && bIsIPv6) {
        return 1;
      } else if (aIsIPv6 && bIsIPv6) {
        if (a.ip.startsWith("fd") && !b.ip.startsWith("fd")) {
          return -1;
        } else if (!a.ip.startsWith("fd") && b.ip.startsWith("fd")) {
          return 1;
        } else if (a.ip.startsWith("fe80:") && !b.ip.startsWith("fe80:")) {
          return -1;
        } else if (!a.ip.startsWith("fe80:") && b.ip.startsWith("fe80:")) {
          return 1;
        }
      }
      return 0;
    });
  }
  /**
   * Registers a deferred promise for a specific queryId together with a timeout and return the promise.
   * The promise will be resolved when the timer runs out latest.
   */
  async #registerWaiterPromise(queryId, timeoutSeconds, resolveOnUpdatedRecords = true) {
    const { promise, resolver } = createPromise();
    const timer = timeoutSeconds !== void 0 ? Time.getTimer("MDNS timeout", timeoutSeconds * 1e3, () => this.#finishWaiter(queryId, true)).start() : void 0;
    this.#recordWaiters.set(queryId, { resolver, timer, resolveOnUpdatedRecords });
    logger.debug(
      `Registered waiter for query ${queryId} with ${timeoutSeconds !== void 0 ? `timeout ${timeoutSeconds} seconds` : "no timeout"}${resolveOnUpdatedRecords ? "" : " (not resolving on updated records)"}`
    );
    await promise;
  }
  /**
   * Remove a waiter promise for a specific queryId and stop the connected timer. If required also resolve the
   * promise.
   */
  #finishWaiter(queryId, resolvePromise, isUpdatedRecord = false) {
    const waiter = this.#recordWaiters.get(queryId);
    if (waiter === void 0) return;
    const { timer, resolver, resolveOnUpdatedRecords } = waiter;
    if (isUpdatedRecord && !resolveOnUpdatedRecords) return;
    logger.debug(`Finishing waiter for query ${queryId}, resolving: ${resolvePromise}`);
    if (timer !== void 0) {
      timer.stop();
    }
    if (resolvePromise) {
      resolver();
    }
    this.#recordWaiters.delete(queryId);
  }
  /** Returns weather a waiter promise is registered for a specific queryId. */
  #hasWaiter(queryId) {
    return this.#recordWaiters.has(queryId);
  }
  #createOperationalMatterQName(operationalId, nodeId) {
    const operationalIdString = Bytes.toHex(operationalId).toUpperCase();
    return getDeviceMatterQname(operationalIdString, NodeId.toHexString(nodeId));
  }
  /**
   * Method to find an operational device (already commissioned) and return a promise with the list of discovered
   * IP/ports or an empty array if not found.
   */
  async findOperationalDevice({ operationalId }, nodeId, timeoutSeconds, ignoreExistingRecords = false) {
    if (this.#closing) {
      throw new ImplementationError("Cannot discover operational device because scanner is closing.");
    }
    const deviceMatterQname = this.#createOperationalMatterQName(operationalId, nodeId);
    let storedDevice = ignoreExistingRecords ? void 0 : this.#getOperationalDeviceRecords(deviceMatterQname);
    if (storedDevice === void 0) {
      const promise = this.#registerWaiterPromise(deviceMatterQname, timeoutSeconds);
      this.#setQueryRecords(deviceMatterQname, [
        {
          name: deviceMatterQname,
          recordClass: DnsRecordClass.IN,
          recordType: DnsRecordType.SRV
        }
      ]);
      await promise;
      storedDevice = this.#getOperationalDeviceRecords(deviceMatterQname);
      this.#removeQuery(deviceMatterQname);
    }
    return storedDevice;
  }
  cancelOperationalDeviceDiscovery(fabric, nodeId, resolvePromise = true) {
    const deviceMatterQname = this.#createOperationalMatterQName(fabric.operationalId, nodeId);
    this.#finishWaiter(deviceMatterQname, resolvePromise);
  }
  cancelCommissionableDeviceDiscovery(identifier, resolvePromise = true) {
    const queryId = this.#buildCommissionableQueryIdentifier(identifier);
    this.#finishWaiter(queryId, resolvePromise);
  }
  getDiscoveredOperationalDevice({ operationalId }, nodeId) {
    return this.#getOperationalDeviceRecords(this.#createOperationalMatterQName(operationalId, nodeId));
  }
  /**
   * Returns the metadata and list of all target addresses (IP/port) discovered for a queried commissionable device
   * record.
   */
  #getCommissionableDeviceRecords(identifier) {
    const storedRecords = Array.from(this.#commissionableDeviceRecords.values());
    const foundRecords = new Array();
    if ("instanceId" in identifier) {
      foundRecords.push(...storedRecords.filter(({ instanceId }) => instanceId === identifier.instanceId));
    } else if ("longDiscriminator" in identifier) {
      foundRecords.push(...storedRecords.filter(({ D }) => D === identifier.longDiscriminator));
    } else if ("shortDiscriminator" in identifier) {
      foundRecords.push(...storedRecords.filter(({ SD }) => SD === identifier.shortDiscriminator));
    } else if ("vendorId" in identifier && "productId" in identifier) {
      foundRecords.push(
        ...storedRecords.filter(({ V, P }) => V === identifier.vendorId && P === identifier.productId)
      );
    } else if ("vendorId" in identifier) {
      foundRecords.push(...storedRecords.filter(({ V }) => V === identifier.vendorId));
    } else if ("deviceType" in identifier) {
      foundRecords.push(...storedRecords.filter(({ DT }) => DT === identifier.deviceType));
    } else if ("productId" in identifier) {
      foundRecords.push(...storedRecords.filter(({ P }) => P === identifier.productId));
    } else if (Object.keys(identifier).length === 0) {
      foundRecords.push(...storedRecords.filter(({ CM }) => CM === 1 || CM === 2));
    }
    return foundRecords.filter(({ addresses }) => addresses.size > 0).map((record) => {
      return {
        ...record,
        addresses: this.#sortServerEntries(Array.from(record.addresses.values())).map(({ ip, port }) => ({
          ip,
          port,
          type: "udp"
        })),
        discoveredAt: void 0,
        ttl: void 0
      };
    });
  }
  /**
   * Builds an identifier string for commissionable queries based on the given identifier object.
   * Some identifiers are identical to the official DNS-SD identifiers, others are custom.
   */
  #buildCommissionableQueryIdentifier(identifier) {
    if ("instanceId" in identifier) {
      return getDeviceInstanceQname(identifier.instanceId);
    }
    if ("longDiscriminator" in identifier) {
      return getLongDiscriminatorQname(identifier.longDiscriminator);
    }
    if ("shortDiscriminator" in identifier) {
      return getShortDiscriminatorQname(identifier.shortDiscriminator);
    }
    if ("vendorId" in identifier && "productId" in identifier) {
      return `_VP${identifier.vendorId}+${identifier.productId}`;
    }
    if ("vendorId" in identifier) {
      return getVendorQname(identifier.vendorId);
    }
    if ("deviceType" in identifier) {
      return getDeviceTypeQname(identifier.deviceType);
    }
    if ("productId" in identifier) {
      return `_P${identifier.productId}`;
    }
    return getCommissioningModeQname();
  }
  #extractInstanceId(instanceName) {
    const instanceNameSeparator = instanceName.indexOf(".");
    if (instanceNameSeparator !== -1) {
      return instanceName.substring(0, instanceNameSeparator);
    }
    return instanceName;
  }
  /**
   * Check all options for a query identifier and return the most relevant one with an active query
   */
  #findCommissionableQueryIdentifier(instanceName, record) {
    if (this.#closing) {
      throw new ImplementationError("Cannot discover commissionable device because scanner is closing.");
    }
    const instanceQueryId = this.#buildCommissionableQueryIdentifier({
      instanceId: this.#extractInstanceId(instanceName)
    });
    if (this.#activeAnnounceQueries.has(instanceQueryId)) {
      return instanceQueryId;
    }
    const longDiscriminatorQueryId = this.#buildCommissionableQueryIdentifier({ longDiscriminator: record.D });
    if (this.#activeAnnounceQueries.has(longDiscriminatorQueryId)) {
      return longDiscriminatorQueryId;
    }
    const shortDiscriminatorQueryId = this.#buildCommissionableQueryIdentifier({ shortDiscriminator: record.SD });
    if (this.#activeAnnounceQueries.has(shortDiscriminatorQueryId)) {
      return shortDiscriminatorQueryId;
    }
    if (record.V !== void 0 && record.P !== void 0) {
      const vendorProductIdQueryId = this.#buildCommissionableQueryIdentifier({
        vendorId: VendorId(record.V),
        productId: record.P
      });
      if (this.#activeAnnounceQueries.has(vendorProductIdQueryId)) {
        return vendorProductIdQueryId;
      }
    }
    if (record.V !== void 0) {
      const vendorIdQueryId = this.#buildCommissionableQueryIdentifier({ vendorId: VendorId(record.V) });
      if (this.#activeAnnounceQueries.has(vendorIdQueryId)) {
        return vendorIdQueryId;
      }
    }
    if (record.DT !== void 0) {
      const deviceTypeQueryId = this.#buildCommissionableQueryIdentifier({ deviceType: record.DT });
      if (this.#activeAnnounceQueries.has(deviceTypeQueryId)) {
        return deviceTypeQueryId;
      }
    }
    if (record.P !== void 0) {
      const productIdQueryId = this.#buildCommissionableQueryIdentifier({ productId: record.P });
      if (this.#activeAnnounceQueries.has(productIdQueryId)) {
        return productIdQueryId;
      }
    }
    const commissioningModeQueryId = this.#buildCommissionableQueryIdentifier({});
    if (this.#activeAnnounceQueries.has(commissioningModeQueryId)) {
      return commissioningModeQueryId;
    }
    return void 0;
  }
  #getCommissionableQueryRecords(identifier) {
    const names = new Array();
    names.push(MATTER_COMMISSION_SERVICE_QNAME);
    if ("instanceId" in identifier) {
      names.push(getDeviceInstanceQname(identifier.instanceId));
    } else if ("longDiscriminator" in identifier) {
      names.push(getLongDiscriminatorQname(identifier.longDiscriminator));
    } else if ("shortDiscriminator" in identifier) {
      names.push(getShortDiscriminatorQname(identifier.shortDiscriminator));
    } else if ("vendorId" in identifier) {
      names.push(getVendorQname(identifier.vendorId));
    } else if ("deviceType" in identifier) {
      names.push(getDeviceTypeQname(identifier.deviceType));
    } else {
      names.push(getCommissioningModeQname());
    }
    return names.map((name) => ({ name, recordClass: DnsRecordClass.IN, recordType: DnsRecordType.PTR }));
  }
  /**
   * Discovers commissionable devices based on a defined identifier for maximal given timeout, but returns the
   * first found entries. If already a discovered device matches in the cache the response is returned directly and
   * no query is triggered. If no record exists a query is sent out and the promise gets fulfilled as soon as at least
   * one device is found. If no device is discovered in the defined timeframe an empty array is returned. When the
   * promise got fulfilled no more queries are send out, but more device entries might be added when discovered later.
   * These can be requested by the getCommissionableDevices method.
   */
  async findCommissionableDevices(identifier, timeoutSeconds = 5, ignoreExistingRecords = false) {
    let storedRecords = ignoreExistingRecords ? [] : this.#getCommissionableDeviceRecords(identifier).filter(({ addresses }) => addresses.length > 0);
    if (storedRecords.length === 0) {
      const queryId = this.#buildCommissionableQueryIdentifier(identifier);
      const promise = this.#registerWaiterPromise(queryId, timeoutSeconds);
      this.#setQueryRecords(queryId, this.#getCommissionableQueryRecords(identifier));
      await promise;
      storedRecords = this.#getCommissionableDeviceRecords(identifier);
      this.#removeQuery(queryId);
    }
    return storedRecords;
  }
  /**
   * Discovers commissionable devices based on a defined identifier and returns the first found entries. If already a
   * @param identifier
   * @param callback
   * @param timeoutSeconds
   */
  async findCommissionableDevicesContinuously(identifier, callback, timeoutSeconds, cancelSignal) {
    const discoveredDevices = /* @__PURE__ */ new Set();
    const now = Time.nowMs();
    const discoveryEndTime = timeoutSeconds ? now + timeoutSeconds * 1e3 : void 0;
    const queryId = this.#buildCommissionableQueryIdentifier(identifier);
    this.#setQueryRecords(queryId, this.#getCommissionableQueryRecords(identifier));
    let canceled = false;
    cancelSignal?.then(
      () => {
        canceled = true;
        this.#finishWaiter(queryId, true);
      },
      (cause) => {
        logger.error("Unexpected error canceling commissioning", cause);
      }
    );
    while (!canceled) {
      this.#getCommissionableDeviceRecords(identifier).forEach((device) => {
        const { deviceIdentifier } = device;
        if (!discoveredDevices.has(deviceIdentifier)) {
          discoveredDevices.add(deviceIdentifier);
          callback(device);
        }
      });
      let remainingTime;
      if (discoveryEndTime !== void 0) {
        const remainingTime2 = Math.ceil((discoveryEndTime - now) / 1e3);
        if (remainingTime2 <= 0) {
          break;
        }
      }
      await this.#registerWaiterPromise(queryId, remainingTime, false);
    }
    return this.#getCommissionableDeviceRecords(identifier);
  }
  getDiscoveredCommissionableDevices(identifier) {
    return this.#getCommissionableDeviceRecords(identifier);
  }
  /**
   * Close all connects, end all timers and resolve all pending promises.
   */
  async close() {
    this.#closing = true;
    this.#periodicTimer.stop();
    this.#queryTimer?.stop();
    await this.#multicastServer.close();
    [...this.#recordWaiters.keys()].forEach(
      (queryId) => this.#finishWaiter(queryId, !!this.#recordWaiters.get(queryId)?.timer)
    );
  }
  /**
   * Main method to handle all incoming DNS messages.
   * It will parse the message and check if it contains relevant discovery records.
   */
  #handleDnsMessage(messageBytes, _remoteIp, netInterface) {
    if (this.#closing) return;
    const message = DnsCodec.decode(messageBytes);
    if (message === void 0) return;
    if (message.messageType !== DnsMessageType.Response && message.messageType !== DnsMessageType.TruncatedResponse)
      return;
    const answers = [...message.answers, ...message.additionalRecords];
    if (this.#handleOperationalRecords(answers, this.#getActiveQueryEarlierAnswers(), netInterface)) return;
    this.#handleCommissionableRecords(answers, this.#getActiveQueryEarlierAnswers(), netInterface);
  }
  #handleIpRecords(answers, target, netInterface) {
    const ipRecords = answers.filter(
      ({ name, recordType }) => (recordType === DnsRecordType.A && this.#enableIpv4 || recordType === DnsRecordType.AAAA) && name === target
    );
    return ipRecords.map(({ value, ttl }) => ({
      value: value.startsWith("fe80::") ? `${value}%${netInterface}` : value,
      ttl
    }));
  }
  #handleOperationalRecords(answers, formerAnswers, netInterface) {
    let recordsHandled = false;
    const operationalTxtRecord = answers.find(
      ({ name, recordType }) => recordType === DnsRecordType.TXT && name.endsWith(MATTER_SERVICE_QNAME)
    );
    if (operationalTxtRecord !== void 0) {
      this.#handleOperationalTxtRecord(operationalTxtRecord, netInterface);
      recordsHandled = true;
    }
    const operationalSrvRecord = answers.find(
      ({ name, recordType }) => recordType === DnsRecordType.SRV && name.endsWith(MATTER_SERVICE_QNAME)
    ) ?? formerAnswers.find(
      ({ name, recordType }) => recordType === DnsRecordType.SRV && name.endsWith(MATTER_SERVICE_QNAME)
    );
    if (operationalSrvRecord !== void 0) {
      this.#handleOperationalSrvRecord(operationalSrvRecord, answers, formerAnswers, netInterface);
      recordsHandled = true;
    }
    return recordsHandled;
  }
  #handleOperationalTxtRecord(record, netInterface) {
    const { name: matterName, value, ttl } = record;
    const discoveredAt = Time.nowMs();
    if (ttl === 0) {
      if (this.#operationalDeviceRecords.has(matterName)) {
        logger.debug(
          `Removing operational device ${matterName} from cache (interface ${netInterface}) because of ttl=0`
        );
        this.#operationalDeviceRecords.delete(matterName);
      }
      return;
    }
    if (!Array.isArray(value)) return;
    const txtData = this.#parseTxtRecord(record);
    if (txtData === void 0) return;
    let device = this.#operationalDeviceRecords.get(matterName);
    if (device !== void 0) {
      device = {
        ...device,
        discoveredAt,
        ttl: ttl * 1e3,
        ...txtData
      };
    } else {
      logger.debug(
        `Adding operational device ${matterName} in cache (interface ${netInterface}, ttl=${ttl}) with TXT data:`,
        MdnsScanner.discoveryDataDiagnostics(txtData)
      );
      device = {
        deviceIdentifier: matterName,
        addresses: /* @__PURE__ */ new Map(),
        discoveredAt,
        ttl: ttl * 1e3,
        ...txtData
      };
    }
    this.#operationalDeviceRecords.set(matterName, device);
  }
  #handleOperationalSrvRecord(record, answers, formerAnswers, netInterface) {
    const {
      name: matterName,
      ttl,
      value: { target, port }
    } = record;
    const discoveredAt = Time.nowMs();
    if (ttl === 0) {
      if (this.#operationalDeviceRecords.has(matterName)) {
        logger.debug(
          `Removing operational device ${matterName} from cache (interface ${netInterface}) because of ttl=0`
        );
        this.#operationalDeviceRecords.delete(matterName);
      }
      return true;
    }
    const ips = this.#handleIpRecords([...answers, ...formerAnswers], target, netInterface);
    const deviceExisted = this.#operationalDeviceRecords.has(matterName);
    const device = this.#operationalDeviceRecords.get(matterName) ?? {
      deviceIdentifier: matterName,
      addresses: /* @__PURE__ */ new Map(),
      discoveredAt,
      ttl: ttl * 1e3
    };
    const { addresses } = device;
    if (ips.length > 0) {
      for (const { value: ip, ttl: ttl2 } of ips) {
        if (ttl2 === 0) {
          logger.debug(
            `Removing IP ${ip} for operational device ${matterName} from cache (interface ${netInterface}) because of ttl=0`
          );
          addresses.delete(ip);
          continue;
        }
        const address = addresses.get(ip) ?? { ip, port, type: "udp" };
        address.discoveredAt = discoveredAt;
        address.ttl = ttl2 * 1e3;
        addresses.set(address.ip, address);
      }
      device.addresses = addresses;
      if (!this.#operationalDeviceRecords.has(matterName)) {
        logger.debug(
          `Added IPs for operational device ${matterName} to cache (interface ${netInterface}):`,
          ...MdnsScanner.deviceAddressDiagnostics(addresses)
        );
      }
      this.#operationalDeviceRecords.set(matterName, device);
    }
    if (addresses.size === 0 && this.#hasWaiter(matterName)) {
      const queries = [{ name: target, recordClass: DnsRecordClass.IN, recordType: DnsRecordType.AAAA }];
      if (this.#enableIpv4) {
        queries.push({ name: target, recordClass: DnsRecordClass.IN, recordType: DnsRecordType.A });
      }
      logger.debug(`Requesting IP addresses for operational device ${matterName} (interface ${netInterface}).`);
      this.#setQueryRecords(matterName, queries, answers);
    } else if (addresses.size > 0) {
      this.#finishWaiter(matterName, true, deviceExisted);
    }
    return true;
  }
  #handleCommissionableRecords(answers, formerAnswers, netInterface) {
    let commissionableRecords = answers.filter(({ name }) => name.endsWith(MATTER_COMMISSION_SERVICE_QNAME));
    if (!commissionableRecords.length) {
      commissionableRecords = formerAnswers.filter(({ name }) => name.endsWith(MATTER_COMMISSION_SERVICE_QNAME));
      if (!commissionableRecords.length) return;
    }
    const queryMissingDataForInstances = /* @__PURE__ */ new Set();
    const txtRecords = commissionableRecords.filter(({ recordType }) => recordType === DnsRecordType.TXT);
    for (const record of txtRecords) {
      const { name, ttl } = record;
      if (ttl === 0) {
        if (this.#commissionableDeviceRecords.has(name)) {
          logger.debug(
            `Removing commissionable device ${name} from cache (interface ${netInterface}) because of ttl=0`
          );
          this.#commissionableDeviceRecords.delete(name);
        }
        continue;
      }
      const txtRecord = this.#parseCommissionableTxtRecord(record);
      if (txtRecord === void 0) continue;
      const instanceId = this.#extractInstanceId(name);
      const parsedRecord = {
        ...txtRecord,
        instanceId,
        deviceIdentifier: instanceId
      };
      if (parsedRecord.D !== void 0 && parsedRecord.SD === void 0) {
        parsedRecord.SD = parsedRecord.D >> 8 & 15;
      }
      if (parsedRecord.VP !== void 0) {
        const VpValueArr = parsedRecord.VP.split("+");
        parsedRecord.V = VpValueArr[0] !== void 0 ? parseInt(VpValueArr[0]) : void 0;
        parsedRecord.P = VpValueArr[1] !== void 0 ? parseInt(VpValueArr[1]) : void 0;
      }
      const storedRecord = this.#commissionableDeviceRecords.get(name);
      if (storedRecord === void 0) {
        queryMissingDataForInstances.add(name);
        logger.debug(
          `Found commissionable device ${name} with data:`,
          MdnsScanner.discoveryDataDiagnostics(parsedRecord)
        );
      } else {
        parsedRecord.addresses = storedRecord.addresses;
      }
      this.#commissionableDeviceRecords.set(name, parsedRecord);
    }
    const srvRecords = commissionableRecords.filter(({ recordType }) => recordType === DnsRecordType.SRV);
    for (const record of srvRecords) {
      const storedRecord = this.#commissionableDeviceRecords.get(record.name);
      if (storedRecord === void 0) continue;
      const {
        value: { target, port },
        ttl
      } = record;
      if (ttl === 0) {
        logger.debug(
          `Removing commissionable device ${record.name} from cache (interface ${netInterface}) because of ttl=0`
        );
        this.#commissionableDeviceRecords.delete(record.name);
        continue;
      }
      const recordExisting = storedRecord.addresses.size > 0;
      const ips = this.#handleIpRecords([...answers, ...formerAnswers], target, netInterface);
      if (ips.length > 0) {
        for (const { value: ip, ttl: ttl2 } of ips) {
          if (ttl2 === 0) {
            logger.debug(
              `Removing IP ${ip} for commissionable device ${record.name} from cache (interface ${netInterface}) because of ttl=0`
            );
            storedRecord.addresses.delete(ip);
            continue;
          }
          const matterServer = storedRecord.addresses.get(ip) ?? { ip, port, type: "udp" };
          matterServer.discoveredAt = Time.nowMs();
          matterServer.ttl = ttl2 * 1e3;
          storedRecord.addresses.set(ip, matterServer);
        }
      }
      this.#commissionableDeviceRecords.set(record.name, storedRecord);
      if (storedRecord.addresses.size === 0) {
        const queryId2 = this.#findCommissionableQueryIdentifier("", storedRecord);
        if (queryId2 === void 0) continue;
        const queries = [{ name: target, recordClass: DnsRecordClass.IN, recordType: DnsRecordType.AAAA }];
        if (this.#enableIpv4) {
          queries.push({ name: target, recordClass: DnsRecordClass.IN, recordType: DnsRecordType.A });
        }
        logger.debug(
          `Requesting IP addresses for commissionable device ${record.name} (interface ${netInterface}).`
        );
        this.#setQueryRecords(queryId2, queries, answers);
      }
      if (storedRecord.addresses.size === 0) continue;
      const queryId = this.#findCommissionableQueryIdentifier(record.name, storedRecord);
      if (queryId === void 0) continue;
      queryMissingDataForInstances.delete(record.name);
      this.#finishWaiter(queryId, true, recordExisting);
    }
    if (queryMissingDataForInstances.size !== 0) {
      for (const name of Array.from(queryMissingDataForInstances.values())) {
        const storedRecord = this.#commissionableDeviceRecords.get(name);
        if (storedRecord === void 0) continue;
        const queryId = this.#findCommissionableQueryIdentifier("", storedRecord);
        if (queryId === void 0) continue;
        logger.debug(`Requesting more records for commissionable device ${name} (interface ${netInterface}).`);
        this.#setQueryRecords(
          queryId,
          [{ name, recordClass: DnsRecordClass.IN, recordType: DnsRecordType.ANY }],
          answers
        );
      }
    }
  }
  #parseTxtRecord(record) {
    const { value } = record;
    const result = {};
    if (Array.isArray(value)) {
      for (const item of value) {
        const [key, value2] = item.split("=");
        if (key === void 0 || value2 === void 0) continue;
        if (["SII", "SAI", "SAT", "T", "D", "CM", "DT", "PH", "ICD"].includes(key)) {
          const intValue = parseInt(value2);
          if (isNaN(intValue)) continue;
          result[key] = intValue;
        } else if (["VP", "DN", "RI", "PI"].includes(key)) {
          result[key] = value2;
        }
      }
    }
    if (result.T === void 0) {
      result.T = 0;
    } else if (result.T === 1) {
      result.T = 0;
    }
    if (result.ICD === void 0) {
      result.ICD = 0;
    }
    return result;
  }
  #parseCommissionableTxtRecord(record) {
    const { value, ttl } = record;
    if (!Array.isArray(value)) return void 0;
    const txtRecord = this.#parseTxtRecord(record);
    if (txtRecord === void 0 || txtRecord.D === void 0 || txtRecord.CM === void 0) {
      return void 0;
    }
    return {
      addresses: /* @__PURE__ */ new Map(),
      discoveredAt: Time.nowMs(),
      ttl: ttl * 1e3,
      ...txtRecord
    };
  }
  #expire() {
    const now = Time.nowMs();
    [...this.#operationalDeviceRecords.entries()].forEach(([recordKey, { addresses, discoveredAt, ttl }]) => {
      const expires = discoveredAt + this.#effectiveTTL(ttl);
      if (now <= expires) {
        [...addresses.entries()].forEach(([key, { discoveredAt: discoveredAt2, ttl: ttl2 }]) => {
          if (now < discoveredAt2 + this.#effectiveTTL(ttl2)) return;
          addresses.delete(key);
        });
      }
      if (now > expires && !addresses.size) {
        this.#operationalDeviceRecords.delete(recordKey);
      }
    });
    [...this.#commissionableDeviceRecords.entries()].forEach(([recordKey, { addresses, discoveredAt, ttl }]) => {
      const expires = discoveredAt + this.#effectiveTTL(ttl);
      if (now <= expires) {
        [...addresses.entries()].forEach(([key, { discoveredAt: discoveredAt2, ttl: ttl2 }]) => {
          if (now < discoveredAt2 + this.#effectiveTTL(ttl2)) return;
          addresses.delete(key);
        });
      }
      if (now > expires && !addresses.size) {
        this.#commissionableDeviceRecords.delete(recordKey);
      }
    });
  }
  static discoveryDataDiagnostics(data) {
    return Diagnostic.dict({
      SII: data.SII,
      SAI: data.SAI,
      SAT: data.SAT,
      T: data.T,
      DT: data.DT,
      PH: data.PH,
      ICD: data.ICD,
      VP: data.VP,
      DN: data.DN,
      RI: data.RI,
      PI: data.PI
    });
  }
  static deviceAddressDiagnostics(addresses) {
    return Array.from(addresses.values()).map(
      (address) => Diagnostic.dict({
        ip: address.ip,
        port: address.port,
        type: address.type
      })
    );
  }
}
export {
  MdnsScanner
};
//# sourceMappingURL=MdnsScanner.js.map
