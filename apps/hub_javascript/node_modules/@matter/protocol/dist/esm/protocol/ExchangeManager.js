/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  Crypto,
  Environmental,
  ImplementationError,
  Logger,
  MatterError,
  MatterFlowError,
  NotImplementedError,
  ObserverGroup,
  TransportInterfaceSet,
  UdpInterface
} from "#general";
import { NodeId, SECURE_CHANNEL_PROTOCOL_ID, SecureMessageType } from "#types";
import { MessageCodec, SessionType } from "../codec/MessageCodec.js";
import { SecureChannelMessenger } from "../securechannel/SecureChannelMessenger.js";
import { SessionManager, UNICAST_UNSECURE_SESSION_ID } from "../session/SessionManager.js";
import { ChannelManager } from "./ChannelManager.js";
import { MessageExchange } from "./MessageExchange.js";
import { DuplicateMessageError } from "./MessageReceptionState.js";
const logger = Logger.get("ExchangeManager");
const MAXIMUM_CONCURRENT_EXCHANGES_PER_SESSION = 5;
class ChannelNotConnectedError extends MatterError {
}
class MessageChannel {
  constructor(channel, session, closeCallback) {
    this.channel = channel;
    this.session = session;
    this.#closeCallback = closeCallback;
  }
  closed = false;
  #closeCallback;
  set closeCallback(callback) {
    this.#closeCallback = callback;
  }
  /** Is the underlying transport reliable? */
  get isReliable() {
    return this.channel.isReliable;
  }
  get type() {
    return this.channel.type;
  }
  /**
   * Max Payload size of the exchange which bases on the maximum payload size of the channel. The full encoded matter
   * message payload sent here can be as huge as allowed by the channel.
   */
  get maxPayloadSize() {
    return this.channel.maxPayloadSize;
  }
  send(message) {
    logger.debug("Message \xBB", MessageCodec.messageDiagnostics(message));
    const packet = this.session.encode(message);
    const bytes = MessageCodec.encodePacket(packet);
    if (bytes.length > this.maxPayloadSize) {
      logger.warn(
        `Matter message to send to ${this.name} is ${bytes.length}bytes long, which is larger than the maximum allowed size of ${this.maxPayloadSize}. This only works if both nodes support it.`
      );
    }
    return this.channel.send(bytes);
  }
  get name() {
    return `${this.channel.name} on session ${this.session.name}`;
  }
  async close() {
    const wasAlreadyClosed = this.closed;
    this.closed = true;
    await this.channel.close();
    if (!wasAlreadyClosed) {
      await this.#closeCallback?.();
    }
  }
}
class ExchangeManager {
  #transportInterfaces;
  #sessionManager;
  #channelManager;
  #exchangeCounter = new ExchangeCounter();
  #exchanges = /* @__PURE__ */ new Map();
  #protocols = /* @__PURE__ */ new Map();
  #listeners = /* @__PURE__ */ new Map();
  #closers = /* @__PURE__ */ new Set();
  #observers = new ObserverGroup(this);
  constructor(context) {
    this.#transportInterfaces = context.transportInterfaces;
    this.#sessionManager = context.sessionManager;
    this.#channelManager = context.channelManager;
    for (const transportInterface of this.#transportInterfaces) {
      this.#addListener(transportInterface);
    }
    this.#observers.on(this.#transportInterfaces.added, this.#addListener);
    this.#observers.on(this.#transportInterfaces.deleted, this.#deleteListener);
    this.#observers.on(this.#sessionManager.sessions.deleted, (session) => {
      if (!session.closingAfterExchangeFinished) {
        session.closer = this.#closeSession(session);
      }
    });
  }
  static [Environmental.create](env) {
    const instance = new ExchangeManager({
      transportInterfaces: env.get(TransportInterfaceSet),
      sessionManager: env.get(SessionManager),
      channelManager: env.get(ChannelManager)
    });
    env.set(ExchangeManager, instance);
    return instance;
  }
  hasProtocolHandler(protocolId) {
    return this.#protocols.has(protocolId);
  }
  getProtocolHandler(protocolId) {
    return this.#protocols.get(protocolId);
  }
  addProtocolHandler(protocol) {
    if (this.hasProtocolHandler(protocol.getId())) {
      throw new ImplementationError(`Handler for protocol ${protocol.getId()} already registered.`);
    }
    this.#protocols.set(protocol.getId(), protocol);
  }
  initiateExchange(address, protocolId) {
    return this.initiateExchangeWithChannel(this.#channelManager.getChannel(address), protocolId);
  }
  initiateExchangeWithChannel(channel, protocolId) {
    const exchangeId = this.#exchangeCounter.getIncrementedCounter();
    const exchangeIndex = exchangeId | 65536;
    const exchange = MessageExchange.initiate(this.#messageExchangeContextFor(channel), exchangeId, protocolId);
    this.#addExchange(exchangeIndex, exchange);
    return exchange;
  }
  async close() {
    for (const protocol of this.#protocols.values()) {
      await protocol.close();
    }
    for (const listeners of this.#listeners.keys()) {
      this.#deleteListener(listeners);
    }
    await Promise.allSettled(this.#closers);
    for (const exchange of this.#exchanges.values()) {
      await exchange.destroy();
    }
    this.#exchanges.clear();
  }
  async onMessage(channel, messageBytes) {
    const packet = MessageCodec.decodePacket(messageBytes);
    if (packet.header.sessionType === SessionType.Group)
      throw new NotImplementedError("Group messages are not supported");
    let session;
    if (packet.header.sessionType === SessionType.Unicast) {
      if (packet.header.sessionId === UNICAST_UNSECURE_SESSION_ID) {
        const initiatorNodeId = packet.header.sourceNodeId ?? NodeId.UNSPECIFIED_NODE_ID;
        session = this.#sessionManager.getUnsecureSession(initiatorNodeId) ?? this.#sessionManager.createInsecureSession({
          initiatorNodeId
        });
      } else {
        session = this.#sessionManager.getSession(packet.header.sessionId);
      }
    } else if (packet.header.sessionType === SessionType.Group) {
      if (packet.header.sourceNodeId !== void 0) {
      }
    }
    if (session === void 0) {
      throw new MatterFlowError(
        `Cannot find a session for ID ${packet.header.sessionId}${packet.header.sourceNodeId !== void 0 ? ` and source NodeId ${packet.header.sourceNodeId}` : ""}`
      );
    }
    const messageId = packet.header.messageId;
    let isDuplicate;
    try {
      session?.updateMessageCounter(packet.header.messageId, packet.header.sourceNodeId);
      isDuplicate = false;
    } catch (e) {
      DuplicateMessageError.accept(e);
      isDuplicate = true;
    }
    const aad = messageBytes.slice(0, messageBytes.length - packet.applicationPayload.length);
    const message = session.decode(packet, aad);
    const exchangeIndex = message.payloadHeader.isInitiatorMessage ? message.payloadHeader.exchangeId : message.payloadHeader.exchangeId | 65536;
    let exchange = this.#exchanges.get(exchangeIndex);
    if (exchange !== void 0 && (exchange.session.id !== session.id || exchange.isInitiator === message.payloadHeader.isInitiatorMessage)) {
      exchange = void 0;
    }
    if (exchange !== void 0) {
      await exchange.onMessageReceived(message, isDuplicate);
    } else {
      if (session.closingAfterExchangeFinished) {
        throw new MatterFlowError(
          `Session with ID ${packet.header.sessionId} marked for closure, decline new exchange creation.`
        );
      }
      const protocolHandler = this.#protocols.get(message.payloadHeader.protocolId);
      if (protocolHandler !== void 0 && message.payloadHeader.isInitiatorMessage && !isDuplicate) {
        if (message.payloadHeader.messageType == SecureMessageType.StandaloneAck && !message.payloadHeader.requiresAck) {
          logger.debug(
            `Ignoring unsolicited standalone ack message ${messageId} for protocol ${message.payloadHeader.protocolId} and exchange id ${message.payloadHeader.exchangeId}.`
          );
          return;
        }
        const exchange2 = MessageExchange.fromInitialMessage(
          this.#messageExchangeContextFor(await this.#channelManager.getOrCreateChannel(channel, session)),
          message
        );
        this.#addExchange(exchangeIndex, exchange2);
        await exchange2.onMessageReceived(message);
        await protocolHandler.onNewExchange(exchange2, message);
      } else if (message.payloadHeader.requiresAck) {
        const exchange2 = MessageExchange.fromInitialMessage(
          this.#messageExchangeContextFor(await this.#channelManager.getOrCreateChannel(channel, session)),
          message
        );
        this.#addExchange(exchangeIndex, exchange2);
        await exchange2.send(SecureMessageType.StandaloneAck, new Uint8Array(0), {
          includeAcknowledgeMessageId: message.packetHeader.messageId
        });
        await exchange2.close();
        logger.debug(
          `Ignoring unsolicited message ${messageId} for protocol ${message.payloadHeader.protocolId}.`
        );
      } else {
        if (protocolHandler === void 0) {
          throw new MatterFlowError(`Unsupported protocol ${message.payloadHeader.protocolId}`);
        }
        if (isDuplicate) {
          logger.info(
            `Ignoring duplicate message ${messageId} (requires no ack) for protocol ${message.payloadHeader.protocolId}.`
          );
          return;
        } else {
          logger.info(
            `Discarding unexpected message ${messageId} for protocol ${message.payloadHeader.protocolId}, exchangeIndex ${exchangeIndex} and sessionId ${session.id} : ${Logger.toJSON(message)}`
          );
        }
      }
    }
  }
  async deleteExchange(exchangeIndex) {
    const exchange = this.#exchanges.get(exchangeIndex);
    if (exchange === void 0) {
      logger.info(`Exchange with index ${exchangeIndex} to delete not found or already deleted.`);
      return;
    }
    const { session } = exchange;
    if (session.isSecure && session.closingAfterExchangeFinished) {
      logger.debug(
        `Exchange index ${exchangeIndex} Session ${session.name} is already marked for closure. Close session now.`
      );
      try {
        await this.#closeSession(session);
      } catch (error) {
        logger.error(`Error closing session ${session.name}. Ignoring.`, error);
      }
    }
    this.#exchanges.delete(exchangeIndex);
  }
  async #closeSession(session) {
    const sessionId = session.id;
    const sessionName = session.name;
    const asExchangeSession = session;
    if (asExchangeSession.closedByExchange) {
      return;
    }
    asExchangeSession.closedByExchange = true;
    for (const [_exchangeIndex, exchange] of this.#exchanges.entries()) {
      if (exchange.session.id === sessionId) {
        await exchange.destroy();
      }
    }
    if (session.sendCloseMessageWhenClosing) {
      const channel = this.#channelManager.getChannelForSession(session);
      logger.debug(`Channel for session ${session.name} is ${channel?.name}`);
      if (channel !== void 0) {
        const exchange = this.initiateExchangeWithChannel(channel, SECURE_CHANNEL_PROTOCOL_ID);
        logger.debug(`Initiated exchange ${!!exchange} to close session ${sessionName}`);
        if (exchange !== void 0) {
          try {
            const messenger = new SecureChannelMessenger(exchange);
            await messenger.sendCloseSession();
            await messenger.close();
          } catch (error) {
            if (error instanceof ChannelNotConnectedError) {
              logger.debug("Session already closed because channel is disconnected.");
            } else {
              logger.error("Error closing session", error);
            }
          }
        }
        await exchange.destroy();
      }
    }
    if (session.closingAfterExchangeFinished) {
      await session.destroy(false, false);
    }
  }
  #addExchange(exchangeIndex, exchange) {
    exchange.closed.on(() => this.deleteExchange(exchangeIndex));
    this.#exchanges.set(exchangeIndex, exchange);
    this.#cleanupSessionExchanges(exchange.session.id);
  }
  #cleanupSessionExchanges(sessionId) {
    if (sessionId === UNICAST_UNSECURE_SESSION_ID) {
      return;
    }
    const sessionExchanges = Array.from(this.#exchanges.values()).filter(
      (exchange) => exchange.session.id === sessionId && !exchange.isClosing
    );
    if (sessionExchanges.length <= MAXIMUM_CONCURRENT_EXCHANGES_PER_SESSION) {
      return;
    }
    const exchangeToClose = sessionExchanges[0];
    logger.debug(`Closing oldest exchange ${exchangeToClose.id} for session ${sessionId}`);
    exchangeToClose.close().catch((error) => logger.error("Error closing exchange", error));
  }
  #messageExchangeContextFor(channel) {
    return {
      channel,
      localSessionParameters: this.#sessionManager.sessionParameters,
      resubmissionStarted: () => this.#sessionManager.resubmissionStarted.emit(channel.session)
    };
  }
  #addListener(transportInterface) {
    const udpInterface = transportInterface instanceof UdpInterface;
    this.#listeners.set(
      transportInterface,
      transportInterface.onData((socket, data) => {
        if (udpInterface && data.length > socket.maxPayloadSize) {
          logger.warn(
            `Ignoring UDP message with size ${data.length} from ${socket.name}, which is larger than the maximum allowed size of ${socket.maxPayloadSize}.`
          );
          return;
        }
        try {
          this.onMessage(socket, data).catch(
            (error) => logger.info(error instanceof MatterError ? error.message : error)
          );
        } catch (error) {
          logger.info(
            "Ignoring UDP message with error",
            error instanceof MatterError ? error.message : error
          );
        }
      })
    );
  }
  #deleteListener(transportInterface) {
    const listener = this.#listeners.get(transportInterface);
    if (listener === void 0) {
      return;
    }
    this.#listeners.delete(transportInterface);
    const closer = listener.close().catch((e) => logger.error("Error closing network listener", e)).finally(() => this.#closers.delete(closer));
    this.#closers.add(closer);
  }
}
class ExchangeCounter {
  exchangeCounter = Crypto.getRandomUInt16();
  getIncrementedCounter() {
    this.exchangeCounter++;
    if (this.exchangeCounter > 65535) {
      this.exchangeCounter = 0;
    }
    return this.exchangeCounter;
  }
}
export {
  ChannelNotConnectedError,
  ExchangeCounter,
  ExchangeManager,
  MessageChannel
};
//# sourceMappingURL=ExchangeManager.js.map
