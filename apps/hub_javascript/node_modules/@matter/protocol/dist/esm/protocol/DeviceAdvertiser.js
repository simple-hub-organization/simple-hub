/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { CommissioningMode } from "#common/InstanceBroadcaster.js";
import { FabricManager } from "#fabric/FabricManager.js";
import {
  AsyncObservable,
  Diagnostic,
  Environmental,
  Logger,
  MatterAggregateError,
  Mutex,
  ObserverGroup,
  Time
} from "#general";
import { SessionManager } from "#session/SessionManager.js";
import { DEVICE_ANNOUNCEMENT_DURATION_MS, DEVICE_ANNOUNCEMENT_INTERVAL_MS } from "#types";
const logger = Logger.get("DeviceAdvertiser");
class DeviceAdvertiser {
  #context;
  #broadcasters = /* @__PURE__ */ new Set();
  #timedOut = AsyncObservable();
  #operationalModeEnded = new AsyncObservable();
  #observers = new ObserverGroup();
  #interval;
  #startTime = null;
  #isClosing = false;
  #commissioningMode = CommissioningMode.NotCommissioning;
  // Currently we do not put much effort into synchronizing announcements as it probably isn't really necessary.  But
  // this mutex prevents automated announcements from piling up and allows us to ensure announcements are complete on
  // close
  #mutex = new Mutex(this);
  constructor(context) {
    this.#context = context;
    this.#interval = Time.getPeriodicTimer(
      "Server node announcement",
      DEVICE_ANNOUNCEMENT_INTERVAL_MS,
      () => (
        // Announcement needs to await a previous announcement because otherwise in testing at least announcement
        // may crash if started simultaneously
        this.#mutex.run(() => this.advertise())
      )
    );
    this.#observers.on(this.#context.fabrics.events.deleted, async () => {
      if (this.#context.fabrics.length === 0) {
        await this.#exitOperationalMode();
      }
    });
    this.#observers.on(this.#context.sessions.resubmissionStarted, (session) => {
      logger.debug(`Resubmission started, re-announce node ${session?.nodeId}`);
      this.advertise(true).catch((error) => logger.warn("Error sending announcement:", error));
    });
    this.#observers.on(this.#context.sessions.subscriptionsChanged, (_session, subscription) => {
      if (subscription.isCanceledByPeer) {
        logger.debug(`Subscription canceled by peer, re-announce`);
        this.startAdvertising().catch((error) => logger.warn("Error sending announcement:", error));
      }
    });
  }
  static [Environmental.create](env) {
    const instance = new DeviceAdvertiser({
      fabrics: env.get(FabricManager),
      sessions: env.get(SessionManager)
    });
    env.set(DeviceAdvertiser, instance);
    return instance;
  }
  /**
   * Emitted when the advertising window closes with no response.
   */
  get timedOut() {
    return this.#timedOut;
  }
  /**
   * Emitted when the device stops advertising due to decommissioning.
   */
  get operationalModeEnded() {
    return this.#operationalModeEnded;
  }
  async enterCommissioningMode(mode, deviceData) {
    this.#commissioningMode = mode;
    for (const broadcaster of this.#broadcasters) {
      await broadcaster.setCommissionMode(mode, deviceData);
    }
    await this.startAdvertising();
  }
  async exitCommissioningMode() {
    this.#commissioningMode = CommissioningMode.NotCommissioning;
    this.#interval.stop();
    this.#startTime = null;
    for (const broadcaster of this.#broadcasters) {
      await broadcaster.expireCommissioningAnnouncement();
    }
  }
  async startAdvertising() {
    if (this.#isClosing) return;
    if (this.#interval.isRunning) {
      this.#interval.stop();
    }
    this.#startTime = Time.nowMs();
    this.#interval.start();
    await this.advertise();
  }
  async advertise(once = false) {
    if (!once) {
      if (this.#startTime !== null && Time.nowMs() - this.#startTime > DEVICE_ANNOUNCEMENT_DURATION_MS) {
        logger.debug("Announcement duration reached, stop announcing");
        await this.#timedOut.emit();
        return;
      }
      if (this.#commissioningMode !== CommissioningMode.NotCommissioning) {
        for (const broadcaster of this.#broadcasters) {
          await broadcaster.announce();
        }
        return;
      }
    }
    const fabrics = this.#context.fabrics;
    if (fabrics.length) {
      let fabricsWithoutSessions = 0;
      for (const fabric of fabrics) {
        const session = this.#context.sessions.getSessionForNode(fabric.addressOf(fabric.rootNodeId));
        if (session === void 0 || !session.isSecure || session.subscriptions.size === 0) {
          fabricsWithoutSessions++;
          logger.debug("Announcing", Diagnostic.dict({ fabric: fabric.fabricId }));
        }
      }
      for (const broadcaster of this.#broadcasters) {
        await broadcaster.setFabrics(fabrics.fabrics);
        if (fabricsWithoutSessions > 0 || this.#commissioningMode !== CommissioningMode.NotCommissioning) {
          await broadcaster.announce();
        }
      }
    } else {
      await this.#exitOperationalMode();
      await this.#operationalModeEnded.emit();
    }
  }
  async advertiseFabrics(fabrics, expireCommissioningAnnouncement = false) {
    for (const broadcaster of this.#broadcasters) {
      await broadcaster.setFabrics(fabrics, expireCommissioningAnnouncement);
      await broadcaster.announce();
    }
  }
  async #exitOperationalMode() {
    for (const broadcaster of this.#broadcasters) {
      await broadcaster.expireFabricAnnouncement();
    }
  }
  async close() {
    await this.#mutex;
    this.#observers.close();
    this.#interval.stop();
    await this.clearBroadcasters();
  }
  hasBroadcaster(broadcaster) {
    return this.#broadcasters.has(broadcaster);
  }
  addBroadcaster(broadcaster) {
    this.#broadcasters.add(broadcaster);
  }
  async deleteBroadcaster(broadcaster) {
    if (this.#broadcasters.delete(broadcaster)) {
      await broadcaster.expireAllAnnouncements();
    }
  }
  async clearBroadcasters() {
    const broadcasters = [...this.#broadcasters];
    const closed = Promise.allSettled(broadcasters.map((b) => b.close()));
    this.#broadcasters.clear();
    const errors = (await closed).map((status) => status.status === "rejected" ? status.reason : void 0).filter((reason) => reason !== void 0);
    if (errors.length) {
      throw new MatterAggregateError(errors, "Error closing broadcasters");
    }
  }
}
export {
  DeviceAdvertiser
};
//# sourceMappingURL=DeviceAdvertiser.js.map
