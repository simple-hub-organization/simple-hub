"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var CaseClient_exports = {};
__export(CaseClient_exports, {
  CaseClient: () => CaseClient
});
module.exports = __toCommonJS(CaseClient_exports);
var import_general = require("#general");
var import_CertificateManager = require("../../certificate/CertificateManager.js");
var import_CaseMessages = require("./CaseMessages.js");
var import_CaseMessenger = require("./CaseMessenger.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("CaseClient");
class CaseClient {
  #sessions;
  constructor(sessions) {
    this.#sessions = sessions;
  }
  async pair(exchange, fabric, peerNodeId, expectedProcessingTimeMs) {
    const messenger = new import_CaseMessenger.CaseClientMessenger(exchange, expectedProcessingTimeMs);
    const initiatorRandom = import_general.Crypto.getRandom();
    const initiatorSessionId = await this.#sessions.getNextAvailableSessionId();
    const { operationalIdentityProtectionKey, operationalCert: nodeOpCert, intermediateCACert } = fabric;
    const { publicKey: initiatorEcdhPublicKey, ecdh } = import_general.Crypto.ecdhGeneratePublicKey();
    let sigma1Bytes;
    let resumed = false;
    let resumptionRecord = this.#sessions.findResumptionRecordByAddress(fabric.addressOf(peerNodeId));
    if (resumptionRecord !== void 0) {
      const { sharedSecret, resumptionId } = resumptionRecord;
      const resumeKey = await import_general.Crypto.hkdf(
        sharedSecret,
        import_general.Bytes.concat(initiatorRandom, resumptionId),
        import_CaseMessages.KDFSR1_KEY_INFO
      );
      const initiatorResumeMic = import_general.Crypto.encrypt(resumeKey, new Uint8Array(0), import_CaseMessages.RESUME1_MIC_NONCE);
      sigma1Bytes = await messenger.sendSigma1({
        initiatorSessionId,
        destinationId: fabric.getDestinationId(peerNodeId, initiatorRandom),
        initiatorEcdhPublicKey,
        initiatorRandom,
        resumptionId,
        initiatorResumeMic,
        initiatorSessionParams: this.#sessions.sessionParameters
      });
    } else {
      sigma1Bytes = await messenger.sendSigma1({
        initiatorSessionId,
        destinationId: fabric.getDestinationId(peerNodeId, initiatorRandom),
        initiatorEcdhPublicKey,
        initiatorRandom,
        initiatorSessionParams: this.#sessions.sessionParameters
      });
    }
    let secureSession;
    const { sigma2Bytes, sigma2, sigma2Resume } = await messenger.readSigma2();
    if (sigma2Resume !== void 0) {
      if (resumptionRecord === void 0) throw new import_general.UnexpectedDataError("Received an unexpected sigma2Resume.");
      const { sharedSecret, fabric: fabric2, sessionParameters: resumptionSessionParams } = resumptionRecord;
      const { responderSessionId: peerSessionId, resumptionId, resumeMic } = sigma2Resume;
      const sessionParameters = {
        ...exchange.session.parameters,
        ...resumptionSessionParams ?? {}
      };
      const resumeSalt = import_general.Bytes.concat(initiatorRandom, resumptionId);
      const resumeKey = await import_general.Crypto.hkdf(sharedSecret, resumeSalt, import_CaseMessages.KDFSR2_KEY_INFO);
      import_general.Crypto.decrypt(resumeKey, resumeMic, import_CaseMessages.RESUME2_MIC_NONCE);
      const secureSessionSalt = import_general.Bytes.concat(initiatorRandom, resumptionRecord.resumptionId);
      secureSession = await this.#sessions.createSecureSession({
        sessionId: initiatorSessionId,
        fabric: fabric2,
        peerNodeId,
        peerSessionId,
        sharedSecret,
        salt: secureSessionSalt,
        isInitiator: true,
        isResumption: true,
        peerSessionParameters: sessionParameters
      });
      await messenger.sendSuccess();
      logger.info(
        `Case client: session resumed with ${messenger.getChannelName()} and parameters`,
        import_general.Diagnostic.dict(secureSession.parameters)
      );
      resumptionRecord.resumptionId = resumptionId;
      resumptionRecord.sessionParameters = secureSession.parameters;
      resumed = true;
    } else {
      const {
        responderEcdhPublicKey: peerEcdhPublicKey,
        encrypted: peerEncrypted,
        responderRandom,
        responderSessionId: peerSessionId,
        responderSessionParams
      } = sigma2;
      const sessionParameters = {
        ...exchange.session.parameters,
        ...responderSessionParams ?? {}
      };
      const sharedSecret = import_general.Crypto.ecdhGenerateSecret(peerEcdhPublicKey, ecdh);
      const sigma2Salt = import_general.Bytes.concat(
        operationalIdentityProtectionKey,
        responderRandom,
        peerEcdhPublicKey,
        import_general.Crypto.hash(sigma1Bytes)
      );
      const sigma2Key = await import_general.Crypto.hkdf(sharedSecret, sigma2Salt, import_CaseMessages.KDFSR2_INFO);
      const peerEncryptedData = import_general.Crypto.decrypt(sigma2Key, peerEncrypted, import_CaseMessages.TBE_DATA2_NONCE);
      const {
        nodeOpCert: peerNewOpCert,
        intermediateCACert: peerIntermediateCACert,
        signature: peerSignature,
        resumptionId: peerResumptionId
      } = import_CaseMessages.TlvEncryptedDataSigma2.decode(peerEncryptedData);
      const peerSignatureData = import_CaseMessages.TlvSignedData.encode({
        nodeOpCert: peerNewOpCert,
        intermediateCACert: peerIntermediateCACert,
        ecdhPublicKey: peerEcdhPublicKey,
        peerEcdhPublicKey: initiatorEcdhPublicKey
      });
      const {
        ellipticCurvePublicKey: peerPublicKey,
        subject: { fabricId: peerFabricIdNOCert, nodeId: peerNodeIdNOCert }
      } = import_CertificateManager.TlvOperationalCertificate.decode(peerNewOpCert);
      import_general.Crypto.verify((0, import_general.PublicKey)(peerPublicKey), peerSignatureData, peerSignature);
      if (peerNodeIdNOCert !== peerNodeId) {
        throw new import_general.UnexpectedDataError(
          "The node ID in the peer certificate doesn't match the expected peer node ID"
        );
      }
      if (peerNodeIdNOCert !== peerNodeId) {
        throw new import_general.UnexpectedDataError(
          "The node ID in the peer certificate doesn't match the expected peer node ID"
        );
      }
      if (peerFabricIdNOCert !== fabric.fabricId) {
        throw new import_general.UnexpectedDataError(
          "The fabric ID in the peer certificate doesn't match the expected fabric ID"
        );
      }
      if (peerIntermediateCACert !== void 0) {
        const {
          subject: { fabricId: peerFabricIdIcaCert }
        } = import_CertificateManager.TlvIntermediateCertificate.decode(peerIntermediateCACert);
        if (peerFabricIdIcaCert !== fabric.fabricId) {
          throw new import_general.UnexpectedDataError(
            "The fabric ID in the peer intermediate CA certificate doesn't match the expected fabric ID"
          );
        }
      }
      fabric.verifyCredentials(peerNewOpCert, peerIntermediateCACert);
      const sigma3Salt = import_general.Bytes.concat(operationalIdentityProtectionKey, import_general.Crypto.hash([sigma1Bytes, sigma2Bytes]));
      const sigma3Key = await import_general.Crypto.hkdf(sharedSecret, sigma3Salt, import_CaseMessages.KDFSR3_INFO);
      const signatureData = import_CaseMessages.TlvSignedData.encode({
        nodeOpCert,
        intermediateCACert,
        ecdhPublicKey: initiatorEcdhPublicKey,
        peerEcdhPublicKey
      });
      const signature = fabric.sign(signatureData);
      const encryptedData = import_CaseMessages.TlvEncryptedDataSigma3.encode({ nodeOpCert, intermediateCACert, signature });
      const encrypted = import_general.Crypto.encrypt(sigma3Key, encryptedData, import_CaseMessages.TBE_DATA3_NONCE);
      const sigma3Bytes = await messenger.sendSigma3({ encrypted });
      await messenger.waitForSuccess("Success after CASE Sigma3");
      const secureSessionSalt = import_general.Bytes.concat(
        operationalIdentityProtectionKey,
        import_general.Crypto.hash([sigma1Bytes, sigma2Bytes, sigma3Bytes])
      );
      secureSession = await this.#sessions.createSecureSession({
        sessionId: initiatorSessionId,
        fabric,
        peerNodeId,
        peerSessionId,
        sharedSecret,
        salt: secureSessionSalt,
        isInitiator: true,
        isResumption: false,
        peerSessionParameters: sessionParameters
      });
      logger.info(
        `Case client: Paired successfully with ${messenger.getChannelName()} and parameters`,
        import_general.Diagnostic.dict(secureSession.parameters)
      );
      resumptionRecord = {
        fabric,
        peerNodeId,
        sharedSecret,
        resumptionId: peerResumptionId,
        sessionParameters: secureSession.parameters
      };
    }
    await messenger.close();
    await this.#sessions.saveResumptionRecord(resumptionRecord);
    return { session: secureSession, resumed };
  }
}
//# sourceMappingURL=CaseClient.js.map
