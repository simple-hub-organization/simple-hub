/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MaybePromise } from "#general";
import { PeerAddress } from "#peer/PeerAddress.js";
import type { MessageExchange } from "#protocol/MessageExchange.js";
import { SecureSession } from "#session/SecureSession.js";
import { TlvEventFilter, TlvSchema, TypeFromSchema } from "#types";
import { AnyAttributeServer } from "../cluster/server/AttributeServer.js";
import { AnyEventServer } from "../cluster/server/EventServer.js";
import { EventStorageData } from "./EventHandler.js";
import { InteractionEndpointStructure } from "./InteractionEndpointStructure.js";
import { InteractionServerMessenger } from "./InteractionMessenger.js";
import { AttributePath, EventPath } from "./InteractionServer.js";
import { Subscription, SubscriptionCriteria } from "./Subscription.js";
export declare const MAX_INTERVAL_PUBLISHER_LIMIT_S: number; /** 1 hour */
export declare const INTERNAL_INTERVAL_PUBLISHER_LIMIT_S: number; /** 3 min */
export declare const MIN_INTERVAL_S = 2;
export declare const DEFAULT_RANDOMIZATION_WINDOW_S = 10;
/**
 * Server options that control subscription handling.
 */
export interface ServerSubscriptionConfig {
    /**
     * Optional maximum subscription interval to use for sending subscription reports. It will be used if not too
     * low and inside the range requested by the connected controller.
     */
    maxIntervalSeconds: number;
    /**
     * Optional minimum subscription interval to use for sending subscription reports. It will be used when other
     * calculated values are smaller than it. Use this to make sure your device hardware can handle the load and to
     * set limits.
     */
    minIntervalSeconds: number;
    /**
     * Optional subscription randomization window to use for sending subscription reports. This specifies a window
     * in seconds from which a random part is added to the calculated maximum interval to make sure that devices
     * that get powered on in parallel not all send at the same timepoint.
     */
    randomizationWindowSeconds: number;
}
export declare namespace ServerSubscriptionConfig {
    /**
     * Validate options and set defaults.
     *
     * @returns the resulting options
     */
    function of(options?: Partial<ServerSubscriptionConfig>): {
        maxIntervalSeconds: number;
        minIntervalSeconds: number;
        randomizationWindowSeconds: number;
    };
}
/**
 * Interface between {@link ServerSubscription} and the local Matter environment.
 */
export interface ServerSubscriptionContext {
    session: SecureSession;
    structure: InteractionEndpointStructure;
    readAttribute(path: AttributePath, attribute: AnyAttributeServer<unknown>, offline?: boolean): Promise<{
        version: number;
        value: unknown;
    }>;
    readEvent(path: EventPath, event: AnyEventServer<any, any>, eventFilters: TypeFromSchema<typeof TlvEventFilter>[] | undefined): Promise<EventStorageData<unknown>[]>;
    initiateExchange(address: PeerAddress, protocolId: number): MessageExchange;
}
/**
 * Implements the server side of a single subscription.
 */
export declare class ServerSubscription extends Subscription {
    #private;
    private readonly minIntervalFloorMs;
    private readonly maxIntervalCeilingMs;
    private readonly peerAddress;
    private sendingUpdateInProgress;
    private sendNextUpdateImmediately;
    private sendUpdateErrorCounter;
    private attributeUpdatePromises;
    constructor(options: {
        id: number;
        context: ServerSubscriptionContext;
        criteria: SubscriptionCriteria;
        minIntervalFloor: number;
        maxIntervalCeiling: number;
        subscriptionOptions: ServerSubscriptionConfig;
    });
    private determineSendingIntervals;
    private registerNewAttributes;
    unregisterAttributeListeners(list: Array<string>): void;
    private registerNewEvents;
    unregisterEventListeners(list: Array<string>): void;
    /**
     * Update the session after an endpoint structure change. The method will initialize all missing new attributes and
     * events and will remove listeners no longer needed.
     * Newly added attributes are then treated as "changed values" and will be sent as subscription data update to the
     * controller. The data of newly added events are not sent automatically.
     */
    updateSubscription(): Promise<void>;
    get maxInterval(): number;
    get sendInterval(): number;
    activateSendingUpdates(): void;
    /**
     * Check if data should be sent straight away or delayed because the minimum interval is not reached. Delay real
     * sending by 50ms in any case to mke sure to catch all updates.
     */
    prepareDataUpdate(): void;
    /**
     * Determine all attributes that have changed since the last update and send them tout to the subscriber.
     */
    sendUpdate(): Promise<void>;
    sendInitialReport(messenger: InteractionServerMessenger): Promise<void>;
    attributeChangeListener<T>(path: AttributePath, schema: TlvSchema<T>, version: number, value: T): void;
    attributeChangeHandler<T>(path: AttributePath, schema: TlvSchema<T>, version: number, value: T): MaybePromise<void>;
    eventChangeListener<T>(path: EventPath, schema: TlvSchema<T>, newEvent: EventStorageData<T>): void;
    flush(): Promise<void>;
    close(graceful?: boolean): Promise<void>;
    private sendUpdateMessage;
}
//# sourceMappingURL=ServerSubscription.d.ts.map