"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var EventHandler_exports = {};
__export(EventHandler_exports, {
  EventHandler: () => EventHandler
});
module.exports = __toCommonJS(EventHandler_exports);
var import_general = require("#general");
var import_types = require("#types");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("EventHandler");
const MAX_EVENTS = 1e4;
class EventHandler {
  #eventNumber = (0, import_types.EventNumber)(0);
  #storedEventCount = 0;
  #eventStorage;
  #events = {
    [import_types.EventPriority.Critical]: new Array(),
    [import_types.EventPriority.Info]: new Array(),
    [import_types.EventPriority.Debug]: new Array()
  };
  #construction;
  get construction() {
    return this.#construction;
  }
  static async create(eventStorage) {
    const handler = new EventHandler(eventStorage);
    await handler.#construction;
    return handler;
  }
  static [import_general.Environmental.create](env) {
    const instance = new EventHandler(env.get(import_general.StorageManager).createContext("events"));
    env.set(EventHandler, instance);
    return instance;
  }
  constructor(eventStorage) {
    this.#eventStorage = eventStorage;
    this.#construction = (0, import_general.Construction)(this, async () => {
      this.#eventNumber = await this.#eventStorage.get("lastEventNumber", this.#eventNumber);
      logger.debug(`Set/Restore last event number: ${this.#eventNumber}`);
    });
  }
  async clear() {
    await this.construction;
    await this.#eventStorage.clear();
    this.#eventNumber = (0, import_types.EventNumber)(0);
    this.#storedEventCount = 0;
    for (const list of Object.values(this.#events)) {
      list.length = 0;
    }
  }
  getEvents(eventPath, filters, filterForFabricIndex) {
    const eventFilter = filters !== void 0 && filters.length > 0 ? (event) => filters.some(
      (filter) => filter.eventMin !== void 0 && event.eventNumber >= (0, import_types.EventNumber)(filter.eventMin)
    ) : () => true;
    const events = new Array();
    const { endpointId, clusterId, eventId } = eventPath;
    for (const priority of [import_types.EventPriority.Critical, import_types.EventPriority.Info, import_types.EventPriority.Debug]) {
      const eventsToCheck = this.#events[priority];
      for (const event of eventsToCheck) {
        if (endpointId === event.endpointId && clusterId === event.clusterId && eventId === event.eventId) {
          if (eventFilter(event)) {
            events.push(event);
          }
        }
      }
    }
    logger.debug(
      `Got ${events.length} events for ${(0, import_types.resolveEventName)(eventPath)} with filters: ${import_general.Logger.toJSON(filters)}`
    );
    if (filterForFabricIndex !== void 0) {
      return events.filter(({ data }) => !("fabricIndex" in data) || data.fabricIndex === filterForFabricIndex);
    }
    return events;
  }
  pushEvent(event) {
    const eventData = {
      eventNumber: (0, import_types.EventNumber)(++this.#eventNumber),
      ...event
    };
    logger.debug(`Received event: ${import_general.Logger.toJSON(eventData)}`);
    this.#events[event.priority].push(eventData);
    this.#storedEventCount++;
    const setPromise = this.#eventStorage.set("lastEventNumber", this.#eventNumber);
    if (import_general.MaybePromise.is(setPromise)) {
      return setPromise.then(() => {
        this.cleanUpEvents();
        return eventData;
      });
    }
    this.cleanUpEvents();
    return eventData;
  }
  cleanUpEvents() {
    if (this.#storedEventCount < MAX_EVENTS) return;
    const eventsToDelete = this.#storedEventCount - MAX_EVENTS;
    for (const priority of [import_types.EventPriority.Debug, import_types.EventPriority.Info, import_types.EventPriority.Critical]) {
      const events = this.#events[priority];
      if (events.length > 0) {
        const removedEvents = events.splice(0, events.length - eventsToDelete);
        logger.debug(`Removed ${removedEvents.length} events from priority ${priority}`);
        return;
      }
    }
  }
}
//# sourceMappingURL=EventHandler.js.map
