"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ServerSubscription_exports = {};
__export(ServerSubscription_exports, {
  DEFAULT_RANDOMIZATION_WINDOW_S: () => DEFAULT_RANDOMIZATION_WINDOW_S,
  INTERNAL_INTERVAL_PUBLISHER_LIMIT_S: () => INTERNAL_INTERVAL_PUBLISHER_LIMIT_S,
  MAX_INTERVAL_PUBLISHER_LIMIT_S: () => MAX_INTERVAL_PUBLISHER_LIMIT_S,
  MIN_INTERVAL_S: () => MIN_INTERVAL_S,
  ServerSubscription: () => ServerSubscription,
  ServerSubscriptionConfig: () => ServerSubscriptionConfig
});
module.exports = __toCommonJS(ServerSubscription_exports);
var import_general = require("#general");
var import_model = require("#model");
var import_types = require("#types");
var import_AttributeServer = require("../cluster/server/AttributeServer.js");
var import_EventServer = require("../cluster/server/EventServer.js");
var import_ChannelManager = require("../protocol/ChannelManager.js");
var import_InteractionMessenger = require("./InteractionMessenger.js");
var import_InteractionServer = require("./InteractionServer.js");
var import_Subscription = require("./Subscription.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("ServerSubscription");
const MAX_INTERVAL_PUBLISHER_LIMIT_S = 60 * 60;
const INTERNAL_INTERVAL_PUBLISHER_LIMIT_S = 3 * 60;
const MIN_INTERVAL_S = 2;
const DEFAULT_RANDOMIZATION_WINDOW_S = 10;
var ServerSubscriptionConfig;
((ServerSubscriptionConfig2) => {
  function of(options) {
    return {
      maxIntervalSeconds: options?.maxIntervalSeconds ?? INTERNAL_INTERVAL_PUBLISHER_LIMIT_S,
      minIntervalSeconds: Math.max(options?.minIntervalSeconds ?? MIN_INTERVAL_S, MIN_INTERVAL_S),
      randomizationWindowSeconds: options?.randomizationWindowSeconds ?? DEFAULT_RANDOMIZATION_WINDOW_S
    };
  }
  ServerSubscriptionConfig2.of = of;
})(ServerSubscriptionConfig || (ServerSubscriptionConfig = {}));
class ServerSubscription extends import_Subscription.Subscription {
  #context;
  #structure;
  #lastUpdateTimeMs = 0;
  #updateTimer;
  #sendDelayTimer;
  #outstandingAttributeUpdates = /* @__PURE__ */ new Map();
  #outstandingEventUpdates = /* @__PURE__ */ new Set();
  #attributeListeners = /* @__PURE__ */ new Map();
  #eventListeners = /* @__PURE__ */ new Map();
  #sendUpdatesActivated = false;
  #maxIntervalMs;
  #sendIntervalMs;
  minIntervalFloorMs;
  maxIntervalCeilingMs;
  peerAddress;
  sendingUpdateInProgress = false;
  sendNextUpdateImmediately = false;
  sendUpdateErrorCounter = 0;
  attributeUpdatePromises = /* @__PURE__ */ new Set();
  constructor(options) {
    const { id, context, criteria, minIntervalFloor, maxIntervalCeiling, subscriptionOptions } = options;
    super(context.session, id, criteria);
    this.#context = context;
    this.#structure = context.structure;
    this.peerAddress = this.session.peerAddress;
    this.minIntervalFloorMs = minIntervalFloor * 1e3;
    this.maxIntervalCeilingMs = maxIntervalCeiling * 1e3;
    const { maxInterval, sendInterval } = this.determineSendingIntervals(
      subscriptionOptions.minIntervalSeconds * 1e3,
      subscriptionOptions.maxIntervalSeconds * 1e3,
      subscriptionOptions.randomizationWindowSeconds * 1e3
    );
    this.#maxIntervalMs = maxInterval;
    this.#sendIntervalMs = sendInterval;
    this.#updateTimer = import_general.Time.getTimer("Subscription update", this.#sendIntervalMs, () => this.prepareDataUpdate());
    this.#sendDelayTimer = import_general.Time.getTimer(
      "Subscription delay",
      50,
      () => this.sendUpdate().catch((error) => logger.warn("Sending subscription update failed:", error))
    );
  }
  determineSendingIntervals(subscriptionMinIntervalMs, subscriptionMaxIntervalMs, subscriptionRandomizationWindowMs) {
    const maxInterval = Math.min(
      Math.max(
        subscriptionMinIntervalMs,
        Math.max(this.minIntervalFloorMs, Math.min(subscriptionMaxIntervalMs, this.maxIntervalCeilingMs))
      ) + Math.floor(subscriptionRandomizationWindowMs * Math.random()),
      MAX_INTERVAL_PUBLISHER_LIMIT_S * 1e3
    );
    let sendInterval = Math.floor(maxInterval / 2);
    if (sendInterval < 6e4) {
      sendInterval = Math.max(this.minIntervalFloorMs, Math.floor(maxInterval * 0.8));
    }
    if (sendInterval < subscriptionMinIntervalMs) {
      logger.warn(
        `Determined subscription send interval of ${sendInterval}ms is too low. Using maxInterval (${maxInterval}ms) instead.`
      );
      sendInterval = subscriptionMinIntervalMs;
    }
    return { maxInterval, sendInterval };
  }
  registerNewAttributes() {
    const newAttributes = new Array();
    const attributeErrors = new Array();
    const formerAttributes = new Set(this.#attributeListeners.keys());
    if (this.criteria.attributeRequests !== void 0) {
      this.criteria.attributeRequests.forEach((path) => {
        const attributes = this.#structure.getAttributes([path]);
        if (attributes.length === 0) {
          const { endpointId, clusterId, attributeId } = path;
          if (endpointId === void 0 || clusterId === void 0 || attributeId === void 0) {
            logger.debug(
              `Subscription attribute ${this.#structure.resolveAttributeName(
                path
              )}: ignore non-existing attribute`
            );
          } else {
            try {
              this.#structure.validateConcreteAttributePath(endpointId, clusterId, attributeId);
              throw new import_general.InternalError(
                "validateConcreteAttributePath check should throw StatusResponseError but did not."
              );
            } catch (e) {
              import_types.StatusResponseError.accept(e);
              logger.debug(
                `Subscription attribute ${this.#structure.resolveAttributeName(
                  path
                )}: unsupported path: Status=${e.code}`
              );
              attributeErrors.push({ path, status: { status: e.code } });
            }
          }
          return;
        }
        attributes.forEach(({ path: path2, attribute }) => {
          formerAttributes.delete((0, import_InteractionServer.attributePathToId)(path2));
          const existingAttributeListener = this.#attributeListeners.get((0, import_InteractionServer.attributePathToId)(path2));
          if (existingAttributeListener !== void 0) {
            const { attribute: existingAttribute, listener: existingListener } = existingAttributeListener;
            if (existingAttribute !== attribute) {
              if (existingListener !== void 0) {
                existingAttribute.removeValueChangeListener(existingListener);
              }
              this.#attributeListeners.delete((0, import_InteractionServer.attributePathToId)(path2));
            } else {
              return;
            }
          }
          if (attribute.isSubscribable) {
            const listener = (value, version) => this.attributeChangeListener(path2, attribute.schema, version, value);
            attribute.addValueChangeListener(listener);
            this.#attributeListeners.set((0, import_InteractionServer.attributePathToId)(path2), { attribute, listener });
          } else {
            this.#attributeListeners.set((0, import_InteractionServer.attributePathToId)(path2), { attribute });
          }
          newAttributes.push({ path: path2, attribute });
        });
      });
    }
    this.unregisterAttributeListeners(Array.from(formerAttributes.values()));
    return { newAttributes, attributeErrors };
  }
  unregisterAttributeListeners(list) {
    for (const pathId of list) {
      const existingAttributeListener = this.#attributeListeners.get(pathId);
      if (existingAttributeListener !== void 0) {
        const { attribute, listener } = existingAttributeListener;
        if (listener !== void 0) {
          attribute.removeValueChangeListener(listener);
        }
        this.#attributeListeners.delete(pathId);
      }
    }
  }
  registerNewEvents() {
    const newEvents = new Array();
    const eventErrors = new Array();
    const formerEvents = new Set(this.#eventListeners.keys());
    if (this.criteria.eventRequests !== void 0) {
      this.criteria.eventRequests.forEach((path) => {
        const events = this.#structure.getEvents([path]);
        if (events.length === 0) {
          const { endpointId, clusterId, eventId } = path;
          if (endpointId === void 0 || clusterId === void 0 || eventId === void 0) {
            logger.debug(
              `Subscription event ${this.#structure.resolveEventName(path)}: ignore non-existing event`
            );
          } else {
            try {
              this.#structure.validateConcreteEventPath(endpointId, clusterId, eventId);
              throw new import_general.InternalError(
                "validateConcreteEventPath should throw StatusResponseError but did not."
              );
            } catch (e) {
              import_types.StatusResponseError.accept(e);
              logger.debug(
                `Subscription event ${this.#structure.resolveEventName(
                  path
                )}: unsupported path: Status=${e.code}`
              );
              eventErrors.push({ path, status: { status: e.code } });
            }
          }
          return;
        }
        events.forEach(({ path: path2, event }) => {
          formerEvents.delete((0, import_InteractionServer.eventPathToId)(path2));
          const existingEventListener = this.#eventListeners.get((0, import_InteractionServer.eventPathToId)(path2));
          if (existingEventListener !== void 0) {
            const { event: existingEvent, listener: existingListener } = existingEventListener;
            if (existingEvent !== event) {
              if (existingListener !== void 0) {
                existingEvent.removeListener(existingListener);
              }
              this.#eventListeners.delete((0, import_InteractionServer.eventPathToId)(path2));
            } else {
              return;
            }
          }
          const listener = (newEvent) => this.eventChangeListener(path2, event.schema, newEvent);
          event.addListener(listener);
          newEvents.push({ path: path2, event });
          this.#eventListeners.set((0, import_InteractionServer.eventPathToId)(path2), { event, listener });
        });
      });
    }
    this.unregisterEventListeners(Array.from(formerEvents.values()));
    return { newEvents, eventErrors };
  }
  unregisterEventListeners(list) {
    for (const pathId of list) {
      const existingEventListener = this.#eventListeners.get(pathId);
      if (existingEventListener !== void 0) {
        const { event, listener } = existingEventListener;
        if (listener !== void 0) {
          event.removeListener(listener);
        }
        this.#eventListeners.delete(pathId);
      }
    }
  }
  /**
   * Update the session after an endpoint structure change. The method will initialize all missing new attributes and
   * events and will remove listeners no longer needed.
   * Newly added attributes are then treated as "changed values" and will be sent as subscription data update to the
   * controller. The data of newly added events are not sent automatically.
   */
  async updateSubscription() {
    const { newAttributes } = this.registerNewAttributes();
    for (const { path, attribute } of newAttributes) {
      const { version, value } = await this.#context.readAttribute(path, attribute);
      this.#outstandingAttributeUpdates.set((0, import_InteractionServer.attributePathToId)(path), {
        attribute,
        path,
        schema: attribute.schema,
        version,
        value
      });
    }
    const { newEvents } = this.registerNewEvents();
    newEvents.flatMap(({ path, event }) => {
      const { schema } = event;
      const matchingEvents = event.get(
        this.session,
        this.criteria.isFabricFiltered,
        void 0,
        this.criteria.eventFilters
      );
      return matchingEvents.map((data) => ({
        event,
        schema,
        path,
        data
      }));
    }).sort((a, b) => {
      const eventNumberA = a.data?.eventNumber ?? (0, import_types.EventNumber)(0);
      const eventNumberB = b.data?.eventNumber ?? (0, import_types.EventNumber)(0);
      if (eventNumberA > eventNumberB) {
        return 1;
      } else if (eventNumberA < eventNumberB) {
        return -1;
      } else {
        return 0;
      }
    }).forEach((event) => this.#outstandingEventUpdates.add(event));
    this.prepareDataUpdate();
  }
  get maxInterval() {
    return Math.ceil(this.#maxIntervalMs / 1e3);
  }
  get sendInterval() {
    return Math.ceil(this.#sendIntervalMs / 1e3);
  }
  activateSendingUpdates() {
    if (this.criteria.eventFilters !== void 0) this.criteria.eventFilters.length = 0;
    if (this.criteria.dataVersionFilters !== void 0) this.criteria.dataVersionFilters.length = 0;
    this.#sendUpdatesActivated = true;
    if (this.#outstandingAttributeUpdates.size > 0 || this.#outstandingEventUpdates.size > 0) {
      void this.sendUpdate();
    }
    this.#updateTimer = import_general.Time.getTimer(
      "Subscription update",
      this.#sendIntervalMs,
      () => this.prepareDataUpdate()
    ).start();
    this.#structure.change.on(() => {
      this.updateSubscription().catch(
        (error) => logger.error("Error updating subscription after structure change:", error)
      );
    });
  }
  /**
   * Check if data should be sent straight away or delayed because the minimum interval is not reached. Delay real
   * sending by 50ms in any case to mke sure to catch all updates.
   */
  prepareDataUpdate() {
    if (this.#sendDelayTimer.isRunning) {
      return;
    }
    if (!this.#sendUpdatesActivated) {
      return;
    }
    this.#updateTimer.stop();
    const now = import_general.Time.nowMs();
    const timeSinceLastUpdateMs = now - this.#lastUpdateTimeMs;
    if (timeSinceLastUpdateMs < this.minIntervalFloorMs) {
      this.#updateTimer = import_general.Time.getTimer(
        "Subscription update",
        this.minIntervalFloorMs - timeSinceLastUpdateMs,
        () => this.prepareDataUpdate()
      ).start();
      return;
    }
    this.#sendDelayTimer.start();
    this.#updateTimer = import_general.Time.getTimer(
      "Subscription update",
      this.#sendIntervalMs,
      () => this.prepareDataUpdate()
    ).start();
  }
  /**
   * Determine all attributes that have changed since the last update and send them tout to the subscriber.
   */
  async sendUpdate() {
    if (this.sendingUpdateInProgress) {
      logger.debug("Sending update already in progress, delaying update ...");
      this.sendNextUpdateImmediately = true;
      return;
    }
    const attributeUpdatesToSend = new Array();
    const attributeUpdates = {};
    Array.from(this.#outstandingAttributeUpdates.values()).forEach((entry) => {
      const {
        path: { nodeId, endpointId, clusterId }
      } = entry;
      const pathId = `${nodeId}-${endpointId}-${clusterId}`;
      attributeUpdates[pathId] = attributeUpdates[pathId] ?? [];
      attributeUpdates[pathId].push(entry);
    });
    this.#outstandingAttributeUpdates.clear();
    Object.values(attributeUpdates).forEach(
      (data) => attributeUpdatesToSend.push(
        ...data.sort(({ version: versionA }, { version: versionB }) => versionA - versionB)
      )
    );
    const eventUpdatesToSend = Array.from(this.#outstandingEventUpdates.values());
    this.#outstandingEventUpdates.clear();
    this.#lastUpdateTimeMs = import_general.Time.nowMs();
    this.sendingUpdateInProgress = true;
    try {
      await this.sendUpdateMessage(attributeUpdatesToSend, eventUpdatesToSend);
      this.sendUpdateErrorCounter = 0;
    } catch (error) {
      if (this.isClosed) {
        return;
      }
      this.sendUpdateErrorCounter++;
      logger.info(
        `Error sending subscription update message (error count=${this.sendUpdateErrorCounter}):`,
        error instanceof import_general.MatterError ? error.message : error
      );
      if (this.sendUpdateErrorCounter <= 2) {
        const newAttributeUpdatesToSend = Array.from(this.#outstandingAttributeUpdates.values());
        this.#outstandingAttributeUpdates.clear();
        const newEventUpdatesToSend = Array.from(this.#outstandingEventUpdates.values());
        this.#outstandingEventUpdates.clear();
        [...attributeUpdatesToSend, ...newAttributeUpdatesToSend].forEach(
          (update) => this.#outstandingAttributeUpdates.set((0, import_InteractionServer.attributePathToId)(update.path), update)
        );
        [...eventUpdatesToSend, ...newEventUpdatesToSend].forEach(
          (update) => this.#outstandingEventUpdates.add(update)
        );
      } else {
        logger.info(
          `Sending update failed 3 times in a row, canceling subscription ${this.id} and let controller subscribe again.`
        );
        this.sendNextUpdateImmediately = false;
        if (error instanceof import_general.NoResponseTimeoutError || error instanceof import_general.NetworkError || error instanceof import_ChannelManager.NoChannelError) {
          await this.session.destroy(false);
        } else {
          throw error;
        }
      }
    }
    this.sendingUpdateInProgress = false;
    if (this.sendNextUpdateImmediately) {
      logger.debug("Sending delayed update immediately after last one was sent.");
      this.sendNextUpdateImmediately = false;
      await this.sendUpdate();
    }
  }
  async sendInitialReport(messenger) {
    this.#updateTimer.stop();
    const { newAttributes, attributeErrors } = this.registerNewAttributes();
    const dataVersionFilterMap = new Map(
      this.criteria.dataVersionFilters?.map(({ path, dataVersion }) => [(0, import_InteractionServer.clusterPathToId)(path), dataVersion]) ?? []
    );
    let attributesFilteredWithVersion = false;
    const attributes = new Array();
    for (const { path, attribute } of newAttributes) {
      try {
        const { value, version } = await this.#context.readAttribute(path, attribute);
        if (value === void 0) continue;
        const { nodeId, endpointId, clusterId } = path;
        const versionFilterValue = endpointId !== void 0 && clusterId !== void 0 ? dataVersionFilterMap.get((0, import_InteractionServer.clusterPathToId)({ nodeId, endpointId, clusterId })) : void 0;
        if (versionFilterValue !== void 0 && versionFilterValue === version) {
          attributesFilteredWithVersion = true;
          continue;
        }
        attributes.push({ path, value, version, schema: attribute.schema, attribute });
      } catch (error) {
        if (import_types.StatusResponseError.is(error, import_types.StatusCode.UnsupportedAccess)) {
          logger.error(`Permission denied reading attribute ${this.#structure.resolveAttributeName(path)}`);
        } else {
          logger.error(`Error reading attribute ${this.#structure.resolveAttributeName(path)}:`, error);
        }
      }
    }
    const attributeReportsPayload = attributes.map(
      ({ path, schema, value, version, attribute }) => ({
        hasFabricSensitiveData: attribute.hasFabricSensitiveData,
        attributeData: {
          path,
          dataVersion: version,
          payload: value,
          schema
        }
      })
    );
    attributeErrors.forEach(
      (attributeStatus) => attributeReportsPayload.push({
        hasFabricSensitiveData: false,
        attributeStatus
      })
    );
    const { newEvents, eventErrors } = this.registerNewEvents();
    let eventsFiltered = false;
    const eventReportsPayload = new Array();
    for (const { path, event } of newEvents) {
      const { schema } = event;
      try {
        const matchingEvents = await this.#context.readEvent(path, event, this.criteria.eventFilters);
        if (matchingEvents.length === 0) {
          eventsFiltered = true;
        } else {
          matchingEvents.forEach(({ eventNumber, priority, epochTimestamp, data }) => {
            eventReportsPayload.push({
              hasFabricSensitiveData: event.hasFabricSensitiveData,
              eventData: {
                path,
                eventNumber,
                priority,
                epochTimestamp,
                payload: data,
                schema
              }
            });
          });
        }
      } catch (error) {
        logger.error(`Error reading event ${this.#structure.resolveEventName(path)}:`, error);
      }
    }
    eventReportsPayload.sort((a, b) => {
      const eventNumberA = a.eventData?.eventNumber ?? 0;
      const eventNumberB = b.eventData?.eventNumber ?? 0;
      if (eventNumberA > eventNumberB) {
        return 1;
      } else if (eventNumberA < eventNumberB) {
        return -1;
      } else {
        return 0;
      }
    });
    if (attributes.length === 0 && !attributesFilteredWithVersion && eventReportsPayload.length === 0 && !eventsFiltered) {
      throw new import_types.StatusResponseError(
        "Subscription failed because no attributes or events are matching the query",
        import_types.StatusCode.InvalidAction
      );
    }
    eventErrors.forEach(
      (eventStatus) => eventReportsPayload.push({
        hasFabricSensitiveData: false,
        eventStatus
      })
    );
    logger.debug(
      `Initialize Subscription with ${attributes.length} attributes and ${eventReportsPayload.length} events.`
    );
    this.#lastUpdateTimeMs = import_general.Time.nowMs();
    await messenger.sendDataReport(
      {
        suppressResponse: false,
        // we always need proper response for initial report
        subscriptionId: this.id,
        interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION,
        attributeReportsPayload,
        eventReportsPayload
      },
      this.criteria.isFabricFiltered
    );
  }
  attributeChangeListener(path, schema, version, value) {
    const changeResult = this.attributeChangeHandler(path, schema, version, value);
    if (import_general.MaybePromise.is(changeResult)) {
      const resolver = Promise.resolve(changeResult).catch((error) => logger.error(`Error handling attribute change:`, error)).finally(() => this.attributeUpdatePromises.delete(resolver));
      this.attributeUpdatePromises.add(resolver);
    }
  }
  attributeChangeHandler(path, schema, version, value) {
    const attributeListenerData = this.#attributeListeners.get((0, import_InteractionServer.attributePathToId)(path));
    if (attributeListenerData === void 0) return;
    const { attribute } = attributeListenerData;
    if (attribute instanceof import_AttributeServer.FabricScopedAttributeServer) {
      return this.#context.readAttribute(path, attribute, true).then(({ value: value2 }) => {
        this.#outstandingAttributeUpdates.set((0, import_InteractionServer.attributePathToId)(path), {
          attribute,
          path,
          schema,
          version,
          value: value2
        });
        this.prepareDataUpdate();
      });
    }
    this.#outstandingAttributeUpdates.set((0, import_InteractionServer.attributePathToId)(path), { attribute, path, schema, version, value });
    this.prepareDataUpdate();
  }
  eventChangeListener(path, schema, newEvent) {
    const eventListenerData = this.#eventListeners.get((0, import_InteractionServer.eventPathToId)(path));
    if (eventListenerData === void 0) return;
    const { event } = eventListenerData;
    if (event instanceof import_EventServer.FabricSensitiveEventServer) {
      const { data } = newEvent;
      if ((0, import_general.isObject)(data) && "fabricIndex" in data && data.fabricIndex !== this.session.fabric?.fabricIndex) {
        return;
      }
    }
    this.#outstandingEventUpdates.add({ event, path, schema, data: newEvent });
    if (path.isUrgent) {
      this.prepareDataUpdate();
    }
  }
  async flush() {
    this.#sendDelayTimer.stop();
    logger.debug(
      `Flushing subscription ${this.id} with ${this.#outstandingAttributeUpdates.size} attributes and ${this.#outstandingEventUpdates.size} events`
    );
    if (this.#outstandingAttributeUpdates.size > 0 || this.#outstandingEventUpdates.size > 0) {
      void this.sendUpdate();
    }
  }
  async close(graceful = false) {
    this.isClosed = true;
    this.#sendUpdatesActivated = false;
    if (this.attributeUpdatePromises.size) {
      const resolvers = [...this.attributeUpdatePromises.values()];
      this.attributeUpdatePromises.clear();
      await Promise.all(resolvers);
    }
    this.#updateTimer.stop();
    this.#sendDelayTimer.stop();
    this.unregisterAttributeListeners(Array.from(this.#attributeListeners.keys()));
    this.unregisterEventListeners(Array.from(this.#eventListeners.keys()));
    if (graceful) {
      await this.flush();
    }
    await super.close();
  }
  async sendUpdateMessage(attributes, events) {
    logger.debug(
      `Sending subscription update message for ID ${this.id} with ${attributes.length} attributes and ${events.length} events`
    );
    const exchange = this.#context.initiateExchange(this.peerAddress, import_types.INTERACTION_PROTOCOL_ID);
    if (exchange === void 0) return;
    if (attributes.length) {
      logger.debug(
        `Subscription attribute changes for ID ${this.id}: ${attributes.map(
          ({ path, value, version }) => `${this.#structure.resolveAttributeName(path)}=${import_general.Logger.toJSON(value)} (${version})`
        ).join(", ")}`
      );
    }
    const messenger = new import_InteractionMessenger.InteractionServerMessenger(exchange);
    try {
      if (attributes.length === 0 && events.length === 0) {
        await messenger.sendDataReport(
          {
            suppressResponse: true,
            // suppressResponse true for empty DataReports
            subscriptionId: this.id,
            interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION
          },
          this.criteria.isFabricFiltered
        );
      } else {
        await messenger.sendDataReport(
          {
            suppressResponse: false,
            // Non empty data reports always need to send response
            subscriptionId: this.id,
            interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION,
            attributeReportsPayload: attributes.map(({ path, schema, value, version, attribute }) => ({
              hasFabricSensitiveData: attribute.hasFabricSensitiveData,
              attributeData: {
                path,
                dataVersion: version,
                schema,
                payload: value
              }
            })),
            eventReportsPayload: events.map(({ path, schema, event, data }) => {
              const { eventNumber, priority, epochTimestamp, data: payload } = data;
              return {
                hasFabricSensitiveData: event.hasFabricSensitiveData,
                eventData: {
                  path,
                  eventNumber,
                  priority,
                  epochTimestamp,
                  schema,
                  payload
                }
              };
            })
          },
          this.criteria.isFabricFiltered
        );
      }
    } catch (error) {
      if (import_types.StatusResponseError.is(error, import_types.StatusCode.InvalidSubscription, import_types.StatusCode.Failure)) {
        logger.info(`Subscription ${this.id} cancelled by peer.`);
        this.isCanceledByPeer = true;
        await this.close(false);
      } else {
        import_types.StatusResponseError.accept(error);
        logger.info(`Subscription ${this.id} update failed:`, error);
        await this.close(false);
      }
    } finally {
      await messenger.close();
    }
  }
}
//# sourceMappingURL=ServerSubscription.js.map
