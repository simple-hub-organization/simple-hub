"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var InteractionMessenger_exports = {};
__export(InteractionMessenger_exports, {
  IncomingInteractionClientMessenger: () => IncomingInteractionClientMessenger,
  InteractionClientMessenger: () => InteractionClientMessenger,
  InteractionServerMessenger: () => InteractionServerMessenger,
  MessageType: () => MessageType
});
module.exports = __toCommonJS(InteractionMessenger_exports);
var import_general = require("#general");
var import_model = require("#model");
var import_types = require("#types");
var import_MessageCodec = require("../codec/MessageCodec.js");
var import_ExchangeManager = require("../protocol/ExchangeManager.js");
var import_MessageExchange = require("../protocol/MessageExchange.js");
var import_AttributeDataEncoder = require("./AttributeDataEncoder.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var MessageType = /* @__PURE__ */ ((MessageType2) => {
  MessageType2[MessageType2["StatusResponse"] = 1] = "StatusResponse";
  MessageType2[MessageType2["ReadRequest"] = 2] = "ReadRequest";
  MessageType2[MessageType2["SubscribeRequest"] = 3] = "SubscribeRequest";
  MessageType2[MessageType2["SubscribeResponse"] = 4] = "SubscribeResponse";
  MessageType2[MessageType2["ReportData"] = 5] = "ReportData";
  MessageType2[MessageType2["WriteRequest"] = 6] = "WriteRequest";
  MessageType2[MessageType2["WriteResponse"] = 7] = "WriteResponse";
  MessageType2[MessageType2["InvokeRequest"] = 8] = "InvokeRequest";
  MessageType2[MessageType2["InvokeResponse"] = 9] = "InvokeResponse";
  MessageType2[MessageType2["TimedRequest"] = 10] = "TimedRequest";
  return MessageType2;
})(MessageType || {});
const logger = import_general.Logger.get("InteractionMessenger");
class InteractionMessenger {
  constructor(exchange) {
    this.exchange = exchange;
  }
  calculateMaximumPeerResponseTime(expectedProcessingTimeMs) {
    return this.exchange.calculateMaximumPeerResponseTime(expectedProcessingTimeMs);
  }
  send(messageType, payload, options) {
    return this.exchange.send(messageType, payload, options);
  }
  sendStatus(status) {
    return this.send(
      1 /* StatusResponse */,
      import_types.TlvStatusResponse.encode({ status, interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION })
    );
  }
  async waitForSuccess(expectedProcessingTimeMs) {
    await this.nextMessage(1 /* StatusResponse */, expectedProcessingTimeMs);
  }
  async nextMessage(expectedMessageType, expectedProcessingTimeMs) {
    const message = await this.exchange.nextMessage(expectedProcessingTimeMs);
    const messageType = message.payloadHeader.messageType;
    this.throwIfErrorStatusMessage(message);
    if (expectedMessageType !== void 0 && messageType !== expectedMessageType) {
      throw new import_general.UnexpectedDataError(
        `Received unexpected message type: ${messageType}, expected: ${expectedMessageType}`
      );
    }
    return message;
  }
  async close() {
    await this.exchange.close();
  }
  throwIfErrorStatusMessage(message) {
    const {
      payloadHeader: { messageType },
      payload
    } = message;
    if (messageType !== 1 /* StatusResponse */) return;
    const { status } = import_types.TlvStatusResponse.decode(payload);
    if (status !== import_types.StatusCode.Success) throw new import_types.StatusResponseError(`Received error status: ${status}`, status);
  }
  getExchangeChannelName() {
    return this.exchange.channel.name;
  }
}
class InteractionServerMessenger extends InteractionMessenger {
  async handleRequest(recipient) {
    let continueExchange = true;
    let isGroupSession = false;
    try {
      while (continueExchange) {
        const message = await this.exchange.nextMessage();
        isGroupSession = message.packetHeader.sessionType === import_MessageCodec.SessionType.Group;
        continueExchange = false;
        switch (message.payloadHeader.messageType) {
          case 2 /* ReadRequest */: {
            if (isGroupSession) {
              throw new import_types.StatusResponseError(
                `ReadRequest is not supported in group sessions`,
                import_types.Status.InvalidAction
              );
            }
            const readRequest = import_types.TlvReadRequest.decode(message.payload);
            await this.sendDataReport(
              await recipient.handleReadRequest(this.exchange, readRequest, message),
              readRequest.isFabricFiltered
            );
            break;
          }
          case 6 /* WriteRequest */: {
            const writeRequest = import_types.TlvWriteRequest.decode(message.payload);
            const { suppressResponse } = writeRequest;
            const writeResponse = await recipient.handleWriteRequest(this.exchange, writeRequest, message);
            if (!suppressResponse && !isGroupSession) {
              await this.send(7 /* WriteResponse */, import_types.TlvWriteResponse.encode(writeResponse));
            }
            break;
          }
          case 3 /* SubscribeRequest */: {
            const subscribeRequest = import_types.TlvSubscribeRequest.decode(message.payload);
            await recipient.handleSubscribeRequest(this.exchange, subscribeRequest, this, message);
            break;
          }
          case 8 /* InvokeRequest */: {
            const invokeRequest = import_types.TlvInvokeRequest.decode(message.payload);
            await recipient.handleInvokeRequest(this.exchange, invokeRequest, this, message);
            break;
          }
          case 10 /* TimedRequest */: {
            const timedRequest = import_types.TlvTimedRequest.decode(message.payload);
            recipient.handleTimedRequest(this.exchange, timedRequest, message);
            await this.sendStatus(import_types.StatusCode.Success);
            continueExchange = true;
            break;
          }
          default:
            throw new import_types.StatusResponseError(
              `Unsupported message type ${message.payloadHeader.messageType}`,
              import_types.Status.InvalidAction
            );
        }
      }
    } catch (error) {
      let errorStatusCode = import_types.StatusCode.Failure;
      if (error instanceof import_types.StatusResponseError) {
        logger.info(`Sending status response ${error.code} for interaction error: ${error.message}`);
        errorStatusCode = error.code;
      } else if (error instanceof import_general.NoResponseTimeoutError) {
        logger.info(error);
      } else {
        logger.warn(error);
      }
      if (!isGroupSession && !(error instanceof import_general.NoResponseTimeoutError)) {
        await this.sendStatus(errorStatusCode);
      }
    } finally {
      await this.exchange.close();
    }
  }
  /**
   * Handle DataReportPayload with the content of a DataReport to send, split them into multiple DataReport
   * messages and send them out based on the size.
   */
  async sendDataReport(dataReportPayload, forFabricFilteredRead) {
    const {
      subscriptionId,
      attributeReportsPayload,
      eventReportsPayload,
      suppressResponse,
      interactionModelRevision
    } = dataReportPayload;
    const dataReport = {
      subscriptionId,
      suppressResponse,
      interactionModelRevision,
      attributeReports: void 0,
      eventReports: void 0
    };
    if (attributeReportsPayload !== void 0 || eventReportsPayload !== void 0) {
      const attributeReportsToSend = [...attributeReportsPayload ?? []];
      const eventReportsToSend = [...eventReportsPayload ?? []];
      dataReport.moreChunkedMessages = true;
      const emptyDataReportBytes = import_types.TlvDataReportForSend.encode(dataReport);
      let firstAttributeAddedToReportMessage = false;
      let firstEventAddedToReportMessage = false;
      const sendAndResetReport = async () => {
        await this.sendDataReportMessage(dataReport);
        dataReport.attributeReports = void 0;
        dataReport.eventReports = void 0;
        messageSize = emptyDataReportBytes.length;
        firstAttributeAddedToReportMessage = false;
        firstEventAddedToReportMessage = false;
      };
      let messageSize = emptyDataReportBytes.length;
      while (true) {
        if (attributeReportsToSend.length > 0) {
          const attributeReport = attributeReportsToSend.shift();
          if (attributeReport !== void 0) {
            if (!firstAttributeAddedToReportMessage) {
              firstAttributeAddedToReportMessage = true;
              messageSize += 3;
            }
            const allowMissingFieldsForNonFabricFilteredRead = !forFabricFilteredRead && attributeReport.hasFabricSensitiveData;
            const encodedAttribute = (0, import_AttributeDataEncoder.encodeAttributePayload)(attributeReport, {
              allowMissingFieldsForNonFabricFilteredRead
            });
            const attributeReportBytes = import_types.TlvAny.getEncodedByteLength(encodedAttribute);
            if (messageSize + attributeReportBytes > this.exchange.maxPayloadSize) {
              if ((0, import_AttributeDataEncoder.canAttributePayloadBeChunked)(attributeReport)) {
                attributeReportsToSend.unshift(...(0, import_AttributeDataEncoder.chunkAttributePayload)(attributeReport));
                continue;
              }
              await sendAndResetReport();
            }
            messageSize += attributeReportBytes;
            if (dataReport.attributeReports === void 0) dataReport.attributeReports = [];
            dataReport.attributeReports.push(encodedAttribute);
          }
        } else if (eventReportsToSend.length > 0) {
          const eventReport = eventReportsToSend.shift();
          if (eventReport === void 0) {
            delete dataReport.moreChunkedMessages;
            break;
          }
          if (!firstEventAddedToReportMessage) {
            firstEventAddedToReportMessage = true;
            messageSize += 3;
          }
          const allowMissingFieldsForNonFabricFilteredRead = !forFabricFilteredRead && eventReport.hasFabricSensitiveData;
          const encodedEvent = (0, import_AttributeDataEncoder.encodeEventPayload)(eventReport, {
            allowMissingFieldsForNonFabricFilteredRead
          });
          const eventReportBytes = import_types.TlvAny.getEncodedByteLength(encodedEvent);
          if (messageSize + eventReportBytes > this.exchange.maxPayloadSize) {
            await sendAndResetReport();
          }
          messageSize += eventReportBytes;
          if (dataReport.eventReports === void 0) dataReport.eventReports = [];
          dataReport.eventReports.push(encodedEvent);
        } else {
          delete dataReport.moreChunkedMessages;
          break;
        }
      }
    }
    await this.sendDataReportMessage(dataReport);
  }
  async sendDataReportMessage(dataReport) {
    const dataReportToSend = {
      ...dataReport,
      suppressResponse: dataReport.moreChunkedMessages ? false : dataReport.suppressResponse
      // always false when moreChunkedMessages is true
    };
    const encodedMessage = import_types.TlvDataReportForSend.encode(dataReportToSend);
    if (encodedMessage.length > this.exchange.maxPayloadSize) {
      throw new import_general.MatterFlowError(
        `DataReport is too long to fit in a single chunk, This should not happen! Data: ${import_general.Logger.toJSON(
          dataReportToSend
        )}`
      );
    }
    logger.debug(
      `Sending DataReport chunk with ${dataReportToSend.attributeReports?.length ?? 0} attributes and ${dataReportToSend.eventReports?.length ?? 0} events: ${encodedMessage.length} bytes (moreChunkedMessages: ${dataReportToSend.moreChunkedMessages ?? false}, suppressResponse: ${dataReportToSend.suppressResponse})`
    );
    if (dataReportToSend.suppressResponse) {
      try {
        await this.exchange.send(5 /* ReportData */, encodedMessage, {
          expectAckOnly: true
        });
      } catch (e) {
        import_MessageExchange.UnexpectedMessageError.accept(e);
        const { receivedMessage } = e;
        this.throwIfErrorStatusMessage(receivedMessage);
      }
    } else {
      await this.exchange.send(5 /* ReportData */, encodedMessage);
      await this.waitForSuccess();
    }
  }
}
class IncomingInteractionClientMessenger extends InteractionMessenger {
  async waitFor(messageType, timeoutMs) {
    const message = await this.nextMessage(timeoutMs);
    const {
      payloadHeader: { messageType: receivedMessageType }
    } = message;
    if (receivedMessageType !== messageType) {
      if (receivedMessageType === 1 /* StatusResponse */) {
        const statusCode = import_types.TlvStatusResponse.decode(message.payload).status;
        throw new import_types.StatusResponseError(`Received status response ${statusCode}`, statusCode);
      }
      throw new import_general.MatterFlowError(
        `Received unexpected message type ${receivedMessageType.toString(16)}. Expected ${messageType.toString(
          16
        )}`
      );
    }
    return message;
  }
  // TODO: Adjust to use callbacks or events to push put received data to allow parallel processing
  async readDataReports(expectedSubscriptionIds) {
    let subscriptionId;
    const attributeValues = [];
    const eventValues = [];
    while (true) {
      const dataReportMessage = await this.waitFor(5 /* ReportData */);
      const report = import_types.TlvDataReport.decode(dataReportMessage.payload);
      if (expectedSubscriptionIds !== void 0) {
        if (report.subscriptionId === void 0 || !expectedSubscriptionIds.includes(report.subscriptionId)) {
          await this.sendStatus(import_types.StatusCode.InvalidSubscription);
          throw new import_general.UnexpectedDataError(
            report.subscriptionId === void 0 ? "Invalid Data report without Subscription ID" : `Invalid Data report with unexpected subscription ID ${report.subscriptionId}`
          );
        }
      }
      if (subscriptionId === void 0 && report.subscriptionId !== void 0) {
        subscriptionId = report.subscriptionId;
      } else if ((subscriptionId !== void 0 || report.subscriptionId !== void 0) && report.subscriptionId !== subscriptionId) {
        throw new import_general.UnexpectedDataError(`Invalid subscription ID ${report.subscriptionId} received`);
      }
      logger.debug(
        `Received DataReport chunk with ${report.attributeReports?.length ?? 0} attributes and ${report.eventReports?.length ?? 0} events, suppressResponse: ${report.suppressResponse}, moreChunkedMessages: ${report.moreChunkedMessages}${report.subscriptionId !== void 0 ? `, subscriptionId: ${report.subscriptionId}` : ""}`
      );
      if (Array.isArray(report.attributeReports) && report.attributeReports.length > 0) {
        attributeValues.push(...report.attributeReports);
      }
      if (Array.isArray(report.eventReports) && report.eventReports.length > 0) {
        eventValues.push(...report.eventReports);
      }
      if (report.moreChunkedMessages) {
        await this.sendStatus(import_types.StatusCode.Success);
      } else if (!report.suppressResponse) {
        this.sendStatus(import_types.StatusCode.Success).catch(
          (error) => logger.info("Error while sending final Success after receiving all DataReport chunks", error)
        );
      }
      if (!report.moreChunkedMessages) {
        report.attributeReports = attributeValues;
        report.eventReports = eventValues;
        return report;
      }
    }
  }
}
class InteractionClientMessenger extends IncomingInteractionClientMessenger {
  constructor(exchange, exchangeProvider) {
    super(exchange);
    this.exchangeProvider = exchangeProvider;
  }
  static async create(exchangeProvider) {
    const exchange = await exchangeProvider.initiateExchange();
    return new this(exchange, exchangeProvider);
  }
  /** Implements a send method with an automatic reconnection mechanism */
  async send(messageType, payload, options) {
    try {
      if (this.exchange.channel.closed) {
        throw new import_ExchangeManager.ChannelNotConnectedError("The exchange channel is closed. Please connect the device first.");
      }
      return await this.exchange.send(messageType, payload, options);
    } catch (error) {
      if (error instanceof import_MessageExchange.RetransmissionLimitReachedError || error instanceof import_ExchangeManager.ChannelNotConnectedError) {
        logger.debug(
          `${error instanceof import_MessageExchange.RetransmissionLimitReachedError ? "Retransmission limit reached" : "Channel not connected"}, trying to reconnect and resend the message.`
        );
        await this.exchange.close();
        if (await this.exchangeProvider.reconnectChannel()) {
          this.exchange = await this.exchangeProvider.initiateExchange();
          return await this.exchange.send(messageType, payload, options);
        }
      } else {
        throw error;
      }
    }
  }
  async sendReadRequest(readRequest) {
    await this.send(2 /* ReadRequest */, this.#encodeReadingRequest(import_types.TlvReadRequest, readRequest));
    return this.readDataReports();
  }
  #encodeReadingRequest(schema, request) {
    const encoded = schema.encode(request);
    if (encoded.length <= this.exchange.maxPayloadSize) {
      return encoded;
    }
    const originalDataVersionFilters = [...request.dataVersionFilters ?? []];
    const requestWithoutDataVersionFilters = schema.encode({
      ...request,
      dataVersionFilters: []
    });
    if (requestWithoutDataVersionFilters.length > this.exchange.maxPayloadSize) {
      throw new import_general.MatterFlowError(
        `Request is too long to fit in a single chunk, This should not happen! Data: ${import_general.Logger.toJSON(request)}`
      );
    }
    return schema.encode({
      ...request,
      dataVersionFilters: this.#shortenDataVersionFilters(
        originalDataVersionFilters,
        this.exchange.maxPayloadSize - requestWithoutDataVersionFilters.length
      )
    });
  }
  #shortenDataVersionFilters(originalDataVersionFilters, availableBytes) {
    const dataVersionFilters = new Array();
    while (availableBytes > 0 && originalDataVersionFilters.length > 0) {
      const dataVersionFilter = originalDataVersionFilters.shift();
      if (dataVersionFilter === void 0) {
        break;
      }
      const encodedDataVersionFilter = import_types.TlvDataVersionFilter.encode(dataVersionFilter);
      const encodedDataVersionFilterLength = encodedDataVersionFilter.length;
      if (encodedDataVersionFilterLength > availableBytes) {
        originalDataVersionFilters.unshift(dataVersionFilter);
        break;
      }
      dataVersionFilters.push(dataVersionFilter);
      availableBytes -= encodedDataVersionFilterLength;
    }
    logger.debug(
      `Removed ${originalDataVersionFilters.length} DataVersionFilters from Request to fit into a single message`
    );
    return dataVersionFilters;
  }
  async sendSubscribeRequest(subscribeRequest) {
    const request = this.#encodeReadingRequest(import_types.TlvSubscribeRequest, subscribeRequest);
    await this.send(3 /* SubscribeRequest */, request);
    const report = await this.readDataReports();
    const { subscriptionId } = report;
    if (subscriptionId === void 0) {
      throw new import_general.UnexpectedDataError(`Subscription ID not provided in report`);
    }
    const subscribeResponseMessage = await this.nextMessage(4 /* SubscribeResponse */);
    const subscribeResponse = import_types.TlvSubscribeResponse.decode(subscribeResponseMessage.payload);
    if (subscribeResponse.subscriptionId !== subscriptionId) {
      throw new import_general.MatterFlowError(
        `Received subscription ID ${subscribeResponse.subscriptionId} instead of ${subscriptionId}`
      );
    }
    return {
      subscribeResponse,
      report
    };
  }
  async sendInvokeCommand(invokeRequest, expectedProcessingTimeMs) {
    if (invokeRequest.suppressResponse) {
      await this.requestWithSuppressedResponse(
        8 /* InvokeRequest */,
        import_types.TlvInvokeRequest,
        invokeRequest,
        expectedProcessingTimeMs
      );
    } else {
      return await this.request(
        8 /* InvokeRequest */,
        import_types.TlvInvokeRequest,
        9 /* InvokeResponse */,
        import_types.TlvInvokeResponse,
        invokeRequest,
        expectedProcessingTimeMs
      );
    }
  }
  async sendWriteCommand(writeRequest) {
    if (writeRequest.suppressResponse) {
      await this.requestWithSuppressedResponse(6 /* WriteRequest */, import_types.TlvWriteRequest, writeRequest);
    } else {
      return await this.request(
        6 /* WriteRequest */,
        import_types.TlvWriteRequest,
        7 /* WriteResponse */,
        import_types.TlvWriteResponse,
        writeRequest
      );
    }
  }
  sendTimedRequest(timeoutSeconds) {
    return this.request(10 /* TimedRequest */, import_types.TlvTimedRequest, 1 /* StatusResponse */, import_types.TlvStatusResponse, {
      timeout: timeoutSeconds,
      interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION
    });
  }
  async requestWithSuppressedResponse(requestMessageType, requestSchema, request, expectedProcessingTimeMs) {
    await this.send(requestMessageType, requestSchema.encode(request), {
      expectAckOnly: true,
      expectedProcessingTimeMs
    });
  }
  async request(requestMessageType, requestSchema, responseMessageType, responseSchema, request, expectedProcessingTimeMs) {
    await this.send(requestMessageType, requestSchema.encode(request), {
      expectAckOnly: false,
      expectedProcessingTimeMs
    });
    const responseMessage = await this.nextMessage(responseMessageType, expectedProcessingTimeMs);
    return responseSchema.decode(responseMessage.payload);
  }
}
//# sourceMappingURL=InteractionMessenger.js.map
