/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MaybePromise, PromiseQueue, Timer } from "#general";
import { PeerAddress } from "#peer/PeerAddress.js";
import { PeerDataStore } from "#peer/PeerAddressStore.js";
import { Attribute, AttributeId, AttributeJsType, ClusterId, Command, EndpointNumber, Event, EventId, EventNumber, NodeId, RequestType, ResponseType, StatusCode, TlvEventFilter, TypeFromSchema } from "#types";
import { ExchangeProvider } from "../protocol/ExchangeProvider.js";
import { MessageExchange } from "../protocol/MessageExchange.js";
import { ProtocolHandler } from "../protocol/ProtocolHandler.js";
import { DecodedAttributeReportValue } from "./AttributeDataDecoder.js";
import { DecodedEventData, DecodedEventReportValue } from "./EventDataDecoder.js";
import { DataReport } from "./InteractionMessenger.js";
export interface AttributeStatus {
    path: {
        nodeId?: NodeId;
        endpointId?: EndpointNumber;
        clusterId?: ClusterId;
        attributeId?: AttributeId;
    };
    status: StatusCode;
}
export declare class SubscriptionClient implements ProtocolHandler {
    private readonly subscriptionListeners;
    private readonly subscriptionUpdateTimers;
    constructor();
    getId(): number;
    registerSubscriptionListener(subscriptionId: number, listener: (dataReport: DataReport) => MaybePromise<void>): void;
    removeSubscriptionListener(subscriptionId: number): void;
    registerSubscriptionUpdateTimer(subscriptionId: number, timer: Timer): void;
    removeSubscriptionUpdateTimer(subscriptionId: number): void;
    onNewExchange(exchange: MessageExchange): Promise<void>;
    close(): Promise<void>;
}
export declare class InteractionClient {
    #private;
    private readonly exchangeProvider;
    readonly address: PeerAddress;
    constructor(exchangeProvider: ExchangeProvider, address: PeerAddress, queue?: PromiseQueue, nodeStore?: PeerDataStore);
    get channelUpdated(): import("#general").Observable<[void], void>;
    registerSubscriptionListener(subscriptionId: number, listener: (dataReport: DataReport) => MaybePromise<void>): void;
    removeSubscription(subscriptionId: number): void;
    getAllAttributes(options?: {
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        enrichCachedAttributeData?: boolean;
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<DecodedAttributeReportValue<any>[]>;
    getAllEvents(options?: {
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<DecodedEventReportValue<any>[]>;
    getAllAttributesAndEvents(options?: {
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        enrichCachedAttributeData?: boolean;
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<{
        attributeReports: DecodedAttributeReportValue<any>[];
        eventReports: DecodedEventReportValue<any>[];
    }>;
    getMultipleAttributes(options?: {
        attributes?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            attributeId?: AttributeId;
        }[];
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        enrichCachedAttributeData?: boolean;
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<DecodedAttributeReportValue<any>[]>;
    getMultipleEvents(options?: {
        events?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            eventId?: EventId;
        }[];
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<DecodedEventReportValue<any>[]>;
    getMultipleAttributesAndEvents(options?: {
        attributes?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            attributeId?: AttributeId;
        }[];
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        enrichCachedAttributeData?: boolean;
        events?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            eventId?: EventId;
        }[];
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<{
        attributeReports: DecodedAttributeReportValue<any>[];
        eventReports: DecodedEventReportValue<any>[];
    }>;
    getAttribute<A extends Attribute<any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        attribute: A;
        isFabricFiltered?: boolean;
        alwaysRequestFromRemote?: boolean;
        executeQueued?: boolean;
    }): Promise<AttributeJsType<A> | undefined>;
    getAttributeWithVersion<A extends Attribute<any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        attribute: A;
        isFabricFiltered?: boolean;
        alwaysRequestFromRemote?: boolean;
        executeQueued?: boolean;
    }): Promise<{
        value: AttributeJsType<A>;
        version: number;
    } | undefined>;
    getEvent<T, E extends Event<T, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        event: E;
        minimumEventNumber?: EventNumber;
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<DecodedEventData<T>[] | undefined>;
    private processReadRequest;
    setAttribute<T>(options: {
        attributeData: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            attribute: Attribute<T, any>;
            value: T;
            dataVersion?: number;
        };
        asTimedRequest?: boolean;
        timedRequestTimeoutMs?: number;
        suppressResponse?: boolean;
        executeQueued?: boolean;
    }): Promise<void>;
    setMultipleAttributes(options: {
        attributes: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            attribute: Attribute<any, any>;
            value: any;
            dataVersion?: number;
        }[];
        asTimedRequest?: boolean;
        timedRequestTimeoutMs?: number;
        suppressResponse?: boolean;
        executeQueued?: boolean;
    }): Promise<AttributeStatus[]>;
    subscribeAttribute<A extends Attribute<any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        attribute: A;
        minIntervalFloorSeconds: number;
        maxIntervalCeilingSeconds: number;
        isFabricFiltered?: boolean;
        knownDataVersion?: number;
        keepSubscriptions?: boolean;
        listener?: (value: AttributeJsType<A>, version: number) => void;
        updateTimeoutHandler?: Timer.Callback;
        updateReceived?: () => void;
        executeQueued?: boolean;
    }): Promise<void>;
    subscribeEvent<T, E extends Event<T, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        event: E;
        minIntervalFloorSeconds: number;
        maxIntervalCeilingSeconds: number;
        isUrgent?: boolean;
        minimumEventNumber?: EventNumber;
        isFabricFiltered?: boolean;
        listener?: (value: DecodedEventData<T>) => void;
        updateTimeoutHandler?: Timer.Callback;
        updateReceived?: () => void;
        executeQueued?: boolean;
    }): Promise<void>;
    subscribeAllAttributesAndEvents(options: {
        minIntervalFloorSeconds: number;
        maxIntervalCeilingSeconds: number;
        attributeListener?: (data: DecodedAttributeReportValue<any>, valueChanged?: boolean, oldValue?: unknown) => void;
        eventListener?: (data: DecodedEventReportValue<any>) => void;
        isUrgent?: boolean;
        keepSubscriptions?: boolean;
        isFabricFiltered?: boolean;
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        enrichCachedAttributeData?: boolean;
        updateTimeoutHandler?: Timer.Callback;
        updateReceived?: () => void;
        executeQueued?: boolean;
    }): Promise<{
        attributeReports?: DecodedAttributeReportValue<any>[];
        eventReports?: DecodedEventReportValue<any>[];
    }>;
    subscribeMultipleAttributesAndEvents(options: {
        attributes?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            attributeId?: AttributeId;
        }[];
        events?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            eventId?: EventId;
            isUrgent?: boolean;
        }[];
        minIntervalFloorSeconds: number;
        maxIntervalCeilingSeconds: number;
        keepSubscriptions?: boolean;
        isFabricFiltered?: boolean;
        attributeListener?: (data: DecodedAttributeReportValue<any>, valueChanged?: boolean, oldValue?: any) => void;
        eventListener?: (data: DecodedEventReportValue<any>) => void;
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        enrichCachedAttributeData?: boolean;
        updateTimeoutHandler?: Timer.Callback;
        updateReceived?: () => void;
        executeQueued?: boolean;
    }): Promise<{
        attributeReports?: DecodedAttributeReportValue<any>[];
        eventReports?: DecodedEventReportValue<any>[];
    }>;
    invoke<C extends Command<any, any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        request: RequestType<C>;
        command: C;
        asTimedRequest?: boolean;
        timedRequestTimeoutMs?: number;
        useExtendedFailSafeMessageResponseTimeout?: boolean;
        executeQueued?: boolean;
    }): Promise<ResponseType<C>>;
    invokeWithSuppressedResponse<C extends Command<any, any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        request: RequestType<C>;
        command: C;
        asTimedRequest?: boolean;
        timedRequestTimeoutMs?: number;
        executeQueued?: boolean;
    }): Promise<void>;
    private withMessenger;
    private registerSubscriptionUpdateTimer;
    removeAllSubscriptions(): void;
    close(): void;
    get session(): import("../index.js").Session;
    get channelType(): import("#general").ChannelType;
    /**
     * Returns the list (optionally filtered by endpointId and/or clusterId) of the dataVersions of the currently cached
     * values to use them as knownDataVersion for read or subscription requests.
     */
    getCachedClusterDataVersions(filter?: {
        endpointId?: EndpointNumber;
        clusterId?: ClusterId;
    }): {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        dataVersion: number;
    }[];
    get maxKnownEventNumber(): EventNumber | undefined;
}
//# sourceMappingURL=InteractionClient.d.ts.map