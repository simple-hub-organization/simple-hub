/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  createPromise,
  fromJson,
  Logger,
  MaybeAsyncStorage,
  StorageError,
  toJson
} from "#general";
import { mkdir, readdir, readFile, rm, writeFile } from "fs/promises";
import { join } from "path";
const logger = new Logger("StorageBackendDiskAsync");
class StorageBackendDiskAsync extends MaybeAsyncStorage {
  #path;
  #clear;
  isInitialized = false;
  #writeFileBlocker = /* @__PURE__ */ new Map();
  constructor(path, clear = false) {
    super();
    this.#path = path;
    this.#clear = clear;
  }
  get initialized() {
    return this.isInitialized;
  }
  async initialize() {
    if (this.#clear) {
      await this.clear();
    }
    await mkdir(this.#path, { recursive: true });
    this.isInitialized = true;
  }
  async #finishAllWrites(filename) {
    for (let i = 0; i < 10; i++) {
      await Promise.allSettled(
        filename !== void 0 ? [this.#writeFileBlocker.get(filename)] : this.#writeFileBlocker.values()
      );
      if (!this.#writeFileBlocker.size) {
        return;
      }
    }
  }
  async close() {
    this.isInitialized = false;
    await this.#finishAllWrites();
  }
  filePath(fileName) {
    return join(this.#path, fileName);
  }
  async clear() {
    await this.#finishAllWrites();
    await rm(this.#path, { recursive: true, force: true });
    await mkdir(this.#path, { recursive: true });
  }
  getContextBaseKey(contexts, allowEmptyContext = false) {
    const contextKey = contexts.join(".");
    if (!contextKey.length && !allowEmptyContext || contextKey.includes("..") || contextKey.startsWith(".") || contextKey.endsWith("."))
      throw new StorageError("Context must not be an empty and not contain dots.");
    return contextKey;
  }
  buildStorageKey(contexts, key) {
    if (!key.length) {
      throw new StorageError("Key must not be an empty string.");
    }
    const contextKey = this.getContextBaseKey(contexts);
    const rawName = `${contextKey}.${key}`;
    return encodeURIComponent(rawName).replace(/[!'()]/g, escape).replace(/\*/g, "%2A");
  }
  async get(contexts, key) {
    let value;
    try {
      value = await readFile(this.filePath(this.buildStorageKey(contexts, key)), "utf8");
    } catch (error) {
      if (error.code === "ENOENT") return void 0;
      throw error;
    }
    try {
      return fromJson(value);
    } catch (error) {
      logger.error(`Failed to parse storage value for key ${key} in context ${contexts.join(".")}`);
    }
  }
  async set(contexts, keyOrValues, value) {
    if (typeof keyOrValues === "string") {
      return this.#writeFile(this.buildStorageKey(contexts, keyOrValues), toJson(value));
    }
    const promises = new Array();
    for (const [key, value2] of Object.entries(keyOrValues)) {
      promises.push(this.#writeFile(this.buildStorageKey(contexts, key), toJson(value2)));
    }
    await Promise.allSettled(promises);
  }
  /** According to Node.js documentation, writeFile is not atomic. This method ensures atomicity. */
  async #writeFile(fileName, value) {
    const blocker = this.#writeFileBlocker.get(fileName);
    if (blocker !== void 0) {
      await blocker;
      return this.#writeFile(fileName, value);
    }
    const { promise, rejecter, resolver } = createPromise();
    this.#writeFileBlocker.set(fileName, promise);
    writeFile(this.filePath(fileName), value, "utf8").then(() => {
      this.#writeFileBlocker.delete(fileName);
      resolver();
    }).catch(() => {
      this.#writeFileBlocker.delete(fileName);
      rejecter();
    });
    return promise;
  }
  async delete(contexts, key) {
    const filename = this.buildStorageKey(contexts, key);
    await this.#finishAllWrites(filename);
    return rm(this.filePath(filename), { force: true });
  }
  /** Returns all keys of a storage context without keys of sub-contexts */
  async keys(contexts) {
    const contextKey = this.getContextBaseKey(contexts);
    const keys = [];
    const contextKeyStart = `${contextKey}.`;
    const len = contextKeyStart.length;
    const files = await readdir(this.#path);
    for (const key of files) {
      const decodedKey = decodeURIComponent(key);
      if (decodedKey.startsWith(contextKeyStart) && !decodedKey.includes(".", len)) {
        keys.push(decodedKey.substring(len));
      }
    }
    return keys;
  }
  async values(contexts) {
    const values = {};
    const promises = new Array();
    for (const key of await this.keys(contexts)) {
      promises.push(
        (async () => {
          const value = await this.get(contexts, key);
          if (value !== void 0) {
            values[key] = value;
          }
        })()
      );
    }
    await Promise.all(promises);
    return values;
  }
  async contexts(contexts) {
    const contextKey = this.getContextBaseKey(contexts, true);
    const startContextKey = contextKey.length ? `${contextKey}.` : "";
    const len = startContextKey.length;
    const foundContexts = new Array();
    const files = await readdir(this.#path);
    for (const key of files) {
      const decodedKey = decodeURIComponent(key);
      if (decodedKey.startsWith(startContextKey)) {
        const subKeys = decodedKey.substring(len).split(".");
        if (subKeys.length === 1) continue;
        const context = subKeys[0];
        if (!foundContexts.includes(context)) {
          foundContexts.push(context);
        }
      }
    }
    return foundContexts;
  }
  async clearAll(contexts) {
    await this.#finishAllWrites();
    const contextKey = this.getContextBaseKey(contexts, true);
    const startContextKey = contextKey.length ? `${contextKey}.` : "";
    const files = await readdir(this.#path);
    const promises = new Array();
    for (const key of files) {
      const decodedKey = decodeURIComponent(key);
      if (decodedKey.startsWith(startContextKey)) {
        promises.push(rm(this.filePath(key), { force: true }));
      }
    }
    await Promise.all(promises);
  }
}
export {
  StorageBackendDiskAsync
};
//# sourceMappingURL=StorageBackendDiskAsync.js.map
