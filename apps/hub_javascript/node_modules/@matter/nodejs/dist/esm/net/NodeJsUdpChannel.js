/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  ChannelType,
  Diagnostic,
  isIPv4,
  isIPv6,
  Logger,
  MAX_UDP_MESSAGE_SIZE,
  NetworkError
} from "#general";
import { RetransmissionLimitReachedError } from "#protocol";
import * as dgram from "dgram";
import { NodeJsNetwork } from "./NodeJsNetwork.js";
const logger = Logger.get("UdpChannelNode");
function createDgramSocket(host, port, options) {
  const socket = dgram.createSocket(options);
  return new Promise((resolve, reject) => {
    const handleBindError = (error) => {
      try {
        socket.close();
      } catch (error2) {
        logger.debug("Error on closing socket", error2);
      }
      reject(error);
    };
    socket.on("error", handleBindError);
    socket.bind(port, host, () => {
      const { address: localHost, port: localPort } = socket.address();
      logger.debug(
        "Socket created and bound ",
        Diagnostic.dict({
          remoteAddress: `${host}:${port}`,
          localAddress: `${localHost}:${localPort}`
        })
      );
      socket.removeListener("error", handleBindError);
      socket.on("error", (error) => logger.error(error));
      resolve(socket);
    });
  });
}
class NodeJsUdpChannel {
  constructor(type, socket, netInterface) {
    this.type = type;
    this.socket = socket;
    this.netInterface = netInterface;
  }
  static async create({
    listeningPort,
    type,
    listeningAddress,
    netInterface,
    membershipAddresses
  }) {
    const socketOptions = { type, reuseAddr: true };
    if (type === "udp6") {
      socketOptions.ipv6Only = true;
    }
    const socket = await createDgramSocket(listeningAddress, listeningPort, socketOptions);
    socket.setBroadcast(true);
    let netInterfaceZone;
    if (netInterface !== void 0) {
      netInterfaceZone = NodeJsNetwork.getNetInterfaceZoneIpv6(netInterface);
      let multicastInterface;
      if (type === "udp4") {
        multicastInterface = NodeJsNetwork.getMulticastInterfaceIpv4(netInterface);
        if (multicastInterface === void 0) {
          throw new NetworkError(`No IPv4 addresses on interface: ${netInterface}`);
        }
      } else {
        if (netInterfaceZone === void 0) {
          throw new NetworkError(`No IPv6 addresses on interface: ${netInterface}`);
        }
        multicastInterface = `::%${netInterfaceZone}`;
      }
      logger.debug(
        "Initialize multicast",
        Diagnostic.dict({
          address: `${multicastInterface}:${listeningPort}`,
          interface: netInterface,
          type
        })
      );
      socket.setMulticastInterface(multicastInterface);
    }
    if (membershipAddresses !== void 0) {
      const multicastInterfaces = NodeJsNetwork.getMembershipMulticastInterfaces(netInterface, type === "udp4");
      for (const address of membershipAddresses) {
        for (const multicastInterface of multicastInterfaces) {
          try {
            socket.addMembership(address, multicastInterface);
          } catch (error) {
            logger.warn(
              `Error adding membership for address ${address}${multicastInterface ? ` with interface ${multicastInterface}` : ""}: ${error}`
            );
          }
        }
      }
    }
    return new NodeJsUdpChannel(type, socket, netInterfaceZone);
  }
  maxPayloadSize = MAX_UDP_MESSAGE_SIZE;
  onData(listener) {
    const messageListener = (data, { address, port }) => {
      const netInterface = this.netInterface ?? NodeJsNetwork.getNetInterfaceForIp(address);
      if (netInterface === void 0) return;
      listener(netInterface, address, port, data);
    };
    this.socket.on("message", messageListener);
    return {
      close: async () => {
        this.socket.removeListener("message", messageListener);
      }
    };
  }
  async send(host, port, data) {
    return new Promise((resolve, reject) => {
      this.socket.send(data, port, host, (error) => {
        if (error !== null) {
          const netError = error instanceof Error && "code" in error && error.code === "EHOSTUNREACH" ? new RetransmissionLimitReachedError(error.message) : new NetworkError(error.message);
          netError.stack = error.stack;
          reject(netError);
          return;
        }
        resolve();
      });
    });
  }
  async close() {
    try {
      this.socket.close();
    } catch (error) {
      logger.debug("Error on closing socket", error);
    }
  }
  get port() {
    return this.socket.address().port;
  }
  supports(type, address) {
    if (type !== ChannelType.UDP) {
      return false;
    }
    if (address === void 0) {
      return true;
    }
    if (this.type === "udp4") {
      return isIPv4(address);
    }
    return isIPv6(address);
  }
}
export {
  NodeJsUdpChannel
};
//# sourceMappingURL=NodeJsUdpChannel.js.map
