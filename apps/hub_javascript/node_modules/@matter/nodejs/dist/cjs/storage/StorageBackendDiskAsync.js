"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var StorageBackendDiskAsync_exports = {};
__export(StorageBackendDiskAsync_exports, {
  StorageBackendDiskAsync: () => StorageBackendDiskAsync
});
module.exports = __toCommonJS(StorageBackendDiskAsync_exports);
var import_general = require("#general");
var import_promises = require("fs/promises");
var import_path = require("path");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = new import_general.Logger("StorageBackendDiskAsync");
class StorageBackendDiskAsync extends import_general.MaybeAsyncStorage {
  #path;
  #clear;
  isInitialized = false;
  #writeFileBlocker = /* @__PURE__ */ new Map();
  constructor(path, clear = false) {
    super();
    this.#path = path;
    this.#clear = clear;
  }
  get initialized() {
    return this.isInitialized;
  }
  async initialize() {
    if (this.#clear) {
      await this.clear();
    }
    await (0, import_promises.mkdir)(this.#path, { recursive: true });
    this.isInitialized = true;
  }
  async #finishAllWrites(filename) {
    for (let i = 0; i < 10; i++) {
      await Promise.allSettled(
        filename !== void 0 ? [this.#writeFileBlocker.get(filename)] : this.#writeFileBlocker.values()
      );
      if (!this.#writeFileBlocker.size) {
        return;
      }
    }
  }
  async close() {
    this.isInitialized = false;
    await this.#finishAllWrites();
  }
  filePath(fileName) {
    return (0, import_path.join)(this.#path, fileName);
  }
  async clear() {
    await this.#finishAllWrites();
    await (0, import_promises.rm)(this.#path, { recursive: true, force: true });
    await (0, import_promises.mkdir)(this.#path, { recursive: true });
  }
  getContextBaseKey(contexts, allowEmptyContext = false) {
    const contextKey = contexts.join(".");
    if (!contextKey.length && !allowEmptyContext || contextKey.includes("..") || contextKey.startsWith(".") || contextKey.endsWith("."))
      throw new import_general.StorageError("Context must not be an empty and not contain dots.");
    return contextKey;
  }
  buildStorageKey(contexts, key) {
    if (!key.length) {
      throw new import_general.StorageError("Key must not be an empty string.");
    }
    const contextKey = this.getContextBaseKey(contexts);
    const rawName = `${contextKey}.${key}`;
    return encodeURIComponent(rawName).replace(/[!'()]/g, escape).replace(/\*/g, "%2A");
  }
  async get(contexts, key) {
    let value;
    try {
      value = await (0, import_promises.readFile)(this.filePath(this.buildStorageKey(contexts, key)), "utf8");
    } catch (error) {
      if (error.code === "ENOENT") return void 0;
      throw error;
    }
    try {
      return (0, import_general.fromJson)(value);
    } catch (error) {
      logger.error(`Failed to parse storage value for key ${key} in context ${contexts.join(".")}`);
    }
  }
  async set(contexts, keyOrValues, value) {
    if (typeof keyOrValues === "string") {
      return this.#writeFile(this.buildStorageKey(contexts, keyOrValues), (0, import_general.toJson)(value));
    }
    const promises = new Array();
    for (const [key, value2] of Object.entries(keyOrValues)) {
      promises.push(this.#writeFile(this.buildStorageKey(contexts, key), (0, import_general.toJson)(value2)));
    }
    await Promise.allSettled(promises);
  }
  /** According to Node.js documentation, writeFile is not atomic. This method ensures atomicity. */
  async #writeFile(fileName, value) {
    const blocker = this.#writeFileBlocker.get(fileName);
    if (blocker !== void 0) {
      await blocker;
      return this.#writeFile(fileName, value);
    }
    const { promise, rejecter, resolver } = (0, import_general.createPromise)();
    this.#writeFileBlocker.set(fileName, promise);
    (0, import_promises.writeFile)(this.filePath(fileName), value, "utf8").then(() => {
      this.#writeFileBlocker.delete(fileName);
      resolver();
    }).catch(() => {
      this.#writeFileBlocker.delete(fileName);
      rejecter();
    });
    return promise;
  }
  async delete(contexts, key) {
    const filename = this.buildStorageKey(contexts, key);
    await this.#finishAllWrites(filename);
    return (0, import_promises.rm)(this.filePath(filename), { force: true });
  }
  /** Returns all keys of a storage context without keys of sub-contexts */
  async keys(contexts) {
    const contextKey = this.getContextBaseKey(contexts);
    const keys = [];
    const contextKeyStart = `${contextKey}.`;
    const len = contextKeyStart.length;
    const files = await (0, import_promises.readdir)(this.#path);
    for (const key of files) {
      const decodedKey = decodeURIComponent(key);
      if (decodedKey.startsWith(contextKeyStart) && !decodedKey.includes(".", len)) {
        keys.push(decodedKey.substring(len));
      }
    }
    return keys;
  }
  async values(contexts) {
    const values = {};
    const promises = new Array();
    for (const key of await this.keys(contexts)) {
      promises.push(
        (async () => {
          const value = await this.get(contexts, key);
          if (value !== void 0) {
            values[key] = value;
          }
        })()
      );
    }
    await Promise.all(promises);
    return values;
  }
  async contexts(contexts) {
    const contextKey = this.getContextBaseKey(contexts, true);
    const startContextKey = contextKey.length ? `${contextKey}.` : "";
    const len = startContextKey.length;
    const foundContexts = new Array();
    const files = await (0, import_promises.readdir)(this.#path);
    for (const key of files) {
      const decodedKey = decodeURIComponent(key);
      if (decodedKey.startsWith(startContextKey)) {
        const subKeys = decodedKey.substring(len).split(".");
        if (subKeys.length === 1) continue;
        const context = subKeys[0];
        if (!foundContexts.includes(context)) {
          foundContexts.push(context);
        }
      }
    }
    return foundContexts;
  }
  async clearAll(contexts) {
    await this.#finishAllWrites();
    const contextKey = this.getContextBaseKey(contexts, true);
    const startContextKey = contextKey.length ? `${contextKey}.` : "";
    const files = await (0, import_promises.readdir)(this.#path);
    const promises = new Array();
    for (const key of files) {
      const decodedKey = decodeURIComponent(key);
      if (decodedKey.startsWith(startContextKey)) {
        promises.push((0, import_promises.rm)(this.filePath(key), { force: true }));
      }
    }
    await Promise.all(promises);
  }
}
//# sourceMappingURL=StorageBackendDiskAsync.js.map
