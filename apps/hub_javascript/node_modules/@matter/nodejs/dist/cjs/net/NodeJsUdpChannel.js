"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var NodeJsUdpChannel_exports = {};
__export(NodeJsUdpChannel_exports, {
  NodeJsUdpChannel: () => NodeJsUdpChannel
});
module.exports = __toCommonJS(NodeJsUdpChannel_exports);
var import_general = require("#general");
var import_protocol = require("#protocol");
var dgram = __toESM(require("dgram"), 1);
var import_NodeJsNetwork = require("./NodeJsNetwork.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("UdpChannelNode");
function createDgramSocket(host, port, options) {
  const socket = dgram.createSocket(options);
  return new Promise((resolve, reject) => {
    const handleBindError = (error) => {
      try {
        socket.close();
      } catch (error2) {
        logger.debug("Error on closing socket", error2);
      }
      reject(error);
    };
    socket.on("error", handleBindError);
    socket.bind(port, host, () => {
      const { address: localHost, port: localPort } = socket.address();
      logger.debug(
        "Socket created and bound ",
        import_general.Diagnostic.dict({
          remoteAddress: `${host}:${port}`,
          localAddress: `${localHost}:${localPort}`
        })
      );
      socket.removeListener("error", handleBindError);
      socket.on("error", (error) => logger.error(error));
      resolve(socket);
    });
  });
}
class NodeJsUdpChannel {
  constructor(type, socket, netInterface) {
    this.type = type;
    this.socket = socket;
    this.netInterface = netInterface;
  }
  static async create({
    listeningPort,
    type,
    listeningAddress,
    netInterface,
    membershipAddresses
  }) {
    const socketOptions = { type, reuseAddr: true };
    if (type === "udp6") {
      socketOptions.ipv6Only = true;
    }
    const socket = await createDgramSocket(listeningAddress, listeningPort, socketOptions);
    socket.setBroadcast(true);
    let netInterfaceZone;
    if (netInterface !== void 0) {
      netInterfaceZone = import_NodeJsNetwork.NodeJsNetwork.getNetInterfaceZoneIpv6(netInterface);
      let multicastInterface;
      if (type === "udp4") {
        multicastInterface = import_NodeJsNetwork.NodeJsNetwork.getMulticastInterfaceIpv4(netInterface);
        if (multicastInterface === void 0) {
          throw new import_general.NetworkError(`No IPv4 addresses on interface: ${netInterface}`);
        }
      } else {
        if (netInterfaceZone === void 0) {
          throw new import_general.NetworkError(`No IPv6 addresses on interface: ${netInterface}`);
        }
        multicastInterface = `::%${netInterfaceZone}`;
      }
      logger.debug(
        "Initialize multicast",
        import_general.Diagnostic.dict({
          address: `${multicastInterface}:${listeningPort}`,
          interface: netInterface,
          type
        })
      );
      socket.setMulticastInterface(multicastInterface);
    }
    if (membershipAddresses !== void 0) {
      const multicastInterfaces = import_NodeJsNetwork.NodeJsNetwork.getMembershipMulticastInterfaces(netInterface, type === "udp4");
      for (const address of membershipAddresses) {
        for (const multicastInterface of multicastInterfaces) {
          try {
            socket.addMembership(address, multicastInterface);
          } catch (error) {
            logger.warn(
              `Error adding membership for address ${address}${multicastInterface ? ` with interface ${multicastInterface}` : ""}: ${error}`
            );
          }
        }
      }
    }
    return new NodeJsUdpChannel(type, socket, netInterfaceZone);
  }
  maxPayloadSize = import_general.MAX_UDP_MESSAGE_SIZE;
  onData(listener) {
    const messageListener = (data, { address, port }) => {
      const netInterface = this.netInterface ?? import_NodeJsNetwork.NodeJsNetwork.getNetInterfaceForIp(address);
      if (netInterface === void 0) return;
      listener(netInterface, address, port, data);
    };
    this.socket.on("message", messageListener);
    return {
      close: async () => {
        this.socket.removeListener("message", messageListener);
      }
    };
  }
  async send(host, port, data) {
    return new Promise((resolve, reject) => {
      this.socket.send(data, port, host, (error) => {
        if (error !== null) {
          const netError = error instanceof Error && "code" in error && error.code === "EHOSTUNREACH" ? new import_protocol.RetransmissionLimitReachedError(error.message) : new import_general.NetworkError(error.message);
          netError.stack = error.stack;
          reject(netError);
          return;
        }
        resolve();
      });
    });
  }
  async close() {
    try {
      this.socket.close();
    } catch (error) {
      logger.debug("Error on closing socket", error);
    }
  }
  get port() {
    return this.socket.address().port;
  }
  supports(type, address) {
    if (type !== import_general.ChannelType.UDP) {
      return false;
    }
    if (address === void 0) {
      return true;
    }
    if (this.type === "udp4") {
      return (0, import_general.isIPv4)(address);
    }
    return (0, import_general.isIPv6)(address);
  }
}
//# sourceMappingURL=NodeJsUdpChannel.js.map
