"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Constraint_exports = {};
__export(Constraint_exports, {
  Constraint: () => Constraint
});
module.exports = __toCommonJS(Constraint_exports);
var import_general = require("@matter/general");
var import_common = require("../common/index.js");
var import_Aspect = require("./Aspect.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class Constraint extends import_Aspect.Aspect {
  /**
   * Initialize from a Constraint.Definition or the constraint DSL defined by the Matter Specification.
   */
  constructor(definition) {
    super(definition);
    let ast;
    switch (typeof definition) {
      case "string":
        if (definition.match(/(?:0b[0x ]*x[0x ]*)|(?:0x[0x_]*x[0x_]*)|(?:00[0x]*x)/i)) {
          break;
        }
        ast = Constraint.parse(this, definition);
        break;
      case "number":
        ast = { value: definition };
        break;
      default:
        ast = definition;
        if (ast?.definition) {
          this.definition = ast.definition;
        }
        break;
    }
    if (!ast) {
      return;
    }
    if (ast.desc !== void 0) {
      this.desc = ast.desc;
    }
    if (ast.value !== void 0) {
      this.value = ast.value;
    }
    if (ast.min !== void 0) {
      this.min = ast.min;
    }
    if (ast.max !== void 0) {
      this.max = ast.max;
    }
    if (ast.in !== void 0) {
      this.in = ast.in;
    }
    if (ast.entry !== void 0) {
      this.entry = new Constraint(ast.entry);
    }
    if (ast.parts !== void 0) {
      this.parts = ast.parts.map((p) => new Constraint(p));
    }
    this.freeze();
  }
  /**
   * Test a value against a constraint.  Does not recurse into arrays.
   */
  test(value, properties) {
    function valueOf(value2, raw = false) {
      if (!raw && (typeof value2 === "string" || Array.isArray(value2))) {
        return value2.length;
      }
      if ((0, import_general.isObject)(value2)) {
        const { type, name } = value2;
        if (type === import_common.FieldValue.reference && typeof name === "string") {
          value2 = valueOf(properties?.[(0, import_general.camelize)(name)], raw);
        }
      }
      return value2;
    }
    if (value === void 0) {
      return false;
    }
    if (this.in) {
      let set = valueOf(this.in, true);
      if (!Array.isArray(set)) {
        set = [set];
      }
      return set.indexOf(value) !== -1;
    }
    const v = valueOf(this.value);
    if (v === value) {
      return true;
    }
    if (v !== void 0 || value === null) {
      return false;
    }
    if (this.min !== void 0 && this.min !== null) {
      const min = valueOf(this.min);
      if (min !== void 0 && min !== null && min > value) {
        return false;
      }
    }
    if (this.max !== void 0 && this.max !== null) {
      const max = valueOf(this.max);
      if (max !== void 0 && max !== null && max < value) {
        return false;
      }
    }
    if (this.parts?.every((part) => part.test(value, properties) === false)) {
      return false;
    }
    return true;
  }
  toString() {
    if (!this.valid && this.definition) {
      return this.definition.toString();
    }
    return Constraint.serialize(this);
  }
  freeze() {
    if (this.parts) {
      Object.freeze(this.parts);
    }
    super.freeze();
  }
}
((Constraint2) => {
  function parseValue(numOrName) {
    let value;
    if (numOrName.match(/^-?0[xb]/)) {
      value = Number.parseInt(numOrName.replace(/[_ ]/g, ""));
    } else {
      value = Number.parseFloat(numOrName);
    }
    if (typeof numOrName === "string") {
      const lower = numOrName.toLowerCase();
      switch (lower) {
        case "true":
          return true;
        case "false":
          return false;
      }
    }
    if (Number.isNaN(value)) {
      return import_common.FieldValue.Reference((0, import_general.camelize)(numOrName));
    }
    if (numOrName.endsWith("%")) {
      return import_common.FieldValue.Percent(value);
    }
    if (numOrName.endsWith("\xB0C")) {
      return import_common.FieldValue.Celsius(value);
    }
    return value;
  }
  function parseAtom(constraint, words) {
    switch (words.length) {
      case 0:
        return void 0;
      case 1:
        switch (words[0].toLowerCase()) {
          case "desc":
            return { desc: true };
          case "all":
          case "any":
            return {};
        }
        const value = parseValue(words[0]);
        if (value === void 0 || value === null) {
          return;
        }
        return { value };
      case 2:
        switch (words[0].toLowerCase()) {
          case "min":
            const min = parseValue(words[1]);
            if (min === void 0 || min === null) {
              return;
            }
            return { min };
          case "max":
            const max = parseValue(words[1]);
            if (max === void 0 || max === null) {
              return;
            }
            return { max };
          case "in":
            const ref = parseValue(words[1]);
            return { in: ref };
          default:
            constraint.error(
              "INVALID_CONSTRAINT",
              `Two word constraint "${words.join(" ")}" does not start with "min" or "max"`
            );
        }
        return;
      case 3:
        if (words[1].toLowerCase() === "to") {
          let parseBound2 = function(name, pos) {
            if (words[pos].toLowerCase() === name) {
              return void 0;
            }
            return parseValue(words[pos]);
          };
          var parseBound = parseBound2;
          const ast = {};
          const min = parseBound2("min", 0);
          if (min !== void 0 && min !== null) {
            ast.min = min;
          }
          const max = parseBound2("max", 2);
          if (max !== void 0 && max !== null) {
            ast.max = max;
          }
          if (ast.min !== void 0 && ast.min !== null || ast.max !== void 0 && ast.max !== null) {
            return ast;
          }
        }
        return;
    }
    constraint.error("INVALID_CONSTRAINT", `Unrecognized value constraint "${words.join(" ")}"`);
  }
  function parse(constraint, definition) {
    let pos = 2;
    let current = definition[0];
    let peeked = definition[1];
    function next() {
      current = peeked;
      if (pos === definition.length) {
        peeked = void 0;
      } else {
        peeked = definition[pos];
        pos++;
      }
    }
    function scan(depth) {
      const parts = Array();
      let words = Array();
      let word = "";
      function parseWords() {
        if (word) {
          words.push(word);
          word = "";
        }
        const atom = parseAtom(constraint, words);
        words = Array();
        return atom;
      }
      function emit() {
        const atom = parseWords();
        if (atom !== void 0) {
          parts.push(atom);
        }
      }
      while (current !== void 0) {
        switch (current) {
          case " ":
          case "	":
          case "\r":
          case "\n":
          case "\v":
          case "\f":
            if (word) {
              words.push(word);
              word = "";
            }
            break;
          case "[":
            next();
            let ast = parseWords();
            const entry = scan(depth + 1);
            if (entry) {
              if (!ast) {
                ast = {};
              }
              ast.entry = entry;
            }
            if (ast) {
              parts.push(ast);
            }
            break;
          case "]":
            if (!depth) {
              constraint.error("INVALID_CONSTRAINT", 'Unexpected "]"');
              break;
            }
            emit();
            if (parts.length > 1) {
              return { parts };
            }
            return parts[0];
          case ",":
            emit();
            break;
          default:
            word += current;
            break;
        }
        next();
      }
      if (depth) {
        constraint.error("INVALID_CONSTRAINT", "Unterminated sub-constraint");
      }
      emit();
      if (parts.length < 2) {
        return parts[0];
      }
      return { parts };
    }
    return scan(0);
  }
  Constraint2.parse = parse;
  function serializeAtom(ast) {
    if (ast.desc) {
      return "desc";
    }
    if (ast.value !== void 0 && ast.value !== null) {
      return `${import_common.FieldValue.serialize(ast.value)}`;
    }
    if (ast.min !== void 0 && ast.min !== null) {
      if (ast.max === void 0 || ast.max === null) {
        return `min ${import_common.FieldValue.serialize(ast.min)}`;
      }
      return `${import_common.FieldValue.serialize(ast.min)} to ${import_common.FieldValue.serialize(ast.max)}`;
    }
    if (ast.max !== void 0 && ast.max !== null) {
      return `max ${import_common.FieldValue.serialize(ast.max)}`;
    }
    if (ast.in !== void 0) {
      return `in ${import_common.FieldValue.serialize(ast.in)}`;
    }
    return "all";
  }
  function serialize(ast) {
    if (ast.parts) {
      return ast.parts.map(serialize).join(", ");
    }
    if (ast.entry) {
      return `${serializeAtom(ast)}[${serialize(ast.entry)}]`;
    }
    return serializeAtom(ast);
  }
  Constraint2.serialize = serialize;
})(Constraint || (Constraint = {}));
//# sourceMappingURL=Constraint.js.map
