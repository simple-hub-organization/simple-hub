"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Observable_exports = {};
__export(Observable_exports, {
  AsyncObservable: () => AsyncObservable,
  BasicObservable: () => BasicObservable,
  EventEmitter: () => EventEmitter,
  Observable: () => Observable,
  ObservableProxy: () => ObservableProxy,
  ObserverGroup: () => ObserverGroup,
  observant: () => observant
});
module.exports = __toCommonJS(Observable_exports);
var import_MatterError = require("../MatterError.js");
var import_Logger = require("../log/Logger.js");
var import_disposable = require("../polyfills/disposable.js");
var import_Promises = require("./Promises.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("Observable");
const observant = Symbol("consider-observed");
function defaultErrorHandler(error) {
  throw error;
}
class BasicObservable {
  #errorHandler;
  #observers;
  #once;
  #isAsync;
  #joinIteration;
  #removeIterator;
  #stopIteration;
  constructor(errorHandler, isAsync) {
    this.#errorHandler = errorHandler ?? defaultErrorHandler;
    this.#isAsync = isAsync;
  }
  [Symbol.dispose]() {
    this.#observers = this.#once = void 0;
    this.#stopIteration?.();
  }
  get isAsync() {
    return this.#isAsync;
  }
  set isAsync(isAsync) {
    this.#isAsync = isAsync;
  }
  get isObserved() {
    if (this.#observers) {
      for (const observer of this.#observers) {
        if (observer[observant] !== false) {
          return true;
        }
      }
    }
    if (this.#once) {
      for (const observer of this.#once) {
        if (observer[observant] !== false) {
          return true;
        }
      }
    }
    return false;
  }
  isObservedBy(observer) {
    return !!this.#observers?.has(observer);
  }
  emit(...payload) {
    if (!this.#observers) {
      return;
    }
    const iterator = [...this.#observers][Symbol.iterator]();
    const emitNext = (previousEmitResult) => {
      if (previousEmitResult !== void 0) {
        return previousEmitResult;
      }
      for (let iteration = iterator.next(); !iteration.done; iteration = iterator.next()) {
        let result;
        const observer = iteration.value;
        try {
          result = observer(...payload);
        } catch (e) {
          if (e instanceof Error) {
            this.#errorHandler(e, observer);
          } else {
            this.#errorHandler(new Error(`${e}`), observer);
          }
        }
        if (this.#once?.has(observer)) {
          this.#once.delete(observer);
          this.#observers?.delete(observer);
        }
        if (result === void 0) {
          continue;
        }
        if (import_Promises.MaybePromise.is(result)) {
          if (!this.isAsync) {
            let identity;
            if (observer.name) {
              identity = ` "${observer.name}"`;
            } else {
              identity = "";
            }
            result.then(
              void 0,
              (error) => logger.error(`Unhandled error in async observer${identity}:`, error)
            );
            continue;
          }
          return result.then((result2) => {
            if (result2 === void 0) {
              return emitNext();
            }
            return result2;
          });
        }
        return result;
      }
    };
    return emitNext();
  }
  on(observer) {
    if (!this.#observers) {
      this.#observers = /* @__PURE__ */ new Set();
    }
    this.#observers.add(observer);
  }
  off(observer) {
    this.#observers?.delete(observer);
  }
  once(observer) {
    this.on(observer);
    if (!this.#once) {
      this.#once = /* @__PURE__ */ new Set();
    }
    this.#once.add(observer);
  }
  then(onfulfilled, onrejected) {
    return new Promise((resolve) => {
      this.once((...payload) => {
        resolve(payload);
      });
    }).then(onfulfilled, onrejected);
  }
  async *[Symbol.asyncIterator]() {
    let promise = this.#addIterator();
    try {
      while (promise) {
        const next = await promise;
        if (next) {
          promise = next.promise;
          yield next.value;
        }
      }
    } finally {
      this.#removeIterator?.();
    }
  }
  #addIterator() {
    if (this.#joinIteration) {
      return this.#joinIteration();
    }
    let resolve;
    let iteratorCount = 1;
    function newPromise() {
      return new Promise((r) => resolve = r);
    }
    let promise = newPromise();
    function observer(...args) {
      const oldResolve = resolve;
      promise = newPromise();
      oldResolve({ value: args[0], promise });
    }
    this.on(observer);
    this.#joinIteration = () => {
      iteratorCount++;
      return promise;
    };
    this.#removeIterator = () => {
      if (!iteratorCount--) {
        this.#stopIteration?.();
      }
    };
    this.#stopIteration = () => {
      this.off(observer);
      resolve(void 0);
      this.#stopIteration = void 0;
      this.#removeIterator = void 0;
    };
  }
}
function constructObservable(errorHandler) {
  return new BasicObservable(errorHandler);
}
const Observable = constructObservable;
function constructAsyncObservable(errorHandler) {
  return new BasicObservable(errorHandler, true);
}
const AsyncObservable = constructAsyncObservable;
function event(emitter, name) {
  const observer = emitter[name];
  if (typeof !observer?.on !== "function") {
    throw new import_MatterError.ImplementationError(`Invalid event name ${name}`);
  }
  return observer;
}
class EventEmitter {
  emit(name, ...payload) {
    event(this, name).emit(...payload);
  }
  addListener(name, handler) {
    event(this, name).on(handler);
  }
  removeListener(name, handler) {
    event(this, name).off(handler);
  }
  get eventNames() {
    return Object.keys(this).filter((k) => typeof this[k]?.on === "function");
  }
  [Symbol.dispose]() {
    for (const name of this.eventNames) {
      this[name][Symbol.dispose]?.();
    }
  }
}
class ObservableProxy extends BasicObservable {
  #target;
  #emitter = super.emit.bind(this);
  constructor(target) {
    super();
    Object.defineProperty(this.#emitter, observant, {
      get() {
        return this.isObserved;
      }
    });
    this.#target = target;
    this.#target.on(this.#emitter);
    this.emit = this.#target.emit.bind(this.#target);
  }
  [Symbol.dispose]() {
    this.#target.off(this.#emitter);
    super[Symbol.dispose]();
  }
  get isAsync() {
    return this.#target.isAsync;
  }
  get isObserved() {
    return this.#target.isObserved;
  }
  emit;
}
class ObserverGroup {
  #defaultTarget;
  #observers = /* @__PURE__ */ new Map();
  #boundObservers = /* @__PURE__ */ new Map();
  constructor(target) {
    this.#defaultTarget = target;
  }
  /**
   * Add an observer.
   *
   * @param observable the observable to observe
   * @param observer the observer function
   * @param target optional "this" to bind the observer
   */
  on(observable, observer, target = this.#defaultTarget) {
    if (target !== void 0) {
      observer = observer.bind(target);
    }
    observable.on(observer);
    const observers = this.#observers.get(observable);
    if (observers === void 0) {
      this.#observers.set(observable, [observer]);
    } else {
      observers.push(observer);
    }
  }
  /**
   * Remove a single observer.
   *
   * @param observable the observable to observe
   * @param observer the observer function
   * @param target if the observer was bound in {@link on} this must match the bound target
   */
  off(observable, observer, target = this.#defaultTarget) {
    if (target) {
      const observers2 = this.#boundObservers.get(observer);
      if (observers2 === void 0) {
        return;
      }
      const bound = observers2.get(target);
      if (bound === void 0) {
        return;
      }
      observers2.delete(target);
      if (observers2.size === 0) {
        this.#boundObservers.delete(observer);
      }
    }
    const observers = this.#observers.get(observable);
    if (observers) {
      const index = observers.indexOf(observer);
      if (index !== -1) {
        observers?.splice(index, 1);
      }
    }
    observable.off(observer);
  }
  /**
   * Remove all observers.
   */
  close() {
    for (const [observable, observers] of this.#observers.entries()) {
      for (const observer of observers) {
        observable.off(observer);
      }
    }
    this.#observers.clear();
    this.#boundObservers.clear();
  }
}
//# sourceMappingURL=Observable.js.map
