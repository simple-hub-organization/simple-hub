/**
 * Utils for promises.
 *
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterError } from "../MatterError.js";
/**
 * Obtain a promise with functions to resolve and reject.
 */
export declare function createPromise<T>(): {
    promise: Promise<T>;
    resolver: (value: T) => void;
    rejecter: (reason?: any) => void;
};
/**
 * Use all promises or promise returning methods and return the first resolved promise or reject when all promises
 * rejected
 */
export declare function anyPromise<T>(promises: ((() => Promise<T>) | Promise<T>)[]): Promise<T>;
/**
 * Thrown when a timed promise times out.
 */
export declare class PromiseTimeoutError extends MatterError {
    constructor(message?: string);
}
/**
 * Create a promise with a timeout.
 *
 * By default rejects with {@link PromiseTimeoutError} on timeout but you can override by supplying {@link cancel}.
 *
 * @param timeoutMs the timeout in milliseconds
 * @param promise a promise that resolves or rejects when the timed task completes
 * @param cancel invoked on timeout (default implementation throws {@link PromiseTimeoutError})
 */
export declare function withTimeout<T>(timeoutMs: number, promise: Promise<T>, cancel?: AbortController | (() => void)): Promise<T>;
/**
 * Return type for functions that are optionally asynchronous.
 *
 * TODO - as currently defined MaybePromise of a Promise incorrectly wraps as a Promise of a Promise
 */
export type MaybePromise<T = void> = T | PromiseLike<T>;
/**
 * Promise-like version of above.
 */
export type MaybePromiseLike<T = void> = T | PromiseLike<T>;
export declare const MaybePromise: {
    /**
     * Determine whether a {@link MaybePromiseLike} is a {@link Promise}.
     */
    is<T>(value: MaybePromise<T>): value is PromiseLike<T>;
    /**
     * Chained MaybePromise.  Invokes the resolve function immediately if the {@link MaybePromise} is not a
     * {@link Promise}, otherwise the same as a normal {@link Promise.then}.
     */
    then<I, O1 = never, O2 = never>(producer: MaybePromise<I> | (() => MaybePromise<I>), resolve?: ((input: I) => MaybePromise<O1>) | null, reject?: ((error: any) => MaybePromise<O2>) | null): MaybePromise<O1 | O2>;
    /**
     * Equivalent of {@link Promise.catch}.
     */
    catch<T, TResult = never>(producer: MaybePromise<T> | (() => MaybePromise<T>), onrejected?: ((reason: any) => MaybePromise<TResult>) | undefined | null): MaybePromise<TResult>;
    /**
     * Equivalent of {@link Promise.finally}.
     */
    finally<T>(producer: MaybePromise<T> | (() => MaybePromise<T>), onfinally?: (() => MaybePromise<void>) | undefined | null): MaybePromise<T>;
    [Symbol.toStringTag]: string;
};
/**
 * A "promise" that may be canceled.
 *
 * Behaviors like a normal promise but does not actually extend {@link Promise} because that makes extension a PITA.
 */
export declare class CancelablePromise<T = void> implements Promise<T> {
    #private;
    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void, onCancel?: () => void);
    cancel(): void;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): CancelablePromise<TResult1 | TResult2>;
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): CancelablePromise<T | TResult>;
    finally(onfinally?: (() => void) | undefined | null): CancelablePromise<T>;
    get [Symbol.toStringTag](): string;
    static is<T>(value: MaybePromise<T>): value is CancelablePromise<T>;
}
//# sourceMappingURL=Promises.d.ts.map