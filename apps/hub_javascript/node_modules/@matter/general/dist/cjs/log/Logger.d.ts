/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { LogLevel } from "./LogLevel.js";
/**
 * Log messages to the console.  This is the default logging mechanism.
 */
export declare function consoleLogger(level: LogLevel, formattedLog: string): void;
export declare namespace consoleLogger {
    /**
     * The target for consoleLogger.
     */
    let console: Console;
}
/**
 * Definition of one registered Logger.
 */
type LoggerDefinition = {
    logIdentifier: string;
    logFormatter: (now: Date, level: LogLevel, facility: string, prefix: string, ...values: any[]) => string;
    log: (level: LogLevel, formattedLog: string) => void;
    defaultLogLevel: LogLevel;
    logLevels: {
        [facility: string]: LogLevel;
    };
};
/**
 * Logger that can be used to emit traces.
 *
 * The class supports adding multiple loggers for different targets. A default logger (identifier "default") is added on
 * startup which logs to "console".
 *
 * Usage:
 *
 *   const facility = Logger.get("loggerName");
 *   facility.debug("My debug message", "my extra value to log");
 *
 * The configuration of the default logger can be adjusted by using the static properties of the Logger class:
 *
 *   - Logger.defaultLogLevel sets the default log level for all the facility
 *   - Logger.logLevels = { loggerName: Level.DEBUG } can set the level for the specific loggers
 *   - Logger.format = Format.ANSI enables colorization via ANSI escape sequences in default formatter
 *
 * For additional loggers, use Logger.addLogger() to add a new logger with a specific identifier. Afterwards the
 * configuration of these can be adjusted using static methods with the identifier as first parameter:
 *
 *   - Logger.setFormatForLogger("loggerName", Format.ANSI)
 *   - Logger.setLogLevelsForLogger("loggerName", { loggerName: Level.DEBUG })
 *   - Logger.setDefaultLoglevelForLogger("loggerName", Level.DEBUG)
 */
export declare class Logger {
    private readonly name;
    static logger: Array<LoggerDefinition>;
    static nestingLevel: number;
    /** Add additional logger to the list of loggers including the default configuration. */
    static addLogger(identifier: string, logger: (level: LogLevel, formattedLog: string) => void, options?: {
        defaultLogLevel?: LogLevel;
        logLevels?: {
            [facility: string]: LogLevel;
        };
        logFormat?: string;
    }): void;
    static removeLogger(identifier: string): void;
    /**
     * Get the logger with the matching identifier.
     * @param identifier The identifier of the logger
     */
    static getLoggerforIdentifier(identifier: string): LoggerDefinition;
    /**
     * Set log level using configuration-style level name for the default logger.
     */
    static set level(level: number | string);
    /**
     * Set logFormatter using configuration-style format name.
     *
     * @param format the name of the formatter (see Format enum)
     */
    static set format(format: string);
    /**
     * Set facility loglevels for the default logger.
     * @param levels The levels to set
     */
    static set logLevels(levels: {
        [facility: string]: LogLevel;
    });
    /**
     * Get facility loglevels for the default logger.
     */
    static get logLevels(): {
        [facility: string]: LogLevel;
    };
    /**
     * Set default loglevel for the default logger.
     *
     * @param level The level to set
     */
    static set defaultLogLevel(level: LogLevel);
    /**
     * Get default loglevel for the default logger.
     */
    static get defaultLogLevel(): LogLevel;
    /**
     * Set the log function for the default logger.
     *
     * @param log The log function to set
     */
    static set log(log: (level: LogLevel, formattedLog: string) => void);
    /**
     * Get the log function for the default logger.
     */
    static get log(): (level: LogLevel, formattedLog: string) => void;
    /**
     * Set the log formatter for the default logger.
     *
     * @param logFormatter
     */
    static set logFormatter(logFormatter: (now: Date, level: LogLevel, facility: string, nestingPrefix: string, values: any[]) => string);
    /**
     * Get the log formatter for the default logger.
     */
    static get logFormatter(): (now: Date, level: LogLevel, facility: string, nestingPrefix: string, values: any[]) => string;
    /**
     * Set logFormatter using configuration-style format name for the logger with the matching identifier.
     *
     * @param identifier The identifier of the logger
     * @param format the name of the formatter (see Format enum)
     */
    static setFormatForLogger(identifier: string, format: string): void;
    /**
     * Set default loglevel for the logger with the matching identifier.
     *
     * @param identifier The identifier of the logger
     * @param level The level to set
     */
    static setDefaultLoglevelForLogger(identifier: string, level: LogLevel): void;
    /**
     * Set facility loglevels for the logger with the matching identifier.
     *
     * @param identifier The identifier of the logger
     * @param levels The levels to set
     */
    static setLogLevelsForLogger(identifier: string, levels: {
        [facility: string]: LogLevel;
    }): void;
    /**
     * Set the log function for the logger with the matching identifier.
     *
     * @param identifier The identifier of the logger
     * @param log The log function to set
     */
    static setLogger(identifier: string, log: (level: LogLevel, formattedLog: string) => void): void;
    /**
     * Set the log formatter for the logger with the matching identifier.
     *
     * @param identifier The identifier of the logger
     * @param logFormatter The log formatter to set
     */
    static setLogFormatterForLogger(identifier: string, logFormatter: (now: Date, level: LogLevel, facility: string, nestingPrefix: string, values: any[]) => string): void;
    /**
     * Create a new facility.
     *
     * @param name the name of the facility
     * @returns a new facility
     */
    static get(name: string): Logger;
    /**
     * Stringify a value (BigInt aware) as JSON.
     *
     * @param data the value to stringify
     * @returns the stringified value
     */
    static toJSON(data: any): string;
    /**
     * Mask a string with a given character. If unmaskedLength is provided then these number of characters will be
     * shown unmasked.
     *
     * @param str String to mask
     * @param maskChar character to mask with
     * @param unmaskedLength number of characters to show unmasked in the beginning
     */
    static maskString(str: string, maskChar?: string, unmaskedLength?: number): string;
    /**
     * Perform operations in a nested logging context.  Messages will be
     * indented while the context executes.
     */
    static nest<T>(context: () => T): T;
    /**
     * Async version of nest().
     */
    static nestAsync(context: () => Promise<any>): Promise<any>;
    /**
     * Unhandled error reporter.
     *
     * Some environments do not report full error details such as {@link Error#cause} and {@link AggregateError#errors}.
     *
     * To ensure these details are always recorded somewhere, unhandled errors may be reported here.
     *
     * To disable this behavior replace this function.
     */
    static reportUnhandledError(error: Error): void;
    /**
     * Invoke logic and return any log messages produced.
     */
    static capture(fn: () => void, fromLogger?: string): {
        level: LogLevel;
        message: string;
    }[];
    constructor(name: string);
    debug: (...values: any[]) => void;
    info: (...values: any[]) => void;
    notice: (...values: any[]) => void;
    warn: (...values: any[]) => void;
    error: (...values: any[]) => void;
    fatal: (...values: any[]) => void;
    private log;
}
export {};
//# sourceMappingURL=Logger.d.ts.map