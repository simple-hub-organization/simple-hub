/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Logger } from "../log/Logger.js";
import { Cache } from "../util/Cache.js";
import { isIPv4 } from "../util/Ip.js";
const logger = Logger.get("UdpMulticastServer");
class UdpMulticastServer {
  constructor(network, broadcastAddressIpv4, broadcastAddressIpv6, broadcastPort, serverIpv4, serverIpv6, netInterface) {
    this.network = network;
    this.broadcastAddressIpv4 = broadcastAddressIpv4;
    this.broadcastAddressIpv6 = broadcastAddressIpv6;
    this.broadcastPort = broadcastPort;
    this.serverIpv4 = serverIpv4;
    this.serverIpv6 = serverIpv6;
    this.netInterface = netInterface;
  }
  static async create({
    netInterface,
    broadcastAddressIpv4,
    broadcastAddressIpv6,
    listeningPort,
    network
  }) {
    return new UdpMulticastServer(
      network,
      broadcastAddressIpv4,
      broadcastAddressIpv6,
      listeningPort,
      broadcastAddressIpv4 === void 0 ? void 0 : await network.createUdpChannel({
        type: "udp4",
        netInterface,
        listeningPort,
        membershipAddresses: [broadcastAddressIpv4]
      }),
      await network.createUdpChannel({
        type: "udp6",
        netInterface,
        listeningPort,
        membershipAddresses: [broadcastAddressIpv6]
      }),
      netInterface
    );
  }
  broadcastChannels = new Cache(
    "UDP broadcast channel",
    (netInterface, iPv4) => this.createBroadcastChannel(netInterface, iPv4),
    5 * 60 * 1e3,
    async (_netInterface, channel) => (await channel).close()
  );
  onMessage(listener) {
    this.serverIpv4?.onData(
      (netInterface, peerAddress, _port, message) => listener(message, peerAddress, netInterface)
    );
    this.serverIpv6.onData(
      (netInterface, peerAddress, _port, message) => listener(message, peerAddress, netInterface)
    );
  }
  async send(message, netInterface, uniCastTarget) {
    netInterface = netInterface ?? this.netInterface;
    if (uniCastTarget !== void 0 && netInterface !== void 0) {
      try {
        await (await this.broadcastChannels.get(netInterface, isIPv4(uniCastTarget))).send(uniCastTarget, this.broadcastPort, message);
      } catch (error) {
        logger.info(`${netInterface} ${uniCastTarget}: ${error.message}`);
      }
    } else {
      const netInterfaces = netInterface !== void 0 ? [{ name: netInterface }] : await this.network.getNetInterfaces();
      await Promise.all(
        netInterfaces.map(async ({ name: netInterface2 }) => {
          const { ipV4, ipV6 } = await this.network.getIpMac(netInterface2) ?? {
            mac: "",
            ipV4: [],
            ipV6: []
          };
          const ips = [...ipV4, ...ipV6];
          await Promise.all(
            ips.map(async (ip) => {
              const iPv4 = ipV4.includes(ip);
              const broadcastTarget = iPv4 ? this.broadcastAddressIpv4 : this.broadcastAddressIpv6;
              if (broadcastTarget == void 0) {
                return;
              }
              try {
                await (await this.broadcastChannels.get(netInterface2, iPv4)).send(broadcastTarget, this.broadcastPort, message);
              } catch (error) {
                logger.info(`${netInterface2}: ${error.message}`);
              }
            })
          );
        })
      );
    }
  }
  async createBroadcastChannel(netInterface, iPv4) {
    return await this.network.createUdpChannel({
      type: iPv4 ? "udp4" : "udp6",
      listeningPort: this.broadcastPort,
      netInterface
    });
  }
  async close() {
    this.serverIpv4?.close();
    this.serverIpv6.close();
    await this.broadcastChannels.close();
  }
}
export {
  UdpMulticastServer
};
//# sourceMappingURL=UdpMulticastServer.js.map
