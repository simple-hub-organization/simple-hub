/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { LogLevel } from "./LogLevel.js";
function Diagnostic(presentation, value) {
  return {
    [Diagnostic.presentation]: presentation,
    [Diagnostic.value]: value
  };
}
((Diagnostic2) => {
  let Presentation;
  ((Presentation2) => {
    Presentation2["Message"] = "message";
    Presentation2["List"] = "list";
    Presentation2["Squash"] = "squash";
    Presentation2["Strong"] = "strong";
    Presentation2["Weak"] = "weak";
    Presentation2["Error"] = "error";
    Presentation2["Dictionary"] = "dictionary";
    Presentation2["Via"] = "via";
  })(Presentation = Diagnostic2.Presentation || (Diagnostic2.Presentation = {}));
  Diagnostic2.presentation = Symbol("presentation");
  Diagnostic2.value = Symbol("value");
  function message(value2) {
    const { now, level, facility, prefix: nestingPrefix, values } = value2;
    return {
      [Diagnostic2.presentation]: "message" /* Message */,
      now: now ?? /* @__PURE__ */ new Date(),
      level: level ?? LogLevel.INFO,
      facility: facility ?? "Diagnostic",
      prefix: nestingPrefix ?? "",
      values: values ?? []
    };
  }
  Diagnostic2.message = message;
  function strong(value2) {
    return Diagnostic2("strong" /* Strong */, value2);
  }
  Diagnostic2.strong = strong;
  function weak(value2) {
    return Diagnostic2("weak" /* Weak */, value2);
  }
  Diagnostic2.weak = weak;
  function via(value2) {
    if (value2[Diagnostic2.presentation]) {
      return value2;
    }
    const via2 = new String(value2);
    Object.defineProperty(via2, Diagnostic2.presentation, { value: "via" /* Via */ });
    return via2;
  }
  Diagnostic2.via = via;
  function node(icon, label, detail) {
    const result = [icon, Diagnostic2.strong(label)];
    if (detail?.self !== void 0) {
      result.push(detail.self);
    }
    if (detail?.children !== void 0) {
      result.push(Diagnostic2.list(detail.children));
    }
    return result;
  }
  Diagnostic2.node = node;
  function list(value2) {
    return Diagnostic2("list" /* List */, value2);
  }
  Diagnostic2.list = list;
  function squash(...values) {
    return Diagnostic2("squash" /* Squash */, values);
  }
  Diagnostic2.squash = squash;
  function dict(entries) {
    return {
      ...entries,
      [Diagnostic2.presentation]: "dictionary" /* Dictionary */
    };
  }
  Diagnostic2.dict = dict;
  function error(error2) {
    return formatError(error2);
  }
  Diagnostic2.error = error;
  function lifecycle(status, value2) {
    return Diagnostic2(status, value2);
  }
  Diagnostic2.lifecycle = lifecycle;
  function lifecycleList(map) {
    return Object.entries(map).map(([label, status]) => Diagnostic2(status, label));
  }
  Diagnostic2.lifecycleList = lifecycleList;
  function interval(ms) {
    if (ms < 0) {
      return `${(ms * 1e3).toPrecision(3)}\u03BCs`;
    } else if (ms < 1e3) {
      return `${ms.toPrecision(3)}ms`;
    } else if (ms < 6e4) {
      return `${(ms / 1e3).toPrecision(3)}s`;
    }
    let days;
    if (ms > 864e5) {
      days = `${Math.floor(ms / 864e5)}d `;
      ms %= 864e5;
    } else {
      days = "";
    }
    const hours = Math.floor(ms / 36e5).toString().padStart(2, "0");
    ms %= 36e5;
    const minutes = Math.floor(ms / 6e4).toString().padStart(2, "0");
    ms %= 6e4;
    const seconds = Math.floor(ms).toString().padStart(2, "0");
    return `${days}${hours}:${minutes}:${seconds}`;
  }
  Diagnostic2.interval = interval;
  function elapsed() {
    return {
      startedAt: performance.now(),
      get time() {
        return performance.now() - this.startedAt;
      },
      toString() {
        return interval(this.time);
      }
    };
  }
  Diagnostic2.elapsed = elapsed;
  function upgrade(value2, diagnostic) {
    switch (typeof value2) {
      case "boolean":
        value2 = new Boolean(value2);
        break;
      case "number":
        value2 = new Number(value2);
        break;
      case "string":
        value2 = new String(value2);
        break;
    }
    if (typeof diagnostic === "function") {
      Object.defineProperty(value2, Diagnostic2.value, { get: diagnostic });
    } else {
      Object.defineProperty(value2, Diagnostic2.value, { value: diagnostic });
    }
    return value2;
  }
  Diagnostic2.upgrade = upgrade;
  function hex(value2) {
    return `0x${value2.toString(16)}`;
  }
  Diagnostic2.hex = hex;
})(Diagnostic || (Diagnostic = {}));
function formatError(error, options = {}) {
  const { messagePrefix, parentStack } = options;
  const messageAndStack = messageAndStackFor(error, parentStack);
  const { stack, stackLines } = messageAndStack;
  let { message } = messageAndStack;
  if (messagePrefix) {
    message = `${messagePrefix} ${message}`;
  }
  message = Diagnostic.upgrade(message, Diagnostic("error" /* Error */, message));
  let cause, errors;
  if (typeof error === "object" && error !== null) {
    ({ cause, errors } = error);
  }
  if (stack === void 0 && cause === void 0 && errors === void 0) {
    return message;
  }
  const list = [message];
  if (stack !== void 0) {
    list.push(Diagnostic("list" /* List */, stack));
  }
  for (; typeof cause === "object" && cause !== null; cause = cause.cause) {
    let formatted = formatError(cause, { messagePrefix: "Caused by:", parentStack: stackLines });
    if (formatted[Diagnostic.presentation] === "list" /* List */) {
      formatted = formatted[Diagnostic.value] ?? formatted;
    }
    if (Array.isArray(formatted)) {
      list.push(...formatted);
    } else {
      list.push(formatted);
    }
  }
  if (Array.isArray(errors)) {
    let cause2 = 0;
    list.push(
      Diagnostic.list(
        errors.map((e) => formatError(e, { messagePrefix: `Cause #${cause2++}:`, parentStack: stackLines }))
      )
    );
  }
  return list;
}
function messageAndStackFor(error, parentStack) {
  let message;
  let rawStack;
  if (error !== void 0 && error !== null) {
    if (typeof error === "string" || typeof error === "number") {
      return { message: `${error}` };
    }
    if ("message" in error) {
      ({ message, stack: rawStack } = error);
    } else if (error.message) {
      message = typeof error.message === "string" ? message : error.toString();
    }
  }
  if (message === void 0 || message === null || message === "") {
    if (error !== void 0 && error !== null) {
      message = error.constructor.name;
      if (!message || message === "Error") {
        message = "(unknown error)";
      }
    } else {
      message = "(unknown error)";
    }
  }
  if (!rawStack) {
    return { message };
  }
  rawStack = rawStack.toString();
  rawStack = rawStack.replace(/^.*?\n\nError: /gs, "Error: ");
  if (rawStack.startsWith("Error: ")) {
    rawStack = rawStack.slice(7);
  }
  const pos = rawStack.indexOf(message);
  if (pos !== -1) {
    rawStack = rawStack.slice(pos + message.length).trim();
  }
  let stackLines = rawStack.split("\n").map((line) => line.trim()).filter((line) => line !== "");
  if (stackLines[0] === "Error") {
    stackLines.shift();
  }
  let truncatedToParent = false;
  if (parentStack) {
    let truncateTo = 0;
    stackSearch: for (; truncateTo < stackLines.length - 1; truncateTo++) {
      let parentPos = parentStack.indexOf(stackLines[truncateTo]);
      if (parentPos === -1) {
        continue;
      }
      parentPos++;
      for (let pos2 = truncateTo + 1; pos2 < stackLines.length && parentPos < parentStack.length; pos2++, parentPos++) {
        if (stackLines[pos2] !== parentStack[parentPos]) {
          continue stackSearch;
        }
      }
      stackLines = stackLines.slice(0, truncateTo + 1);
      truncatedToParent = true;
      break;
    }
  }
  const stack = Array();
  for (const line of stackLines) {
    const match1 = line.match(/^at\s+(?:(.+)\s+\(([^)]+)\)|(<anonymous>))$/);
    if (match1) {
      const value = [Diagnostic.weak("at "), match1[1] ?? match1[3]];
      if (match1[2] !== void 0) {
        value.push(Diagnostic.weak(" ("), Diagnostic.weak(match1[2]), Diagnostic.weak(")"));
      }
      stack.push(Diagnostic.squash(...value));
      continue;
    }
    const match2 = line.match(/^at\s+(.+)(:\d+:\d+)$/);
    if (match2) {
      stack.push(Diagnostic.squash(Diagnostic.weak("at "), match2[1], Diagnostic.weak(match2[2])));
      continue;
    }
    stack.push(line);
  }
  if (truncatedToParent) {
    stack.push(Diagnostic.weak("(see parent frames)"));
  }
  return { message, stack, stackLines };
}
export {
  Diagnostic
};
//# sourceMappingURL=Diagnostic.js.map
