/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Boot } from "#util/Boot.js";
import { ImplementationError, NotImplementedError } from "../MatterError.js";
import { Time } from "../time/Time.js";
import { Bytes } from "../util/Bytes.js";
import { Diagnostic } from "./Diagnostic.js";
import { LogFormat } from "./LogFormat.js";
import { LogLevel } from "./LogLevel.js";
function consoleLogger(level, formattedLog) {
  const console2 = consoleLogger.console;
  switch (level) {
    case LogLevel.DEBUG:
      console2.debug(formattedLog);
      break;
    case LogLevel.INFO:
      console2.info(formattedLog);
      break;
    case LogLevel.NOTICE:
      console2.info(formattedLog);
      break;
    case LogLevel.WARN:
      console2.warn(formattedLog);
      break;
    case LogLevel.ERROR:
      console2.error(formattedLog);
      break;
    case LogLevel.FATAL:
      console2.error(formattedLog);
      break;
  }
}
const globalConsole = console;
((consoleLogger2) => {
  consoleLogger2.console = globalConsole;
})(consoleLogger || (consoleLogger = {}));
function logFormatterFor(formatName) {
  const format = LogFormat(formatName);
  return (now, level, facility, prefix, ...values) => format(Diagnostic.message({ now, level, facility, prefix, values }));
}
class Logger {
  constructor(name) {
    this.name = name;
  }
  static logger;
  static nestingLevel;
  /** Add additional logger to the list of loggers including the default configuration. */
  static addLogger(identifier, logger, options) {
    if (Logger.logger.some((logger2) => logger2.logIdentifier === identifier)) {
      throw new NotImplementedError(`Logger "${identifier}" already exists`);
    }
    Logger.logger.push({
      logIdentifier: identifier,
      logFormatter: logFormatterFor(options?.logFormat ?? LogFormat.PLAIN),
      log: logger,
      defaultLogLevel: options?.defaultLogLevel ?? LogLevel.DEBUG,
      logLevels: options?.logLevels ?? {}
    });
  }
  static removeLogger(identifier) {
    const index = Logger.logger.findIndex((logger) => logger.logIdentifier === identifier);
    if (index === -1) {
      throw new NotImplementedError(`Logger "${identifier}" does not exist`);
    }
    Logger.logger.splice(index, 1);
  }
  /**
   * Get the logger with the matching identifier.
   * @param identifier The identifier of the logger
   */
  static getLoggerforIdentifier(identifier) {
    const logger = Logger.logger.find((logger2) => logger2.logIdentifier === identifier);
    if (logger === void 0) {
      throw new NotImplementedError(`Unknown logger "${identifier}"`);
    }
    return logger;
  }
  /**
   * Set log level using configuration-style level name for the default logger.
   */
  static set level(level) {
    if (level === void 0) {
      level = LogLevel.DEBUG;
    }
    let levelNum;
    if (typeof level === "string") {
      if (level.match(/^[0-9]+$/)) {
        levelNum = Number.parseInt(level);
      } else {
        levelNum = LogLevel[level.toUpperCase()];
        if (levelNum === void 0) {
          throw new ImplementationError(`Unsupported log level "${level}"`);
        }
      }
    } else {
      levelNum = level;
    }
    if (LogLevel[levelNum] === void 0) {
      throw new ImplementationError(`Unsupported log level "${level}"`);
    }
    Logger.defaultLogLevel = levelNum;
  }
  /**
   * Set logFormatter using configuration-style format name.
   *
   * @param format the name of the formatter (see Format enum)
   */
  static set format(format) {
    Logger.setLogFormatterForLogger("default", logFormatterFor(format));
  }
  /**
   * Set facility loglevels for the default logger.
   * @param levels The levels to set
   */
  static set logLevels(levels) {
    Logger.setLogLevelsForLogger("default", levels);
  }
  /**
   * Get facility loglevels for the default logger.
   */
  static get logLevels() {
    return Logger.getLoggerforIdentifier("default").logLevels;
  }
  /**
   * Set default loglevel for the default logger.
   *
   * @param level The level to set
   */
  static set defaultLogLevel(level) {
    Logger.setDefaultLoglevelForLogger("default", level);
  }
  /**
   * Get default loglevel for the default logger.
   */
  static get defaultLogLevel() {
    return Logger.getLoggerforIdentifier("default").defaultLogLevel;
  }
  /**
   * Set the log function for the default logger.
   *
   * @param log The log function to set
   */
  static set log(log) {
    Logger.setLogger("default", log);
  }
  /**
   * Get the log function for the default logger.
   */
  static get log() {
    return Logger.getLoggerforIdentifier("default").log;
  }
  /**
   * Set the log formatter for the default logger.
   *
   * @param logFormatter
   */
  static set logFormatter(logFormatter) {
    Logger.setLogFormatterForLogger("default", logFormatter);
  }
  /**
   * Get the log formatter for the default logger.
   */
  static get logFormatter() {
    return Logger.getLoggerforIdentifier("default").logFormatter;
  }
  /**
   * Set logFormatter using configuration-style format name for the logger with the matching identifier.
   *
   * @param identifier The identifier of the logger
   * @param format the name of the formatter (see Format enum)
   */
  static setFormatForLogger(identifier, format) {
    const logger = Logger.logger.find((logger2) => logger2.logIdentifier === identifier);
    if (logger) {
      logger.logFormatter = logFormatterFor(format);
    } else {
      throw new NotImplementedError(`Unknown logger "${identifier}"`);
    }
  }
  /**
   * Set default loglevel for the logger with the matching identifier.
   *
   * @param identifier The identifier of the logger
   * @param level The level to set
   */
  static setDefaultLoglevelForLogger(identifier, level) {
    const logger = Logger.logger.find((logger2) => logger2.logIdentifier === identifier);
    if (logger) {
      logger.defaultLogLevel = level;
    } else {
      throw new NotImplementedError(`Unknown logger "${identifier}"`);
    }
  }
  /**
   * Set facility loglevels for the logger with the matching identifier.
   *
   * @param identifier The identifier of the logger
   * @param levels The levels to set
   */
  static setLogLevelsForLogger(identifier, levels) {
    const logger = Logger.logger.find((logger2) => logger2.logIdentifier === identifier);
    if (logger) {
      logger.logLevels = levels;
    } else {
      throw new NotImplementedError(`Unknown logger "${identifier}"`);
    }
  }
  /**
   * Set the log function for the logger with the matching identifier.
   *
   * @param identifier The identifier of the logger
   * @param log The log function to set
   */
  static setLogger(identifier, log) {
    const logger = Logger.logger.find((logger2) => logger2.logIdentifier === identifier);
    if (logger) {
      logger.log = log;
    } else {
      throw new NotImplementedError(`Unknown logger "${identifier}"`);
    }
  }
  /**
   * Set the log formatter for the logger with the matching identifier.
   *
   * @param identifier The identifier of the logger
   * @param logFormatter The log formatter to set
   */
  static setLogFormatterForLogger(identifier, logFormatter) {
    const logger = Logger.logger.find((logger2) => logger2.logIdentifier === identifier);
    if (logger) {
      logger.logFormatter = logFormatter;
    } else {
      throw new NotImplementedError(`Unknown logger "${identifier}"`);
    }
  }
  /**
   * Create a new facility.
   *
   * @param name the name of the facility
   * @returns a new facility
   */
  static get(name) {
    return new Logger(name);
  }
  /**
   * Stringify a value (BigInt aware) as JSON.
   *
   * @param data the value to stringify
   * @returns the stringified value
   */
  static toJSON(data) {
    return JSON.stringify(data, (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      if (value instanceof Uint8Array) {
        return Bytes.toHex(value);
      }
      if (value === void 0) {
        return "undefined";
      }
      return value;
    });
  }
  /**
   * Mask a string with a given character. If unmaskedLength is provided then these number of characters will be
   * shown unmasked.
   *
   * @param str String to mask
   * @param maskChar character to mask with
   * @param unmaskedLength number of characters to show unmasked in the beginning
   */
  static maskString(str, maskChar = "*", unmaskedLength) {
    return str.substring(0, unmaskedLength ?? 0) + str.substring(unmaskedLength ?? 0).replace(/./g, maskChar);
  }
  /**
   * Perform operations in a nested logging context.  Messages will be
   * indented while the context executes.
   */
  static nest(context) {
    this.nestingLevel++;
    try {
      return context();
    } finally {
      this.nestingLevel--;
    }
  }
  /**
   * Async version of nest().
   */
  static async nestAsync(context) {
    this.nestingLevel++;
    try {
      return await context();
    } finally {
      this.nestingLevel--;
    }
  }
  /**
   * Unhandled error reporter.
   *
   * Some environments do not report full error details such as {@link Error#cause} and {@link AggregateError#errors}.
   *
   * To ensure these details are always recorded somewhere, unhandled errors may be reported here.
   *
   * To disable this behavior replace this function.
   */
  static reportUnhandledError(error) {
    try {
      Logger.get("Logger").fatal("Unhandled error detected:", error);
    } catch (e) {
    }
  }
  /**
   * Invoke logic and return any log messages produced.
   */
  static capture(fn, fromLogger = "default") {
    if (!Logger) {
      throw new Error("No logger loaded, cannot capture logs");
    }
    const logger = Logger.getLoggerforIdentifier(fromLogger);
    const actualLogSettings = {
      logFormatter: logger.logFormatter,
      log: logger.log,
      defaultLogLevel: logger.defaultLogLevel,
      logLevels: { ...logger.logLevels }
    };
    try {
      Logger.setFormatForLogger(fromLogger, LogFormat.PLAIN);
      const captured = new Array();
      Logger.setLogger(
        fromLogger,
        (level, message) => captured.push({
          level,
          message: message.replace(/\d{4}-\d\d-\d\d \d\d:\d\d:\d\d\.\d\d\d/, "xxxx-xx-xx xx:xx:xx.xxx")
        })
      );
      fn();
      return captured;
    } finally {
      Logger.setLogFormatterForLogger(fromLogger, actualLogSettings.logFormatter);
      Logger.setDefaultLoglevelForLogger(fromLogger, actualLogSettings.defaultLogLevel);
      Logger.setLogLevelsForLogger(fromLogger, actualLogSettings.logLevels);
      Logger.setLogger(fromLogger, actualLogSettings.log);
    }
  }
  debug = (...values) => this.log(LogLevel.DEBUG, values);
  info = (...values) => this.log(LogLevel.INFO, values);
  notice = (...values) => this.log(LogLevel.NOTICE, values);
  warn = (...values) => this.log(LogLevel.WARN, values);
  error = (...values) => this.log(LogLevel.ERROR, values);
  fatal = (...values) => this.log(LogLevel.FATAL, values);
  log(level, values) {
    Logger.logger.forEach((logger) => {
      if (level < (logger.logLevels[this.name] ?? logger.defaultLogLevel)) return;
      logger.log(level, logger.logFormatter(Time.now(), level, this.name, nestingPrefix(), values));
    });
  }
}
function nestingPrefix() {
  if (Logger.nestingLevel) {
    return "\u23B8".padEnd(Logger.nestingLevel * 2);
  }
  return "";
}
Boot.init(() => {
  Logger.logger = new Array({
    logIdentifier: "default",
    logFormatter: LogFormat.plain,
    log: consoleLogger,
    defaultLogLevel: LogLevel.DEBUG,
    logLevels: {}
  });
  Logger.nestingLevel = 0;
  if (typeof MatterHooks !== "undefined") {
    MatterHooks.loggerSetup?.(Logger);
  }
});
export {
  Logger,
  consoleLogger
};
//# sourceMappingURL=Logger.js.map
