/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import * as mod from "@noble/curves/abstract/modular";
import * as utils from "@noble/curves/abstract/utils";
import { MatterError } from "../MatterError.js";
import { PrivateKey } from "./Key.js";
export declare const ec: {
    mod(a: bigint, b: bigint): bigint;
    pow(num: bigint, power: bigint, modulo: bigint): bigint;
    pow2(x: bigint, power: bigint, modulo: bigint): bigint;
    invert(number: bigint, modulo: bigint): bigint;
    tonelliShanks(P: bigint): <T>(Fp: mod.IField<T>, n: T) => T;
    FpSqrt(P: bigint): <T>(Fp: mod.IField<T>, n: T) => T;
    validateField<T>(field: mod.IField<T>): mod.IField<T>;
    FpPow<T>(f: mod.IField<T>, num: T, power: bigint): T;
    FpInvertBatch<T>(f: mod.IField<T>, nums: T[]): T[];
    FpDiv<T>(f: mod.IField<T>, lhs: T, rhs: T | bigint): T;
    FpLegendre(order: bigint): <T>(f: mod.IField<T>, x: T) => T;
    FpIsSquare<T>(f: mod.IField<T>): (x: T) => boolean;
    nLength(n: bigint, nBitLength?: number): {
        nBitLength: number;
        nByteLength: number;
    };
    Field(ORDER: bigint, bitLen?: number, isLE?: boolean, redef?: Partial<mod.IField<bigint>>): Readonly<mod.IField<bigint> & Required<Pick<mod.IField<bigint>, "isOdd">>>;
    FpSqrtOdd<T>(Fp: mod.IField<T>, elm: T): T;
    FpSqrtEven<T>(Fp: mod.IField<T>, elm: T): T;
    hashToPrivateScalar(hash: string | Uint8Array, groupOrder: bigint, isLE?: boolean): bigint;
    getFieldBytesLength(fieldOrder: bigint): number;
    getMinHashLength(fieldOrder: bigint): number;
    mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE?: boolean): Uint8Array;
    isNegativeLE: (num: bigint, modulo: bigint) => boolean;
    isBytes(a: unknown): a is Uint8Array;
    abytes(item: unknown): void;
    abool(title: string, value: boolean): void;
    bytesToHex(bytes: Uint8Array): string;
    numberToHexUnpadded(num: number | bigint): string;
    hexToNumber(hex: string): bigint;
    hexToBytes(hex: string): Uint8Array;
    bytesToNumberBE(bytes: Uint8Array): bigint;
    bytesToNumberLE(bytes: Uint8Array): bigint;
    numberToBytesBE(n: number | bigint, len: number): Uint8Array;
    numberToBytesLE(n: number | bigint, len: number): Uint8Array;
    numberToVarBytesBE(n: number | bigint): Uint8Array;
    ensureBytes(title: string, hex: utils.Hex, expectedLength?: number): Uint8Array;
    concatBytes(...arrays: Uint8Array[]): Uint8Array;
    equalBytes(a: Uint8Array, b: Uint8Array): boolean;
    utf8ToBytes(str: string): Uint8Array;
    inRange(n: bigint, min: bigint, max: bigint): boolean;
    aInRange(title: string, n: bigint, min: bigint, max: bigint): void;
    bitLen(n: bigint): number;
    bitGet(n: bigint, pos: number): bigint;
    bitSet(n: bigint, pos: number, value: boolean): bigint;
    createHmacDrbg<T>(hashLen: number, qByteLen: number, hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array): (seed: Uint8Array, predicate: (v: Uint8Array) => T | undefined) => T;
    validateObject<T extends Record<string, any>>(object: T, validators: { [K in keyof T]?: "string" | "bigint" | "boolean" | "function" | "hash" | "stringOrUint8Array" | "isSafeInteger" | "array" | "field" | undefined; }, optValidators?: { [K in keyof T]?: "string" | "bigint" | "boolean" | "function" | "hash" | "stringOrUint8Array" | "isSafeInteger" | "array" | "field" | undefined; }): T;
    memoized<T extends object, R, O extends any[]>(fn: (arg: T, ...args: O) => R): (arg: T, ...args: O) => R;
    bitMask: (n: number) => bigint;
    notImplemented: () => never;
    p256: Readonly<{
        create: (hash: import("@noble/curves/abstract/utils").CHash) => import("@noble/curves/abstract/weierstrass").CurveFn;
        CURVE: ReturnType<(curve: import("@noble/curves/abstract/weierstrass").CurveType) => Readonly<{
            readonly nBitLength: number;
            readonly nByteLength: number;
            readonly Fp: import("@noble/curves/abstract/modular").IField<bigint>;
            readonly n: bigint;
            readonly h: bigint;
            readonly hEff?: bigint;
            readonly Gx: bigint;
            readonly Gy: bigint;
            readonly allowInfinityPoint?: boolean;
            readonly a: bigint;
            readonly b: bigint;
            readonly allowedPrivateKeyLengths?: readonly number[];
            readonly wrapPrivateKey?: boolean;
            readonly endo?: {
                beta: bigint;
                splitScalar: (k: bigint) => {
                    k1neg: boolean;
                    k1: bigint;
                    k2neg: boolean;
                    k2: bigint;
                };
            };
            readonly isTorsionFree?: ((c: import("@noble/curves/abstract/weierstrass").ProjConstructor<bigint>, point: import("@noble/curves/abstract/weierstrass").ProjPointType<bigint>) => boolean) | undefined;
            readonly clearCofactor?: ((c: import("@noble/curves/abstract/weierstrass").ProjConstructor<bigint>, point: import("@noble/curves/abstract/weierstrass").ProjPointType<bigint>) => import("@noble/curves/abstract/weierstrass").ProjPointType<bigint>) | undefined;
            readonly hash: import("@noble/curves/abstract/utils").CHash;
            readonly hmac: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;
            readonly randomBytes: (bytesLength?: number) => Uint8Array;
            lowS: boolean;
            readonly bits2int?: (bytes: Uint8Array) => bigint;
            readonly bits2int_modN?: (bytes: Uint8Array) => bigint;
            readonly p: bigint;
        }>>;
        getPublicKey: (privateKey: import("@noble/curves/abstract/utils").PrivKey, isCompressed?: boolean) => Uint8Array;
        getSharedSecret: (privateA: import("@noble/curves/abstract/utils").PrivKey, publicB: import("@noble/curves/abstract/utils").Hex, isCompressed?: boolean) => Uint8Array;
        sign: (msgHash: import("@noble/curves/abstract/utils").Hex, privKey: import("@noble/curves/abstract/utils").PrivKey, opts?: import("@noble/curves/abstract/weierstrass").SignOpts) => import("@noble/curves/abstract/weierstrass").RecoveredSignatureType;
        verify: (signature: import("@noble/curves/abstract/utils").Hex | {
            r: bigint;
            s: bigint;
        }, msgHash: import("@noble/curves/abstract/utils").Hex, publicKey: import("@noble/curves/abstract/utils").Hex, opts?: import("@noble/curves/abstract/weierstrass").VerOpts) => boolean;
        ProjectivePoint: import("@noble/curves/abstract/weierstrass").ProjConstructor<bigint>;
        Signature: import("@noble/curves/abstract/weierstrass").SignatureConstructor;
        utils: {
            normPrivateKeyToScalar: (key: import("@noble/curves/abstract/utils").PrivKey) => bigint;
            isValidPrivateKey(privateKey: import("@noble/curves/abstract/utils").PrivKey): boolean;
            randomPrivateKey: () => Uint8Array;
            precompute: (windowSize?: number, point?: import("@noble/curves/abstract/weierstrass").ProjPointType<bigint>) => import("@noble/curves/abstract/weierstrass").ProjPointType<bigint>;
        };
    }>;
};
export declare const CRYPTO_RANDOM_LENGTH = 32;
export declare const CRYPTO_ENCRYPT_ALGORITHM = "aes-128-ccm";
export declare const CRYPTO_HASH_ALGORITHM = "sha256";
export declare const CRYPTO_EC_CURVE = "prime256v1";
export declare const CRYPTO_EC_KEY_BYTES = 32;
export declare const CRYPTO_AUTH_TAG_LENGTH = 16;
export declare const CRYPTO_SYMMETRIC_KEY_LENGTH = 16;
export type CryptoDsaEncoding = "ieee-p1363" | "der";
export declare class CryptoVerifyError extends MatterError {
}
export declare abstract class Crypto {
    static get: () => Crypto;
    abstract encrypt(key: Uint8Array, data: Uint8Array, nonce: Uint8Array, aad?: Uint8Array): Uint8Array;
    static readonly encrypt: (key: Uint8Array, data: Uint8Array, nonce: Uint8Array, aad?: Uint8Array) => Uint8Array;
    abstract decrypt(key: Uint8Array, data: Uint8Array, nonce: Uint8Array, aad?: Uint8Array): Uint8Array;
    static readonly decrypt: (key: Uint8Array, data: Uint8Array, nonce: Uint8Array, aad?: Uint8Array) => Uint8Array;
    abstract getRandomData(length: number): Uint8Array;
    static readonly getRandomData: (length: number) => Uint8Array;
    static readonly getRandom: () => Uint8Array;
    static readonly getRandomUInt16: () => number;
    static readonly getRandomUInt32: () => number;
    static readonly getRandomBigUInt64: () => bigint;
    static readonly getRandomBigInt: (size: number, maxValue?: bigint) => bigint;
    abstract ecdhGeneratePublicKey(): {
        publicKey: Uint8Array;
        ecdh: any;
    };
    static readonly ecdhGeneratePublicKey: () => {
        publicKey: Uint8Array;
        ecdh: any;
    };
    abstract ecdhGeneratePublicKeyAndSecret(peerPublicKey: Uint8Array): {
        publicKey: Uint8Array;
        sharedSecret: Uint8Array;
    };
    static readonly ecdhGeneratePublicKeyAndSecret: (peerPublicKey: Uint8Array) => {
        publicKey: Uint8Array;
        sharedSecret: Uint8Array;
    };
    abstract ecdhGenerateSecret(peerPublicKey: Uint8Array, ecdh: any): Uint8Array;
    static readonly ecdhGenerateSecret: (peerPublicKey: Uint8Array, ecdh: any) => Uint8Array;
    abstract hash(data: Uint8Array | Uint8Array[]): Uint8Array;
    static readonly hash: (data: Uint8Array | Uint8Array[]) => Uint8Array;
    abstract pbkdf2(secret: Uint8Array, salt: Uint8Array, iteration: number, keyLength: number): Promise<Uint8Array>;
    static readonly pbkdf2: (secret: Uint8Array, salt: Uint8Array, iteration: number, keyLength: number) => Promise<Uint8Array>;
    abstract hkdf(secret: Uint8Array, salt: Uint8Array, info: Uint8Array, length?: number): Promise<Uint8Array>;
    static readonly hkdf: (secret: Uint8Array, salt: Uint8Array, info: Uint8Array, length?: number) => Promise<Uint8Array>;
    abstract hmac(key: Uint8Array, data: Uint8Array): Uint8Array;
    static readonly hmac: (key: Uint8Array, data: Uint8Array) => Uint8Array;
    abstract sign(privateKey: JsonWebKey, data: Uint8Array | Uint8Array[], dsaEncoding?: CryptoDsaEncoding): Uint8Array;
    static readonly sign: (privateKey: JsonWebKey, data: Uint8Array | Uint8Array[], dsaEncoding?: CryptoDsaEncoding) => Uint8Array;
    abstract verify(publicKey: JsonWebKey, data: Uint8Array, signature: Uint8Array, dsaEncoding?: CryptoDsaEncoding): void;
    static readonly verify: (publicKey: JsonWebKey, data: Uint8Array, signature: Uint8Array, dsaEncoding?: CryptoDsaEncoding) => void;
    abstract createKeyPair(): PrivateKey;
    static readonly createKeyPair: () => PrivateKey;
}
//# sourceMappingURL=Crypto.d.ts.map