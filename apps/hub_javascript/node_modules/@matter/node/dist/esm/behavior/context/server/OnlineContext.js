/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Diagnostic, ImplementationError, InternalError, MaybePromise } from "#general";
import { assertSecureSession } from "#protocol";
import { AccessControlServer } from "../../../behaviors/access-control/AccessControlServer.js";
import { Transaction } from "../../state/transaction/Transaction.js";
import { Contextual } from "../Contextual.js";
import { ContextAgents } from "./ContextAgents.js";
function OnlineContext(options) {
  return {
    act(actor) {
      let agents;
      let fabric;
      let subject;
      const { exchange } = options;
      const session = exchange?.session;
      if (session) {
        assertSecureSession(session);
        fabric = session.fabric?.fabricIndex;
        subject = session.peerNodeId;
      } else {
        fabric = options.fabric;
        subject = options.subject;
      }
      if (subject === void 0) {
        throw new ImplementationError("OnlineContext requires an authorized subject");
      }
      const { message } = options;
      const via = Diagnostic.via(
        `online#${message?.packetHeader?.messageId?.toString(16) ?? "?"}@${subject.toString(16)}`
      );
      let context;
      let trace;
      let activity;
      if (options.tracer && options.actionType) {
        trace = {
          type: options.actionType
        };
      }
      const close = () => {
        if (trace) {
          options.tracer?.record(trace);
        }
        if (message) {
          Contextual.setContextOf(message, void 0);
        }
        if (activity) {
          activity[Symbol.dispose]();
        }
      };
      const actOnline = (transaction) => {
        context = {
          ...options,
          session,
          exchange,
          subject,
          fabric,
          transaction,
          trace,
          interactionComplete: exchange?.closed,
          authorizedFor(desiredAccessLevel, location) {
            if (location === void 0) {
              throw new InternalError("AccessControl.Location is required");
            }
            if (location.accessLevels !== void 0) {
              return location.accessLevels.includes(desiredAccessLevel);
            }
            if (options.root === void 0) {
              throw new InternalError("Root endpoint is required");
            }
            const accessControl = options.root.act((agent) => agent.get(AccessControlServer));
            if (MaybePromise.is(accessControl)) {
              throw new InternalError("AccessControlServer should already be initialized.");
            }
            const accessLevels = accessControl.accessLevelsFor(
              context,
              location,
              options.endpoint
            );
            location.accessLevels = accessLevels;
            return accessLevels.includes(desiredAccessLevel);
          },
          agentFor(endpoint) {
            if (!agents) {
              agents = ContextAgents(context);
            }
            return agents.agentFor(endpoint);
          },
          get [Contextual.context]() {
            return this;
          }
        };
        if (message) {
          Contextual.setContextOf(message, context);
        }
        return actor(context);
      };
      const traceError = (e) => {
        if (trace) {
          const status = e.code;
          if (typeof status === "number") {
            trace.status = status;
          }
        }
        throw e;
      };
      let isAsync = false;
      try {
        activity = options.activity?.frame(via);
        const result = Transaction.act(via, actOnline);
        if (MaybePromise.is(result)) {
          isAsync = true;
          return Promise.resolve(result).catch(traceError).finally(close);
        }
        return result;
      } catch (e) {
        traceError(e);
        throw e;
      } finally {
        if (!isAsync && context) {
          close();
        }
      }
    },
    [Symbol.toStringTag]: "OnlineContext"
  };
}
export {
  OnlineContext
};
//# sourceMappingURL=OnlineContext.js.map
