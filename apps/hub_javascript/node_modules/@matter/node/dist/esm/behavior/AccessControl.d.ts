/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AccessLevel, DataModelPath } from "#model";
import { ClusterId, FabricIndex, SubjectId } from "#types";
import { Schema } from "./supervision/Schema.js";
/**
 * Enforces access control for a specific schema.
 */
export interface AccessControl {
    /**
     * Operational access control metadata.
     */
    limits: AccessControl.Limits;
    /**
     * Assert read is authorized.
     */
    authorizeRead: AccessControl.Assertion;
    /**
     * Determine if read is authorized.
     */
    mayRead: AccessControl.Verification;
    /**
     * Assert write is authorized.
     */
    authorizeWrite: AccessControl.Assertion;
    /**
     * Determine if write is authorized.
     */
    mayWrite: AccessControl.Verification;
    /**
     * Assert invoke is authorized.
     */
    authorizeInvoke: AccessControl.Assertion;
    /**
     * Determine if invoke is authorized.
     */
    mayInvoke: AccessControl.Verification;
}
/**
 * Obtain an enforcer for specific schema.
 *
 * This is central to security.  Implementation is explicit, all objects are involved are frozen and cache is stored as
 * module-private.
 *
 * Pure function; returned value is cached.
 */
export declare function AccessControl(schema: Schema): AccessControl;
export declare namespace AccessControl {
    /**
     * Operational access control metadata for a schema.
     */
    interface Limits {
        readonly readable: boolean;
        readonly readLevel: AccessLevel;
        readonly writable: boolean;
        readonly writeLevel: AccessLevel;
        readonly fabricScoped: boolean;
        readonly fabricSensitive: boolean;
        readonly timed: boolean;
    }
    /**
     * A function that asserts access control requirements are met.
     */
    type Assertion = (session: Session, location: Location) => void;
    /**
     * A function that returns true if access control requirements are met.
     */
    type Verification = (session: Session, location: Location) => boolean;
    /**
     * Metadata that varies with position in the data model.
     */
    interface Location {
        /**
         * The diagnostic path to the location.
         */
        path: DataModelPath;
        /**
         * The owning behavior.
         */
        cluster?: ClusterId;
        /**
         * The fabric that owns the data subtree.  Undefined or {@link FabricIndex.NO_FABRIC} disables fabric
         * enforcement.
         */
        owningFabric?: FabricIndex;
        /**
         * The access levels already retrieved for this location. With this subtree elements can access the same
         * access levels without re-evaluating.
         */
        accessLevels?: AccessLevel[];
    }
    /**
     * Authorization metadata that varies with session.
     */
    interface Session {
        /**
         * Checks if the authorized client has a certain Access Privilege granted.
         */
        authorizedFor(desiredAccessLevel: AccessLevel, location?: Location): boolean;
        /**
         * The fabric of the authorized client.
         */
        readonly fabric?: FabricIndex;
        /**
         * The authenticated {@link SubjectId} for online sessions.
         */
        readonly subject?: SubjectId;
        /**
         * If this is true, fabric-scoped lists are filtered to the accessing
         * fabric.
         */
        readonly fabricFiltered?: boolean;
        /**
         * If this is true a timed transaction is in effect.
         */
        readonly timed?: boolean;
        /**
         * If this is true then data access levels are not enforced.  Datatypes and command-related access controls are
         * active.
         */
        readonly command?: boolean;
        /**
         * If this is true then access levels are not enforced and all values are read/write.  Datatypes are still
         * enforced.
         *
         * Tracks "offline" rather than "online" because this makes the safer mode (full enforcement) the default.
         */
        offline?: boolean;
    }
}
//# sourceMappingURL=AccessControl.d.ts.map