/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { OnOff } from "#clusters/on-off";
import { MaybePromise, Timer } from "#general";
declare const Base: import("../../index.js").ClusterBehavior.Type<import("@matter/types").ClusterComposer.WithFeatures<OnOff.Cluster, readonly [OnOff.Feature.Lighting]>, import("../../index.js").ClusterBehavior.Type<OnOff.Cluster, import("../../index.js").ClusterBehavior.Type<import("@matter/types").ClusterType.Of<{
    readonly id: 0;
    readonly revision: 0;
    readonly name: "Unknown";
    readonly attributes: {};
    readonly commands: {};
    readonly events: {};
}>, typeof import("../../index.js").ClusterBehavior, import("./OnOffInterface.js").OnOffInterface>, import("./OnOffInterface.js").OnOffInterface>, import("./OnOffInterface.js").OnOffInterface>;
/**
 * This is the default server implementation of {@link OnOffBehavior}.
 *
 * This implementation includes all features of {@link OnOff.Cluster} and automatically enables the "Level Control
 * for Lighting" Feature. You should use {@link OnOffServer.with} to specialize the class for the features your
 * implementation supports. Alternatively you can extend this class and override the methods you need to change or add
 * mandatory commands.
 *
 * The "OffOnly" feature is automatically supported because the commands are disabled by conformance.
 * The default implementation do not contain any logic for the DeadFrontBehavior feature because this is very use case
 * specific, so this needs to be implemented by the device implementor as needed.
 */
export declare class OnOffServer extends Base {
    #private;
    protected internal: OnOffServer.Internal;
    initialize(): void;
    [Symbol.asyncDispose](): Promise<void>;
    on(): MaybePromise<void>;
    off(): MaybePromise<void>;
    /**
     * Default implementation notes:
     * This method uses the on/off methods when timed actions should occur. This means that it is enough to override
     * on() and off() with custom control logic.
     */
    toggle(): MaybePromise<void>;
    /**
     * Default implementation notes:
     * * This implementation ignores the effect and just calls off().
     * * Global Scene Control is not supported yet.
     */
    offWithEffect(): MaybePromise<void>;
    /**
     * Default implementation notes:
     * * Global Scene Control is not supported yet, so the device is just turned on.
     */
    onWithRecallGlobalScene(): MaybePromise<void>;
    /**
     * Default implementation notes:
     * * This method uses the on/off methods when timed actions should occur. This means that it is enough to override
     * on() and off() with custom control logic.
     */
    onWithTimedOff({ onOffControl, offWaitTime, onTime }: OnOff.OnWithTimedOffRequest): MaybePromise<void>;
    protected get timedOnTimer(): Timer;
    protected get delayedOffTimer(): Timer;
}
export declare namespace OnOffServer {
    class Internal {
        timedOnTimer?: Timer;
        delayedOffTimer?: Timer;
    }
}
export {};
//# sourceMappingURL=OnOffServer.d.ts.map