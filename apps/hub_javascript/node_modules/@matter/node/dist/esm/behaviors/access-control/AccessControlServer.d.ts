/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AccessControl } from "#behavior/AccessControl.js";
import { ActionContext } from "#behavior/context/ActionContext.js";
import { AccessControl as AccessControlTypes } from "#clusters/access-control";
import { AccessLevel } from "#model";
import { AccessControlManager, EndpointInterface, IncomingSubjectDescriptor } from "#protocol";
import { ClusterId } from "#types";
import { AccessControlBehavior } from "./AccessControlBehavior.js";
/**
 * This is the default server implementation of AccessControlBehavior.
 */
export declare class AccessControlServer extends AccessControlBehavior {
    #private;
    internal: AccessControlServer.Internal;
    initialize(): void;
    /**
     * Implements the access control check for the given context, location and endpoint and is called by the
     * InteractionServer. The method returns the list of granted Access privileges for the given context, location and
     * endpoint.
     */
    accessLevelsFor(context: ActionContext, location: AccessControl.Location, endpoint?: EndpointInterface): AccessLevel[];
    /**
     * This method allows to implement the validation of manufacturer specific ACL extensions when an extension entry is
     * added or changed. The default implementation checks whether the extension is a valid TLV and possible to decode.
     *
     * In case of an Error throws StatusResponseError.
     *
     * Override this method in your own behavior to implement custom validation.
     */
    protected extensionEntryValidator(extension: AccessControlTypes.AccessControlExtension): void;
    /**
     * This method allows to implement the validation of manufacturer specific ACL extensions when access control is
     * checked to decide if access is allowed or not.
     * The default implementation always returns true. Override this method in your own behavior to implement custom
     * validation.
     */
    protected extensionEntryAccessCheck(_aclList: AccessControlTypes.AccessControlEntry[], _aclEntry: AccessControlTypes.AccessControlEntry, _subjectDesc: IncomingSubjectDescriptor, _endpoint: EndpointInterface, _clusterId: ClusterId): boolean;
    /**
     * The AccessControlManager instance that is used to manage the ACL for this behavior.
     */
    get aclManager(): AccessControlManager;
    resetDelayedAccessControlList(): void;
    /**
     * If set to true, the ACL will not be updated immediately when it changes, but only when the `aclUpdateDelayed`
     * property is set to false again.
     * This is a hack to prevent the ACL from updating while we are in the middle of a write transaction and will be
     * removed again once we somehow handle relevant sub transactions.
     */
    get aclUpdateDelayed(): boolean;
    /**
     * If set to true, the ACL will not be updated immediately when it changes, but only when the `aclUpdateDelayed`
     * property is set to false again.
     * This is a hack to prevent the ACL from updating while we are in the middle of a write transaction and will be
     * removed again once we somehow handle relevant sub transactions.
     */
    set aclUpdateDelayed(value: boolean);
}
export declare namespace AccessControlServer {
    class Internal {
        /** AccessControlManager instance that is used to manage the ACL checks for this device. */
        aclManager?: AccessControlManager;
        /** If set to true ACL updates are delayed while in a write transaction. More details see getter/setter above. */
        aclUpdateDelayed: boolean;
        /** Latest delayed data of acl */
        delayedAclData?: AccessControlTypes.AccessControlEntry[];
    }
}
//# sourceMappingURL=AccessControlServer.d.ts.map