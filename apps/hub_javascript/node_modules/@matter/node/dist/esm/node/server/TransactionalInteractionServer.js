var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __using = (stack, value, async) => {
  if (value != null) {
    if (typeof value !== "object" && typeof value !== "function") __typeError("Object expected");
    var dispose, inner;
    if (async) dispose = value[__knownSymbol("asyncDispose")];
    if (dispose === void 0) {
      dispose = value[__knownSymbol("dispose")];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") __typeError("Object not disposable");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    stack.push([async, dispose, value]);
  } else if (async) {
    stack.push([async]);
  }
  return value;
};
var __callDispose = (stack, error, hasError) => {
  var E = typeof SuppressedError === "function" ? SuppressedError : function(e, s, m, _) {
    return _ = Error(m), _.name = "SuppressedError", _.error = e, _.suppressed = s, _;
  };
  var fail = (e) => error = hasError ? new E(e, error, "An error was suppressed during disposal") : (hasError = true, e);
  var next = (it) => {
    while (it = stack.pop()) {
      try {
        var result = it[1] && it[1].call(it[2]);
        if (it[0]) return Promise.resolve(result).then(next, (e) => (fail(e), next()));
      } catch (e) {
        fail(e);
      }
    }
    if (hasError) throw error;
  };
  return next();
};
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ActionTracer } from "#behavior/context/ActionTracer.js";
import { NodeActivity } from "#behavior/context/NodeActivity.js";
import { OfflineContext } from "#behavior/context/server/OfflineContext.js";
import { OnlineContext } from "#behavior/context/server/OnlineContext.js";
import { AccessControlCluster } from "#clusters/access-control";
import { EndpointServer } from "#endpoint/EndpointServer.js";
import { EndpointLifecycle } from "#endpoint/properties/EndpointLifecycle.js";
import { Diagnostic, InternalError, Logger, MaybePromise } from "#general";
import {
  AccessDeniedError,
  ExchangeManager,
  InteractionEndpointStructure,
  InteractionServer,
  InteractionServerMessenger
} from "#protocol";
import { AccessControlServer } from "../../behaviors/access-control/AccessControlServer.js";
const logger = Logger.get("TransactionalInteractionServer");
const activityKey = Symbol("activity");
const AclClusterId = AccessControlCluster.id;
const AclAttributeId = AccessControlCluster.attributes.acl.id;
class TransactionalInteractionServer extends InteractionServer {
  #endpointStructure;
  #changeListener;
  #endpoint;
  #activity;
  #newActivityBlocked = false;
  #aclServer;
  #aclUpdateIsDelayedInExchange = /* @__PURE__ */ new Set();
  static async create(endpoint, sessions) {
    const structure = new InteractionEndpointStructure();
    return new TransactionalInteractionServer(endpoint, {
      sessions,
      structure,
      subscriptionOptions: endpoint.state.network.subscriptionOptions,
      maxPathsPerInvoke: endpoint.state.basicInformation.maxPathsPerInvoke,
      initiateExchange: (address, protocolId) => endpoint.env.get(ExchangeManager).initiateExchange(address, protocolId)
    });
  }
  constructor(endpoint, context) {
    super(context);
    const { structure } = context;
    this.#activity = endpoint.env.get(NodeActivity);
    this.#endpoint = endpoint;
    this.#endpointStructure = structure;
    this.#updateStructure();
    this.#changeListener = (type) => {
      switch (type) {
        case EndpointLifecycle.Change.PartsReady:
        case EndpointLifecycle.Change.ClientsChanged:
        case EndpointLifecycle.Change.ServersChanged:
        case EndpointLifecycle.Change.Destroyed:
          this.#updateStructure();
          break;
      }
    };
    endpoint.lifecycle.changed.on(this.#changeListener);
  }
  async [Symbol.asyncDispose]() {
    this.#endpoint.lifecycle.changed.off(this.#changeListener);
    await this.close();
    this.#endpointStructure.close();
  }
  blockNewActivity() {
    this.#newActivityBlocked = true;
  }
  async onNewExchange(exchange) {
    var _stack = [];
    try {
      if (this.#newActivityBlocked || this.isClosing) {
        return;
      }
      const activity = __using(_stack, this.#activity.begin(`session#${exchange.session.id.toString(16)}`));
      exchange[activityKey] = activity;
      return new InteractionServerMessenger(exchange).handleRequest(this).finally(() => delete exchange[activityKey]);
    } catch (_) {
      var _error = _, _hasError = true;
    } finally {
      __callDispose(_stack, _error, _hasError);
    }
  }
  get aclServer() {
    if (this.#aclServer !== void 0) {
      return this.#aclServer;
    }
    const aclServer = this.#endpoint.act((agent) => agent.get(AccessControlServer));
    if (MaybePromise.is(aclServer)) {
      throw new InternalError("AccessControlServer should already be initialized.");
    }
    return this.#aclServer = aclServer;
  }
  async readAttribute(path, attribute, exchange, fabricFiltered, message, endpoint, offline = false) {
    const readAttribute = () => super.readAttribute(path, attribute, exchange, fabricFiltered, message, endpoint, offline);
    if (offline) {
      return OfflineContext.act("offline-read", this.#activity, readAttribute);
    }
    return OnlineContext({
      activity: exchange[activityKey],
      fabricFiltered,
      message,
      exchange,
      tracer: this.#tracer,
      actionType: ActionTracer.ActionType.Read,
      endpoint,
      root: this.#endpoint
    }).act(readAttribute);
  }
  async readEvent(path, eventFilters, event, exchange, fabricFiltered, message, endpoint) {
    const readEvent = (context) => {
      if (!context.authorizedFor(event.readAcl, { cluster: path.clusterId })) {
        throw new AccessDeniedError(
          `Access to ${endpoint.number}/${Diagnostic.hex(path.clusterId)} denied on ${exchange.session.name}.`
        );
      }
      return super.readEvent(path, eventFilters, event, exchange, fabricFiltered, message, endpoint);
    };
    return OnlineContext({
      activity: exchange[activityKey],
      fabricFiltered,
      message,
      exchange,
      tracer: this.#tracer,
      actionType: ActionTracer.ActionType.Read,
      endpoint,
      root: this.#endpoint
    }).act(readEvent);
  }
  async handleWriteRequest(exchange, writeRequest, message) {
    let result;
    try {
      result = await super.handleWriteRequest(exchange, writeRequest, message);
    } catch (error) {
      if (this.#aclUpdateIsDelayedInExchange.has(exchange)) {
        this.#aclUpdateIsDelayedInExchange.delete(exchange);
        if (this.#aclUpdateIsDelayedInExchange.size === 0) {
          this.aclServer.resetDelayedAccessControlList();
        } else {
          logger.error("One of multiple concurrent ACL writes failed, unhandled case for now.");
        }
      }
      throw error;
    }
    if (this.#aclUpdateIsDelayedInExchange.has(exchange)) {
      this.#aclUpdateIsDelayedInExchange.delete(exchange);
      if (this.#aclUpdateIsDelayedInExchange.size === 0) {
        this.aclServer.aclUpdateDelayed = false;
      } else {
        logger.info("Multiple concurrent ACL writes, waiting for all to finish.");
      }
    }
    return result;
  }
  async writeAttribute(path, attribute, value, exchange, message, endpoint, timed = false, isListWrite) {
    const writeAttribute = () => super.writeAttribute(path, attribute, value, exchange, message, endpoint, timed, isListWrite);
    if (path.endpointId === 0 && path.clusterId === AclClusterId && path.attributeId === AclAttributeId) {
      this.aclServer.aclUpdateDelayed = true;
      this.#aclUpdateIsDelayedInExchange.add(exchange);
    } else {
      if (this.#aclUpdateIsDelayedInExchange.has(exchange)) {
        this.#aclUpdateIsDelayedInExchange.delete(exchange);
        if (this.#aclUpdateIsDelayedInExchange.size === 0) {
          this.aclServer.aclUpdateDelayed = false;
        } else {
          logger.info("Multiple concurrent ACL writes, waiting for all to finish.");
        }
      }
    }
    return OnlineContext({
      activity: exchange[activityKey],
      timed,
      message,
      exchange,
      fabricFiltered: true,
      tracer: this.#tracer,
      actionType: ActionTracer.ActionType.Write,
      endpoint,
      root: this.#endpoint
    }).act(writeAttribute);
  }
  async invokeCommand(path, command, exchange, commandFields, message, endpoint, timed = false) {
    const invokeCommand = (context) => {
      if (!context.authorizedFor(command.invokeAcl, { cluster: path.clusterId })) {
        throw new AccessDeniedError(
          `Access to ${endpoint.number}/${Diagnostic.hex(path.clusterId)} denied on ${exchange.session.name}.`
        );
      }
      return super.invokeCommand(path, command, exchange, commandFields, message, endpoint, timed);
    };
    return OnlineContext({
      activity: exchange[activityKey],
      command: true,
      timed,
      message,
      exchange,
      tracer: this.#tracer,
      actionType: ActionTracer.ActionType.Invoke,
      endpoint,
      root: this.#endpoint
    }).act(invokeCommand);
  }
  get #tracer() {
    if (this.#endpoint.env.has(ActionTracer)) {
      return this.#endpoint.env.get(ActionTracer);
    }
  }
  #updateStructure() {
    if (this.#endpoint.lifecycle.isPartsReady) {
      this.#endpointStructure.initializeFromEndpoint(EndpointServer.forEndpoint(this.#endpoint));
    }
  }
}
export {
  TransactionalInteractionServer
};
//# sourceMappingURL=TransactionalInteractionServer.js.map
