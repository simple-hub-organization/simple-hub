"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var OnlineContext_exports = {};
__export(OnlineContext_exports, {
  OnlineContext: () => OnlineContext
});
module.exports = __toCommonJS(OnlineContext_exports);
var import_general = require("#general");
var import_protocol = require("#protocol");
var import_AccessControlServer = require("../../../behaviors/access-control/AccessControlServer.js");
var import_Transaction = require("../../state/transaction/Transaction.js");
var import_Contextual = require("../Contextual.js");
var import_ContextAgents = require("./ContextAgents.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function OnlineContext(options) {
  return {
    act(actor) {
      let agents;
      let fabric;
      let subject;
      const { exchange } = options;
      const session = exchange?.session;
      if (session) {
        (0, import_protocol.assertSecureSession)(session);
        fabric = session.fabric?.fabricIndex;
        subject = session.peerNodeId;
      } else {
        fabric = options.fabric;
        subject = options.subject;
      }
      if (subject === void 0) {
        throw new import_general.ImplementationError("OnlineContext requires an authorized subject");
      }
      const { message } = options;
      const via = import_general.Diagnostic.via(
        `online#${message?.packetHeader?.messageId?.toString(16) ?? "?"}@${subject.toString(16)}`
      );
      let context;
      let trace;
      let activity;
      if (options.tracer && options.actionType) {
        trace = {
          type: options.actionType
        };
      }
      const close = () => {
        if (trace) {
          options.tracer?.record(trace);
        }
        if (message) {
          import_Contextual.Contextual.setContextOf(message, void 0);
        }
        if (activity) {
          activity[Symbol.dispose]();
        }
      };
      const actOnline = (transaction) => {
        context = {
          ...options,
          session,
          exchange,
          subject,
          fabric,
          transaction,
          trace,
          interactionComplete: exchange?.closed,
          authorizedFor(desiredAccessLevel, location) {
            if (location === void 0) {
              throw new import_general.InternalError("AccessControl.Location is required");
            }
            if (location.accessLevels !== void 0) {
              return location.accessLevels.includes(desiredAccessLevel);
            }
            if (options.root === void 0) {
              throw new import_general.InternalError("Root endpoint is required");
            }
            const accessControl = options.root.act((agent) => agent.get(import_AccessControlServer.AccessControlServer));
            if (import_general.MaybePromise.is(accessControl)) {
              throw new import_general.InternalError("AccessControlServer should already be initialized.");
            }
            const accessLevels = accessControl.accessLevelsFor(
              context,
              location,
              options.endpoint
            );
            location.accessLevels = accessLevels;
            return accessLevels.includes(desiredAccessLevel);
          },
          agentFor(endpoint) {
            if (!agents) {
              agents = (0, import_ContextAgents.ContextAgents)(context);
            }
            return agents.agentFor(endpoint);
          },
          get [import_Contextual.Contextual.context]() {
            return this;
          }
        };
        if (message) {
          import_Contextual.Contextual.setContextOf(message, context);
        }
        return actor(context);
      };
      const traceError = (e) => {
        if (trace) {
          const status = e.code;
          if (typeof status === "number") {
            trace.status = status;
          }
        }
        throw e;
      };
      let isAsync = false;
      try {
        activity = options.activity?.frame(via);
        const result = import_Transaction.Transaction.act(via, actOnline);
        if (import_general.MaybePromise.is(result)) {
          isAsync = true;
          return Promise.resolve(result).catch(traceError).finally(close);
        }
        return result;
      } catch (e) {
        traceError(e);
        throw e;
      } finally {
        if (!isAsync && context) {
          close();
        }
      }
    },
    [Symbol.toStringTag]: "OnlineContext"
  };
}
//# sourceMappingURL=OnlineContext.js.map
