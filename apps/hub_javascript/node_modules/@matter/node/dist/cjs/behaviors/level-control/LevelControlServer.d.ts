/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { LevelControl } from "#clusters/level-control";
import { MaybePromise, Timer } from "#general";
import { TypeFromPartialBitSchema } from "#types";
declare const LevelControlLogicBase: import("../../index.js").ClusterBehavior.Type<import("#types").ClusterComposer.WithFeatures<LevelControl.Cluster, readonly [LevelControl.Feature.OnOff, LevelControl.Feature.Lighting]>, import("../../index.js").ClusterBehavior.Type<LevelControl.Cluster, import("../../index.js").ClusterBehavior.Type<import("#types").ClusterType.Of<{
    readonly id: 0;
    readonly revision: 0;
    readonly name: "Unknown";
    readonly attributes: {};
    readonly commands: {};
    readonly events: {};
}>, typeof import("../../index.js").ClusterBehavior, import("./LevelControlInterface.js").LevelControlInterface>, import("./LevelControlInterface.js").LevelControlInterface>, import("./LevelControlInterface.js").LevelControlInterface>;
/**
 * This is the default server implementation of {@link LevelControlBehavior}.
 *
 * This implementation includes all features of {@link LevelControl.Cluster} and implements all mandatory commands. The
 * On-Off Feature is automatically turned on as defined by the matter specification.
 * You should use {@link LevelControlServer.with} to specialize the class for the features your implementation supports.
 *
 * This default implementation also handles the OnOff cluster dependency and the ColorControl dependency as defined by
 * the Matter specification automatically.
 *
 * This implementation ignores by default all transition times and sets the level immediately. Alternatively, you can
 * set the `managedTransitionTimeHandling` state attribute to true to have matter.js manage transition times by
 * changing the level value step-wise every second. This might be an intermediate solution if you develop
 * independently of defined hardware.
 *
 * If you develop for a specific hardware you should extend the {@link LevelControlServer} class and implement the
 * following methods to natively use device features to correctly support the transition times. For this the default
 * implementation uses special protected methods which are used by the real commands and are only responsible for the
 * actual value change logic. The benefit of this structure is that basic data validations and options checks are
 * already done, and you can focus on the actual hardware interaction:
 * * {@link LevelControlServerLogic.moveToLevelLogic} Logic to move the value to a defined level with a transition time
 * * {@link LevelControlServerLogic.moveLogic} Logic to move the value up or down with a defined rate
 * * {@link LevelControlServerLogic.stepLogic} Logic to step the value up or down with a defined step size and transition
 * * {@link LevelControlServerLogic.stopLogic} Logic to stop any currently running transitions
 * * {@link LevelControlServerLogic.handleOnOffChange} Logic to handle dimming to onLevel when device got turned on by connected OnOff cluster
 *
 * If you add own implementation you can use:
 * * {@link LevelControlServerLogic.setLevel} to set the level attribute including automatic handling of the onoff dependency
 * * {@link LevelControlServerLogic.setRemainingTime} to set the remaining time attribute when Lighting feature is enabled
 *
 * All overridable methods except setRemainingTime can be implemented sync or async by returning a Promise.
 */
export declare class LevelControlServerLogic extends LevelControlLogicBase {
    #private;
    protected internal: LevelControlServerLogic.Internal;
    state: LevelControlServerLogic.State;
    /** Returns the minimum level, including feature specific fallback value handling. */
    get minLevel(): number;
    /** Returns the maximum level, including feature specific fallback value handling. */
    get maxLevel(): number;
    /**
     * The current level value as number.
     * Throws an StatusResponse Error when null!
     */
    get currentLevel(): number;
    initialize(): void;
    /**
     * Default implementation notes:
     * This method ignores the transition time provided by the command or settings and just sets the level to the
     * requested value. After the options and value checks it uses the {@link moveToLevelLogic} method to set the level.
     * If you want to implement own logic just override {@link moveToLevelLogic} with is also used for {@link moveToLevelWithOnOff}.
     */
    moveToLevel({ level, transitionTime, optionsMask, optionsOverride }: LevelControl.MoveToLevelRequest): MaybePromise<void>;
    /**
     * Default implementation notes:
     * This method ignores the transition time provided by the command or settings and just sets the level to the
     * requested value. After the options and value checks it uses the {@link moveToLevelLogic} method to set the level.
     * If you want to implement own logic just override {@link moveToLevelLogic} with is also used for {@link moveToLevel}.
     */
    moveToLevelWithOnOff({ level, transitionTime }: LevelControl.MoveToLevelRequest): MaybePromise<void>;
    /**
     * Default implementation of the moveToLevel logic. When a transition time is specified the implementation uses a
     * step based logic to manage the move. It also checks if the level is within the min and max level range and sets
     * the level accordingly. The method uses {@link setLevel} to set the level and handle the on/off state if the method
     * is called by a *WithOnOff command.
     *
     * @param level Level to set
     * @param transitionTime Transition time, ignored in this default implementation
     * @param withOnOff true if the method is called by a *WithOnOff command
     * @param options Options for the command
     * @protected
     */
    protected moveToLevelLogic(level: number, transitionTime: number | null, withOnOff: boolean, options?: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise<void>;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link moveLogic} method to set the level.
     * If you want to implement own logic just override {@link moveLogic} with is also used for {@link moveWithOnOff}.
     * The logic is implemented as follows: When no move rate is provided and also no default move rate is set, the
     * server will move as fast as possible, so we set to min/max directly. Else the step logic is applied and the
     * level is increased or decreased by the step size every second.
     */
    move({ moveMode, rate, optionsMask, optionsOverride }: LevelControl.MoveRequest): MaybePromise<void>;
    /**
     * Default implementation notes:
     * This implementation uses the {@link moveLogic} method to set the level.
     * If you want to implement own logic just override {@link moveLogic} with is also used for {@link move}.
     * The logic is implemented as follows: When no move rate is provided and also no default move rate is set, the
     * server will move as fast as possible, so we set to min/max directly. Else the step logic is applied and the
     * level is increased or decreased by the step size every second.
     */
    moveWithOnOff({ moveMode, rate }: LevelControl.MoveRequest): MaybePromise<void>;
    /**
     * Default implementation of the move logic. When no move rate is provided and also no default move rate is set, the
     * server will move as fast as possible, so it is set to min/max directly. Else the step logic is applied and the
     * level is increased or decreased by the step size every second. The method uses {@link setLevel} to set the level
     * and handle the on/off state if the method is called by a *WithOnOff command.
     *
     * @param moveMode Mode (Up/Down) of the move action
     * @param rate Rate of the move action, null if no rate is provided and the default should be used
     * @param withOnOff true if the method is called by a *WithOnOff command
     * @param options Options for the command
     * @protected
     */
    protected moveLogic(moveMode: LevelControl.MoveMode, rate: number | null, withOnOff: boolean, options?: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise<void>;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link stepLogic} method to set the level.
     * If you want to implement own logic just override {@link stepLogic} with is also used for {@link stepWithOnOff}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set to currentlevel +/- stepSize directly. Else the step logic is applied and the level is
     * increased or decreased by the step size every transition time interval.
     */
    step({ stepMode, stepSize, transitionTime, optionsMask, optionsOverride }: LevelControl.StepRequest): MaybePromise<void>;
    /**
     * Default implementation notes:
     * This implementation uses the {@link stepLogic} method to set the level.
     * If you want to implement own logic just override {@link stepLogic} with is also used for {@link step}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set to min/max directly. Else the step logic is applied and the level is increased or decreased
     * by the step size every transition time interval.
     */
    stepWithOnOff({ stepMode, stepSize, transitionTime }: LevelControl.StepRequest): MaybePromise<void>;
    /**
     * Default implementation of the step logic. When no transition time is provided, the server will move as fast as
     * possible, so it is set to min/max directly. Else the level is increased or decreased by the step size every
     * second. The method uses {@link setLevel} to set the level and handle the on/off state if the method is called
     * by a *WithOnOff command. The remaining time is updated with every step.
     *
     * @param stepMode Mode (Up/Down) of the step action
     * @param stepSize Size of the step action
     * @param transitionTime Time of the step action in 10th of a second
     * @param withOnOff true if the method is called by a *WithOnOff command
     * @param options Options for the command
     * @protected
     */
    protected stepLogic(stepMode: LevelControl.StepMode, stepSize: number, transitionTime: number | null, withOnOff: boolean, options?: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise<void>;
    stop({ optionsMask, optionsOverride }: LevelControl.StopRequest): MaybePromise<void>;
    stopWithOnOff(request: LevelControl.StopRequest): MaybePromise<void>;
    /**
     * Default implementation of the stop logic. This stops any level transitions currently appening and sets the
     * remaining time to 0.
     *
     * @protected
     */
    protected stopLogic(_options?: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise<void>;
    /**
     * Method to set the remaining time attribute when Lighting feature is enabled.
     *
     * @param remainingTime Remaining time in 1/10th of a second
     * @protected
     */
    protected setRemainingTime(remainingTime: number): void;
    /**
     * Default implementation of the logic to set the level including the handing of the on/off state when one of the
     * *WithOnOff commands is called. This implementation checks if the level is at the minLevel and the device is on,
     * it will turn off the device. If the level is above the minLevel and the device is off, it will turn on the device.
     *
     * @param level Level which is set by the command
     * @param withOnOff true if the method is called by a *WithOnOff command
     * @param options Options for the command
     * @protected
     */
    protected setLevel(level: number, withOnOff: boolean, options?: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise<void>;
    /**
     * This is the default implementation of the required interaction with the OnOff cluster on the same endpoint when
     * the onOff feature is used.
     * This implementation just sets the current level to the onLevel value when the device is turned on. Other fading
     * up/down logic required by the {@link MatterSpecification.v12.Cluster} §1.6.4.1.1 needs to be implemented in a
     * specialized class if needed.
     *
     * @param onOff The new onOff state
     * @protected
     */
    protected handleOnOffChange(onOff: boolean): void;
    [Symbol.asyncDispose](): Promise<void>;
}
export declare namespace LevelControlServerLogic {
    class Internal {
        /** Timer for the managed transition */
        transitionIntervalTimer?: Timer;
        /** Structure to store the data of the current managed transition */
        currentTransitionData?: {
            changeRate: number;
            withOnOff: boolean;
            targetLevel?: number;
            options?: TypeFromPartialBitSchema<typeof LevelControl.Options>;
        };
    }
    class State extends LevelControlLogicBase.State {
        /**
         * The default implementation always set the target level immediately and so ignores all transition times
         * requested or configured.
         * Set this to true to manage transition times by changing the level value step wise every second. This is in
         * most cases not the best way because hardware supporting levels usually have ways to specify the change rate
         * or target value and transition time.
         */
        managedTransitionTimeHandling: boolean;
    }
    const ExtensionInterface: {
        moveToLevelLogic(level: number, transitionTime: number | null, withOnOff: boolean, options: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise<void>;
        moveLogic(moveMode: LevelControl.MoveMode, rate: number | null, withOnOff: boolean, options: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise<void>;
        stepLogic(stepMode: LevelControl.StepMode, stepSize: number, transitionTime: number | null, withOnOff: boolean, options: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise<void>;
        stopLogic(options: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise<void>;
        setLevel(level: number, withOnOff: boolean, options: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise<void>;
        setRemainingTime(remainingTime: number): void;
        handleOnOffChange(onOff: boolean): void;
    };
}
declare const LevelControlServer_base: import("../../index.js").ClusterBehavior.Type<import("#types").ClusterComposer.WithFeatures<import("#types").ClusterComposer.WithFeatures<LevelControl.Cluster, readonly [LevelControl.Feature.OnOff, LevelControl.Feature.Lighting]>, readonly [LevelControl.Feature.OnOff]>, typeof LevelControlServerLogic, import("./LevelControlInterface.js").LevelControlInterface>;
export declare class LevelControlServer extends LevelControlServer_base {
}
export {};
//# sourceMappingURL=LevelControlServer.d.ts.map