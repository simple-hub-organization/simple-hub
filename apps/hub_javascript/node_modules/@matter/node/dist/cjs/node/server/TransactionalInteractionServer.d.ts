/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Endpoint } from "#endpoint/Endpoint.js";
import { AnyAttributeServer, AnyEventServer, AttributePath, AttributeServer, CommandPath, CommandServer, EndpointInterface, EventPath, EventStorageData, InteractionContext, InteractionServer, Message, MessageExchange, SessionManager, WriteRequest, WriteResponse } from "#protocol";
import { TlvEventFilter, TypeFromSchema } from "#types";
import { AccessControlServer } from "../../behaviors/access-control/AccessControlServer.js";
import { ServerNode } from "../ServerNode.js";
/**
 * Wire up an InteractionServer that initializes an InvocationContext earlier than the cluster API supports.
 *
 * This is necessary for attributes because the ClusterServer attribute APIs are synchronous while transaction
 * management is asynchronous.
 *
 * It's not necessary for command handling because that API is entirely async.  We do it here, however, just for the
 * sake of consistency.
 *
 * This could be integrated directly into InteractionServer but this further refactoring is probably warranted there
 * regardless.  This keeps the touch light for now.
 */
export declare class TransactionalInteractionServer extends InteractionServer {
    #private;
    static create(endpoint: Endpoint<ServerNode.RootEndpoint>, sessions: SessionManager): Promise<TransactionalInteractionServer>;
    constructor(endpoint: Endpoint<ServerNode.RootEndpoint>, context: InteractionContext);
    [Symbol.asyncDispose](): Promise<void>;
    blockNewActivity(): void;
    onNewExchange(exchange: MessageExchange): Promise<void>;
    get aclServer(): AccessControlServer;
    protected readAttribute(path: AttributePath, attribute: AnyAttributeServer<any>, exchange: MessageExchange, fabricFiltered: boolean, message: Message, endpoint: EndpointInterface, offline?: boolean): Promise<{
        version: number;
        value: any;
    }>;
    protected readEvent(path: EventPath, eventFilters: TypeFromSchema<typeof TlvEventFilter>[] | undefined, event: AnyEventServer<any, any>, exchange: MessageExchange, fabricFiltered: boolean, message: Message, endpoint: EndpointInterface): Promise<EventStorageData<any>[]>;
    handleWriteRequest(exchange: MessageExchange, writeRequest: WriteRequest, message: Message): Promise<WriteResponse>;
    protected writeAttribute(path: AttributePath, attribute: AttributeServer<any>, value: any, exchange: MessageExchange, message: Message, endpoint: EndpointInterface, timed?: boolean, isListWrite?: boolean): Promise<void>;
    protected invokeCommand(path: CommandPath, command: CommandServer<any, any>, exchange: MessageExchange, commandFields: any, message: Message, endpoint: EndpointInterface, timed?: boolean): Promise<{
        code: import("#types").StatusCode;
        clusterCode?: number;
        responseId: import("#types").CommandId;
        response: import("#types").TlvStream;
    }>;
}
//# sourceMappingURL=TransactionalInteractionServer.d.ts.map