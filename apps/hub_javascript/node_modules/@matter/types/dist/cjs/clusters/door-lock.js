"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var door_lock_exports = {};
__export(door_lock_exports, {
  DoorLock: () => DoorLock,
  DoorLockCluster: () => DoorLockCluster
});
module.exports = __toCommonJS(door_lock_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvNullable = require("../tlv/TlvNullable.js");
var import_model = require("#model");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_TlvBoolean = require("../tlv/TlvBoolean.js");
var import_TlvString = require("../tlv/TlvString.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_TlvArray = require("../tlv/TlvArray.js");
var import_FabricIndex = require("../datatype/FabricIndex.js");
var import_NodeId = require("../datatype/NodeId.js");
var import_TlvNoArguments = require("../tlv/TlvNoArguments.js");
var import_ClusterType = require("../cluster/ClusterType.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var DoorLock;
((DoorLock2) => {
  let Feature;
  ((Feature2) => {
    Feature2["PinCredential"] = "PinCredential";
    Feature2["RfidCredential"] = "RfidCredential";
    Feature2["FingerCredentials"] = "FingerCredentials";
    Feature2["Logging"] = "Logging";
    Feature2["WeekDayAccessSchedules"] = "WeekDayAccessSchedules";
    Feature2["DoorPositionSensor"] = "DoorPositionSensor";
    Feature2["FaceCredentials"] = "FaceCredentials";
    Feature2["CredentialOverTheAirAccess"] = "CredentialOverTheAirAccess";
    Feature2["User"] = "User";
    Feature2["Notification"] = "Notification";
    Feature2["YearDayAccessSchedules"] = "YearDayAccessSchedules";
    Feature2["HolidaySchedules"] = "HolidaySchedules";
    Feature2["Unbolting"] = "Unbolting";
  })(Feature = DoorLock2.Feature || (DoorLock2.Feature = {}));
  let DoorState;
  ((DoorState2) => {
    DoorState2[DoorState2["DoorOpen"] = 0] = "DoorOpen";
    DoorState2[DoorState2["DoorClosed"] = 1] = "DoorClosed";
    DoorState2[DoorState2["DoorJammed"] = 2] = "DoorJammed";
    DoorState2[DoorState2["DoorForcedOpen"] = 3] = "DoorForcedOpen";
    DoorState2[DoorState2["DoorUnspecifiedError"] = 4] = "DoorUnspecifiedError";
    DoorState2[DoorState2["DoorAjar"] = 5] = "DoorAjar";
  })(DoorState = DoorLock2.DoorState || (DoorLock2.DoorState = {}));
  DoorLock2.TlvDoorStateChangeEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the new door state for this door event.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.2.1
     */
    doorState: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)())
  });
  DoorLock2.TlvGetLogRecordRequest = (0, import_TlvObject.TlvObject)({ logIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16) });
  let EventType;
  ((EventType2) => {
    EventType2[EventType2["Operation"] = 0] = "Operation";
    EventType2[EventType2["Programming"] = 1] = "Programming";
    EventType2[EventType2["Alarm"] = 2] = "Alarm";
  })(EventType = DoorLock2.EventType || (DoorLock2.EventType = {}));
  let EventSource;
  ((EventSource2) => {
    EventSource2[EventSource2["Keypad"] = 0] = "Keypad";
    EventSource2[EventSource2["Remote"] = 1] = "Remote";
    EventSource2[EventSource2["Manual"] = 2] = "Manual";
    EventSource2[EventSource2["Rfid"] = 3] = "Rfid";
    EventSource2[EventSource2["Indeterminate"] = 255] = "Indeterminate";
  })(EventSource = DoorLock2.EventSource || (DoorLock2.EventSource = {}));
  DoorLock2.TlvGetLogRecordResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the index into the log table where this log entry is stored. If the log entry
     * requested is 0, the most recent log is returned with the appropriate log entry ID.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.5.1
     */
    logEntryId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
    /**
     * This field shall indicate the timestamp for all events and alarms on the door lock in Epoch Time in Seconds
     * with local time offset based on the local timezone and DST offset on the day of the event.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.5.2
     */
    timestamp: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvEpochS),
    /**
     * This field shall indicate the type of event that took place on the door lock, as defined in EventTypeEnum.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.5.3
     */
    eventType: (0, import_TlvObject.TlvField)(2, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the source value as defined in EventSourceEnum.
     *
     * If the EventType is 2 (Alarm) then the source SHOULD be, but does not have to be 255 (Indeterminate).
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.5.4
     */
    source: (0, import_TlvObject.TlvField)(3, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the type of event that took place on the door lock depending on the event code
     * table provided for a given event type and source. See Operation Event Codes.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.5.5
     */
    eventId: (0, import_TlvObject.TlvField)(4, import_TlvNumber.TlvUInt8),
    /**
     * This field shall indicate the ID of the user who generated the event on the door lock if one is available.
     * Otherwise, the value is 0xFFFF.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.5.6
     */
    userId: (0, import_TlvObject.TlvField)(5, import_TlvNumber.TlvUInt16),
    /**
     * This field shall indicate the PIN code or RFID code that was used to create the event on the door lock if
     * one is available.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.5.7
     */
    pin: (0, import_TlvObject.TlvField)(6, import_TlvString.TlvByteString)
  });
  DoorLock2.CredentialRules = {
    /**
     * Only one credential is required for lock operation
     */
    single: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * Any two credentials are required for lock operation
     */
    dual: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * Any three credentials are required for lock operation
     */
    tri: (0, import_BitmapSchema.BitFlag)(2)
  };
  let DataOperationType;
  ((DataOperationType2) => {
    DataOperationType2[DataOperationType2["Add"] = 0] = "Add";
    DataOperationType2[DataOperationType2["Clear"] = 1] = "Clear";
    DataOperationType2[DataOperationType2["Modify"] = 2] = "Modify";
  })(DataOperationType = DoorLock2.DataOperationType || (DoorLock2.DataOperationType = {}));
  let UserStatus;
  ((UserStatus2) => {
    UserStatus2[UserStatus2["Available"] = 0] = "Available";
    UserStatus2[UserStatus2["OccupiedEnabled"] = 1] = "OccupiedEnabled";
    UserStatus2[UserStatus2["OccupiedDisabled"] = 3] = "OccupiedDisabled";
  })(UserStatus = DoorLock2.UserStatus || (DoorLock2.UserStatus = {}));
  let UserType;
  ((UserType2) => {
    UserType2[UserType2["UnrestrictedUser"] = 0] = "UnrestrictedUser";
    UserType2[UserType2["YearDayScheduleUser"] = 1] = "YearDayScheduleUser";
    UserType2[UserType2["WeekDayScheduleUser"] = 2] = "WeekDayScheduleUser";
    UserType2[UserType2["ProgrammingUser"] = 3] = "ProgrammingUser";
    UserType2[UserType2["NonAccessUser"] = 4] = "NonAccessUser";
    UserType2[UserType2["ForcedUser"] = 5] = "ForcedUser";
    UserType2[UserType2["DisposableUser"] = 6] = "DisposableUser";
    UserType2[UserType2["ExpiringUser"] = 7] = "ExpiringUser";
    UserType2[UserType2["ScheduleRestrictedUser"] = 8] = "ScheduleRestrictedUser";
    UserType2[UserType2["RemoteOnlyUser"] = 9] = "RemoteOnlyUser";
  })(UserType = DoorLock2.UserType || (DoorLock2.UserType = {}));
  let CredentialRule;
  ((CredentialRule2) => {
    CredentialRule2[CredentialRule2["Single"] = 0] = "Single";
    CredentialRule2[CredentialRule2["Dual"] = 1] = "Dual";
    CredentialRule2[CredentialRule2["Tri"] = 2] = "Tri";
  })(CredentialRule = DoorLock2.CredentialRule || (DoorLock2.CredentialRule = {}));
  DoorLock2.TlvSetUserRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the type of operation.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.34.1
     */
    operationType: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the user ID.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.34.2
     */
    userIndex: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16.bound({ min: 1 })),
    /**
     * This field shall contain a string to use as a human readable identifier for the user. If UserName is null
     * then:
     *
     *   • If the OperationType is Add, the UserName in the resulting user record shall be set to an empty string.
     *
     *   • If the OperationType is Modify, the UserName in the user record shall NOT be changed from the current
     *     value.
     *
     * If UserName is not null, the UserName in the user record shall be set to the provided value.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.34.3
     */
    userName: (0, import_TlvObject.TlvField)(2, (0, import_TlvNullable.TlvNullable)(import_TlvString.TlvString.bound({ maxLength: 10 }))),
    /**
     * This field shall indicate the fabric assigned number to use for connecting this user to other users on other
     * devices from the fabric’s perspective.
     *
     * If UserUniqueID is null then:
     *
     *   • If the OperationType is Add, the UserUniqueID in the resulting user record shall be set to default value
     *     specified above.
     *
     *   • If the OperationType is Modify, the UserUniqueID in the user record shall NOT be changed from the
     *     current value.
     *
     * If UserUniqueID is not null, the UserUniqueID in the user record shall be set to the provided value.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.34.4
     */
    userUniqueId: (0, import_TlvObject.TlvField)(3, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt32)),
    /**
     * This field shall indicate the UserStatus to assign to this user when created or modified. If UserStatus is
     * null then:
     *
     *   • If the OperationType is Add, the UserStatus in the resulting user record shall be set to default value
     *     specified above.
     *
     *   • If the OperationType is Modify, the UserStatus in the user record shall NOT be changed from the current
     *     value.
     *
     * If UserStatus is not null, the UserStatus in the user record shall be set to the provided value.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.34.5
     */
    userStatus: (0, import_TlvObject.TlvField)(4, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    /**
     * This field shall indicate the UserType to assign to this user when created or modified. If UserType is null
     * then:
     *
     *   • If the OperationType is Add, the UserType in the resulting user record shall be set to default value
     *     specified above.
     *
     *   • If the OperationType is Modify, the UserType in the user record shall NOT be changed from the current
     *     value.
     *
     * If UserType is not null, the UserType in the user record shall be set to the provided value.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.34.6
     */
    userType: (0, import_TlvObject.TlvField)(5, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    /**
     * This field shall indicate the CredentialRule to use for this user.
     *
     * The valid CredentialRule enumeration values depends on the bits in the CredentialRulesBitmap map. Each bit
     * in the map identifies a valid CredentialRule that can be used.
     *
     * If CredentialRule is null then:
     *
     *   • If the OperationType is Add, the CredentialRule in the resulting user record shall be set to default
     *     value specified above.
     *
     *   • If the OperationType is Modify, the CredentialRule in the user record shall NOT be changed from the
     *     current value.
     *
     * If CredentialRule is not null, the CredentialRule in the user record shall be set to the provided value.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.34.7
     */
    credentialRule: (0, import_TlvObject.TlvField)(6, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)()))
  });
  DoorLock2.TlvGetUserRequest = (0, import_TlvObject.TlvObject)({ userIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16.bound({ min: 1 })) });
  let CredentialType;
  ((CredentialType2) => {
    CredentialType2[CredentialType2["ProgrammingPin"] = 0] = "ProgrammingPin";
    CredentialType2[CredentialType2["Pin"] = 1] = "Pin";
    CredentialType2[CredentialType2["Rfid"] = 2] = "Rfid";
    CredentialType2[CredentialType2["Fingerprint"] = 3] = "Fingerprint";
    CredentialType2[CredentialType2["FingerVein"] = 4] = "FingerVein";
    CredentialType2[CredentialType2["Face"] = 5] = "Face";
  })(CredentialType = DoorLock2.CredentialType || (DoorLock2.CredentialType = {}));
  DoorLock2.TlvCredential = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the credential field used to authorize the lock operation.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.6.26.1
     */
    credentialType: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the index of the specific credential used to authorize the lock operation in the
     * list of credentials identified by CredentialType (e.g. PIN, RFID, etc.). This field shall be set to 0 if
     * CredentialType is ProgrammingPIN or does not correspond to a list that can be indexed into.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.6.26.2
     */
    credentialIndex: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16)
  });
  DoorLock2.TlvGetUserResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the user ID.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.36.1
     */
    userIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16.bound({ min: 1 })),
    /**
     * This field shall contain a string to use as a human readable identifier for the user.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.36.2
     */
    userName: (0, import_TlvObject.TlvField)(1, (0, import_TlvNullable.TlvNullable)(import_TlvString.TlvString.bound({ maxLength: 10 }))),
    /**
     * See UserUniqueID field.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.36.3
     */
    userUniqueId: (0, import_TlvObject.TlvField)(2, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt32)),
    /**
     * This field shall indicate the UserStatus assigned to the user when created or modified.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.36.4
     */
    userStatus: (0, import_TlvObject.TlvField)(3, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    /**
     * This field shall indicate the UserType assigned to this user when created or modified.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.36.5
     */
    userType: (0, import_TlvObject.TlvField)(4, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    /**
     * This field shall indicate the CredentialRule set for this user.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.36.6
     */
    credentialRule: (0, import_TlvObject.TlvField)(5, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    /**
     * This field shall contain a list of credentials for this user.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.36.7
     */
    credentials: (0, import_TlvObject.TlvField)(6, (0, import_TlvNullable.TlvNullable)((0, import_TlvArray.TlvArray)(DoorLock2.TlvCredential, { minLength: 0 }))),
    /**
     * This field shall indicate the user’s creator fabric index. CreatorFabricIndex shall be null if UserStatus is
     * set to Available or when the creator fabric cannot be determined (for example, when user was created outside
     * the Interaction Model) and shall NOT be null otherwise. This value shall be set to 0 if the original creator
     * fabric was deleted.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.36.8
     */
    creatorFabricIndex: (0, import_TlvObject.TlvField)(7, (0, import_TlvNullable.TlvNullable)(import_FabricIndex.TlvFabricIndex)),
    /**
     * This field shall indicate the user’s last modifier fabric index. LastModifiedFabricIndex shall be null if
     * UserStatus is set to Available or when the modifier fabric cannot be determined (for example, when user was
     * modified outside the Interaction Model) and shall NOT be null otherwise. This value shall be set to 0 if the
     * last modifier fabric was deleted.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.36.9
     */
    lastModifiedFabricIndex: (0, import_TlvObject.TlvField)(8, (0, import_TlvNullable.TlvNullable)(import_FabricIndex.TlvFabricIndex)),
    /**
     * This field shall indicate the next occupied UserIndex in the database which is useful for quickly
     * identifying occupied user slots in the database. This shall NOT be null if there is at least one occupied
     * entry after the requested UserIndex in the User database and shall be null if there are no more occupied
     * entries.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.36.10
     */
    nextUserIndex: (0, import_TlvObject.TlvField)(9, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16.bound({ min: 1 })))
  });
  DoorLock2.TlvClearUserRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall specify a valid User index or 0xFFFE to indicate all user slots shall be cleared.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.37.1
     */
    userIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16)
  });
  DoorLock2.TlvSetCredentialRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the set credential operation type requested.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.40.1
     */
    operationType: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall contain a credential structure that contains the CredentialTypeEnum and the credential
     * index (if applicable or 0 if not) to set.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.40.2
     */
    credential: (0, import_TlvObject.TlvField)(1, DoorLock2.TlvCredential),
    /**
     * This field shall indicate the credential data to set for the credential being added or modified. The length
     * of the credential data shall conform to the limits of the CredentialType specified in the Credential
     * structure otherwise an INVALID_COMMAND status shall be returned in the SetCredentialResponse command.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.40.3
     */
    credentialData: (0, import_TlvObject.TlvField)(2, import_TlvString.TlvByteString),
    /**
     * This field shall indicate the user index to the user record that corresponds to the credential being added
     * or modified. This shall be null if OperationType is add and a new credential and user is being added at the
     * same time.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.40.4
     */
    userIndex: (0, import_TlvObject.TlvField)(3, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16.bound({ min: 1 }))),
    /**
     * This field shall indicate the user status to use in the new user record if a new user is being created. This
     * shall be null if OperationType is Modify. This may be null when adding a new credential and user.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.40.5
     */
    userStatus: (0, import_TlvObject.TlvField)(4, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    /**
     * This field shall indicate the user type to use in the new user record if a new user is being created. This
     * shall be null if OperationType is Modify. This may be null when adding a new credential and user.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.40.6
     */
    userType: (0, import_TlvObject.TlvField)(5, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)()))
  });
  DoorLock2.TlvSetCredentialResponse = (0, import_TlvObject.TlvObject)({
    /**
     * Status comes from the Status Codes table and shall be one of the following values:
     *
     *   • SUCCESS, if setting user credential was successful.
     *
     *   • FAILURE, if some unexpected internal error occurred setting user credential.
     *
     *   • OCCUPIED, if OperationType is Add and CredentialIndex in Credential structure points to an occupied slot.
     *
     *   • OCCUPIED, if OperationType is Modify and CredentialIndex in Credential structure does not match the
     *     CredentialIndex that is already associated with the provided UserIndex.
     *
     *   • DUPLICATE, if CredentialData provided is a duplicate of another credential with the same CredentialType
     *     (e.g. duplicate PIN code).
     *
     *   • RESOURCE_EXHAUSTED, if OperationType is Add and the user referred to by UserIndex already has
     *     NumberOfCredentialsSupportedPerUser credentials associated.
     *
     *   • INVALID_COMMAND, if one or more fields violate constraints or are invalid.
     *
     *   • INVALID_COMMAND, if the CredentialIndex in the Credential provided exceeds the number of credentials of
     *     the provided CredentialType supported by the lock.
     *
     *   • INVALID_COMMAND, if OperationType is Modify and UserIndex points to an available slot.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.41.1
     */
    status: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the user index that was created with the new credential. If the status being
     * returned is not success then this shall be null. This shall be null if OperationType was Modify; if the
     * OperationType was Add and a new User was created this shall NOT be null and shall provide the UserIndex
     * created. If the OperationType was Add and an existing User was associated with the new credential then this
     * shall be null.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.41.2
     */
    userIndex: (0, import_TlvObject.TlvField)(1, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16.bound({ min: 1 }))),
    /**
     * This field shall indicate the next available index in the database for the credential type set, which is
     * useful for quickly identifying available credential slots in the database. This shall NOT be null if there
     * is at least one available entry after the requested credential index in the corresponding database and shall
     * be null if there are no more available entries. The NextCredentialIndex reported shall NOT exceed the
     * maximum number of credentials for a particular credential type.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.41.3
     */
    nextCredentialIndex: (0, import_TlvObject.TlvOptionalField)(2, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16))
  });
  DoorLock2.TlvGetCredentialStatusRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall contain a credential structure that contains the CredentialTypeEnum and the credential
     * index (if applicable or 0 if not) to retrieve the status for.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.42.1
     */
    credential: (0, import_TlvObject.TlvField)(0, DoorLock2.TlvCredential)
  });
  DoorLock2.TlvGetCredentialStatusResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate if the requested credential type and index exists and is populated for the
     * requested user index.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.43.1
     */
    credentialExists: (0, import_TlvObject.TlvField)(0, import_TlvBoolean.TlvBoolean),
    /**
     * This field shall indicate the credential’s corresponding user index value if the credential exists. If
     * CredentialType requested was ProgrammingPIN then UserIndex shall be null; otherwise, UserIndex shall be null
     * if CredentialExists is set to False and shall NOT be null if CredentialExists is set to True.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.43.2
     */
    userIndex: (0, import_TlvObject.TlvField)(1, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16.bound({ min: 1 }))),
    /**
     * This field shall indicate the credential’s creator fabric index. CreatorFabricIndex shall be null if
     * CredentialExists is set to False or when the creator fabric cannot be determined (for example, when
     * credential was created outside the Interaction Model) and shall NOT be null otherwise. This value shall be
     * set to 0 if the original creator fabric was deleted.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.43.3
     */
    creatorFabricIndex: (0, import_TlvObject.TlvField)(2, (0, import_TlvNullable.TlvNullable)(import_FabricIndex.TlvFabricIndex)),
    /**
     * This field shall indicate the credential’s last modifier fabric index. LastModifiedFabricIndex shall be null
     * if CredentialExists is set to False or when the modifier fabric cannot be determined (for example, when
     * credential was modified outside the Interaction Model) and shall NOT be null otherwise. This value shall be
     * set to 0 if the last modifier fabric was deleted.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.43.4
     */
    lastModifiedFabricIndex: (0, import_TlvObject.TlvField)(3, (0, import_TlvNullable.TlvNullable)(import_FabricIndex.TlvFabricIndex)),
    /**
     * This field shall indicate the next occupied index in the database for the credential type requested, which
     * is useful for quickly identifying occupied credential slots in the database. This shall NOT be null if there
     * is at least one occupied entry after the requested credential index in the corresponding database and shall
     * be null if there are no more occupied entries. The NextCredentialIndex reported shall NOT exceed the maximum
     * number of credentials for a particular credential type.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.43.5
     */
    nextCredentialIndex: (0, import_TlvObject.TlvOptionalField)(4, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16))
  });
  DoorLock2.TlvClearCredentialRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall contain a credential structure that contains the CredentialTypeEnum and the credential
     * index (0xFFFE for all credentials or 0 if not applicable) to clear. This shall be null if clearing all
     * credential types otherwise it shall NOT be null.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.44.1
     */
    credential: (0, import_TlvObject.TlvField)(0, (0, import_TlvNullable.TlvNullable)(DoorLock2.TlvCredential))
  });
  let LockDataType;
  ((LockDataType2) => {
    LockDataType2[LockDataType2["Unspecified"] = 0] = "Unspecified";
    LockDataType2[LockDataType2["ProgrammingCode"] = 1] = "ProgrammingCode";
    LockDataType2[LockDataType2["UserIndex"] = 2] = "UserIndex";
    LockDataType2[LockDataType2["WeekDaySchedule"] = 3] = "WeekDaySchedule";
    LockDataType2[LockDataType2["YearDaySchedule"] = 4] = "YearDaySchedule";
    LockDataType2[LockDataType2["HolidaySchedule"] = 5] = "HolidaySchedule";
    LockDataType2[LockDataType2["Pin"] = 6] = "Pin";
    LockDataType2[LockDataType2["Rfid"] = 7] = "Rfid";
    LockDataType2[LockDataType2["Fingerprint"] = 8] = "Fingerprint";
    LockDataType2[LockDataType2["FingerVein"] = 9] = "FingerVein";
    LockDataType2[LockDataType2["Face"] = 10] = "Face";
  })(LockDataType = DoorLock2.LockDataType || (DoorLock2.LockDataType = {}));
  let OperationSource;
  ((OperationSource2) => {
    OperationSource2[OperationSource2["Unspecified"] = 0] = "Unspecified";
    OperationSource2[OperationSource2["Manual"] = 1] = "Manual";
    OperationSource2[OperationSource2["ProprietaryRemote"] = 2] = "ProprietaryRemote";
    OperationSource2[OperationSource2["Keypad"] = 3] = "Keypad";
    OperationSource2[OperationSource2["Auto"] = 4] = "Auto";
    OperationSource2[OperationSource2["Button"] = 5] = "Button";
    OperationSource2[OperationSource2["Schedule"] = 6] = "Schedule";
    OperationSource2[OperationSource2["Remote"] = 7] = "Remote";
    OperationSource2[OperationSource2["Rfid"] = 8] = "Rfid";
    OperationSource2[OperationSource2["Biometric"] = 9] = "Biometric";
  })(OperationSource = DoorLock2.OperationSource || (DoorLock2.OperationSource = {}));
  DoorLock2.TlvLockUserChangeEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the lock data type that was changed.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.5.1
     */
    lockDataType: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the data operation performed on the lock data type changed.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.5.2
     */
    dataOperationType: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the source of the user data change.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.5.3
     */
    operationSource: (0, import_TlvObject.TlvField)(2, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the lock UserIndex associated with the change (if any). This shall be null if
     * there is no specific user associated with the data operation. This shall be 0xFFFE if all users are affected
     * (e.g. Clear Users).
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.5.4
     */
    userIndex: (0, import_TlvObject.TlvField)(3, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16)),
    /**
     * This field shall indicate the fabric index of the fabric that performed the change (if any). This shall be
     * null if there is no fabric that can be determined to have caused the change. This shall NOT be null if the
     * operation source is "Remote".
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.5.5
     */
    fabricIndex: (0, import_TlvObject.TlvField)(4, (0, import_TlvNullable.TlvNullable)(import_FabricIndex.TlvFabricIndex)),
    /**
     * This field shall indicate the Node ID that performed the change (if any). The Node ID of the node that
     * performed the change. This shall be null if there was no Node involved in the change. This shall NOT be null
     * if the operation source is "Remote".
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.5.6
     */
    sourceNode: (0, import_TlvObject.TlvField)(5, (0, import_TlvNullable.TlvNullable)(import_NodeId.TlvNodeId)),
    /**
     * This field shall indicate the index of the specific item that was changed (e.g. schedule, PIN, RFID, etc.)
     * in the list of items identified by LockDataType. This shall be null if the LockDataType does not correspond
     * to a list that can be indexed into (e.g. ProgrammingUser). This shall be 0xFFFE if all indices are affected
     * (e.g. ClearPINCode, ClearRFIDCode, ClearWeekDaySchedule, ClearYearDaySchedule, etc.).
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.5.7
     */
    dataIndex: (0, import_TlvObject.TlvField)(6, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16))
  });
  DoorLock2.DaysMask = {
    /**
     * Schedule is applied on Sunday
     */
    sunday: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * Schedule is applied on Monday
     */
    monday: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * Schedule is applied on Tuesday
     */
    tuesday: (0, import_BitmapSchema.BitFlag)(2),
    /**
     * Schedule is applied on Wednesday
     */
    wednesday: (0, import_BitmapSchema.BitFlag)(3),
    /**
     * Schedule is applied on Thursday
     */
    thursday: (0, import_BitmapSchema.BitFlag)(4),
    /**
     * Schedule is applied on Friday
     */
    friday: (0, import_BitmapSchema.BitFlag)(5),
    /**
     * Schedule is applied on Saturday
     */
    saturday: (0, import_BitmapSchema.BitFlag)(6)
  };
  DoorLock2.TlvSetWeekDayScheduleRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the index of the Week Day schedule.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.14.1
     */
    weekDayIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8.bound({ min: 1 })),
    userIndexUserId: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16.bound({ min: 1 })),
    /**
     * This field shall indicate which week days the schedule is active.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.14.3
     */
    daysMask: (0, import_TlvObject.TlvField)(2, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt8, DoorLock2.DaysMask)),
    /**
     * This field shall indicate the starting hour for the Week Day schedule.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.14.4
     */
    startHour: (0, import_TlvObject.TlvField)(3, import_TlvNumber.TlvUInt8.bound({ max: 23 })),
    /**
     * This field shall indicate the starting minute for the Week Day schedule.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.14.5
     */
    startMinute: (0, import_TlvObject.TlvField)(4, import_TlvNumber.TlvUInt8.bound({ max: 59 })),
    /**
     * This field shall indicate the ending hour for the Week Day schedule. EndHour shall be equal to or greater
     * than StartHour.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.14.6
     */
    endHour: (0, import_TlvObject.TlvField)(5, import_TlvNumber.TlvUInt8.bound({ max: 23 })),
    /**
     * This field shall indicate the ending minute for the Week Day schedule. If EndHour is equal to StartHour then
     * EndMinute shall be greater than StartMinute.
     *
     * If the EndHour is equal to 23 and the EndMinute is equal to 59 the Lock shall grant access to the user up
     * until 23:59:59.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.14.7
     */
    endMinute: (0, import_TlvObject.TlvField)(6, import_TlvNumber.TlvUInt8.bound({ max: 59 }))
  });
  DoorLock2.TlvGetWeekDayScheduleRequest = (0, import_TlvObject.TlvObject)({
    weekDayIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8.bound({ min: 1 })),
    userIndexUserId: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16.bound({ min: 1 }))
  });
  DoorLock2.TlvGetWeekDayScheduleResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the index of the Week Day schedule.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.16.1
     */
    weekDayIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8.bound({ min: 1 })),
    userIndexUserId: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16.bound({ min: 1 })),
    /**
     * Status shall be one of the following values:
     *
     *   • SUCCESS if both WeekDayIndex and UserIndex are valid and there is a corresponding schedule entry.
     *
     *   • INVALID_COMMAND if either WeekDayIndex and/or UserIndex values are not within valid range
     *
     *   • NOT_FOUND if no corresponding schedule entry found for WeekDayIndex.
     *
     *   • NOT_FOUND if no corresponding user entry found for UserIndex.
     *
     * If this field is SUCCESS, the optional fields for this command shall be present. For other (error) status
     * values, only the fields up to the status field shall be present.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.16.3
     */
    status: (0, import_TlvObject.TlvField)(2, (0, import_TlvNumber.TlvEnum)()),
    daysMask: (0, import_TlvObject.TlvOptionalField)(3, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt8, DoorLock2.DaysMask)),
    /**
     * This field shall indicate the starting hour for the Week Day schedule.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.16.4
     */
    startHour: (0, import_TlvObject.TlvOptionalField)(4, import_TlvNumber.TlvUInt8.bound({ max: 23 })),
    /**
     * This field shall indicate the starting minute for the Week Day schedule.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.16.5
     */
    startMinute: (0, import_TlvObject.TlvOptionalField)(5, import_TlvNumber.TlvUInt8.bound({ max: 59 })),
    /**
     * This field shall indicate the ending hour for the Week Day schedule. EndHour shall be equal to or greater
     * than StartHour.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.16.6
     */
    endHour: (0, import_TlvObject.TlvOptionalField)(6, import_TlvNumber.TlvUInt8.bound({ max: 23 })),
    /**
     * This field shall indicate the ending minute for the Week Day schedule. If EndHour is equal to StartHour then
     * EndMinute shall be greater than StartMinute.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.16.7
     */
    endMinute: (0, import_TlvObject.TlvOptionalField)(7, import_TlvNumber.TlvUInt8.bound({ max: 59 }))
  });
  DoorLock2.TlvClearWeekDayScheduleRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the Week Day schedule index to clear or 0xFE to clear all Week Day schedules for
     * the specified user.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.17.1
     */
    weekDayIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8),
    userIndexUserId: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16.bound({ min: 1 }))
  });
  DoorLock2.TlvSetYearDayScheduleRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the index of the Year Day schedule.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.18.1
     */
    yearDayIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8.bound({ min: 1 })),
    userIndexUserId: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16.bound({ min: 1 })),
    /**
     * This field shall indicate the starting time for the Year Day schedule in Epoch Time in Seconds with local
     * time offset based on the local timezone and DST offset on the day represented by the value.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.18.3
     */
    localStartTime: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvEpochS),
    /**
     * This field shall indicate the ending time for the Year Day schedule in Epoch Time in Seconds with local time
     * offset based on the local timezone and DST offset on the day represented by the value. LocalEndTime shall be
     * greater than LocalStartTime.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.18.4
     */
    localEndTime: (0, import_TlvObject.TlvField)(3, import_TlvNumber.TlvEpochS)
  });
  DoorLock2.TlvGetYearDayScheduleRequest = (0, import_TlvObject.TlvObject)({
    yearDayIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8.bound({ min: 1 })),
    userIndexUserId: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16.bound({ min: 1 }))
  });
  DoorLock2.TlvGetYearDayScheduleResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the index of the Year Day schedule.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.20.1
     */
    yearDayIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8.bound({ min: 1 })),
    userIndexUserId: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16.bound({ min: 1 })),
    /**
     * Status shall be one of the following values:
     *
     *   • SUCCESS if both YearDayIndex and UserIndex are valid and there is a corresponding schedule entry.
     *
     *   • INVALID_COMMAND if either YearDayIndex and/or UserIndex values are not within valid range
     *
     *   • NOT_FOUND if no corresponding schedule entry found for YearDayIndex.
     *
     *   • NOT_FOUND if no corresponding user entry found for UserIndex.
     *
     * If this field is SUCCESS, the optional fields for this command shall be present. For other (error) status
     * values, only the fields up to the status field shall be present.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.20.3
     */
    status: (0, import_TlvObject.TlvField)(2, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the starting time for the Year Day schedule in Epoch Time in Seconds with local
     * time offset based on the local timezone and DST offset on the day represented by the value. This shall be
     * null if the schedule is not set for the YearDayIndex and UserIndex provided.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.20.4
     */
    localStartTime: (0, import_TlvObject.TlvOptionalField)(2, import_TlvNumber.TlvEpochS),
    /**
     * This field shall indicate the ending time for the Year Day schedule in Epoch Time in Seconds with local time
     * offset based on the local timezone and DST offset on the day represented by the value. LocalEndTime shall be
     * greater than LocalStartTime. This shall be null if the schedule is not set for the YearDayIndex and
     * UserIndex provided.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.20.5
     */
    localEndTime: (0, import_TlvObject.TlvOptionalField)(3, import_TlvNumber.TlvEpochS)
  });
  DoorLock2.TlvClearYearDayScheduleRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the Year Day schedule index to clear or 0xFE to clear all Year Day schedules for
     * the specified user.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.21.1
     */
    yearDayIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8),
    userIndexUserId: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16.bound({ min: 1 }))
  });
  let OperatingMode;
  ((OperatingMode2) => {
    OperatingMode2[OperatingMode2["Normal"] = 0] = "Normal";
    OperatingMode2[OperatingMode2["Vacation"] = 1] = "Vacation";
    OperatingMode2[OperatingMode2["Privacy"] = 2] = "Privacy";
    OperatingMode2[OperatingMode2["NoRemoteLockUnlock"] = 3] = "NoRemoteLockUnlock";
    OperatingMode2[OperatingMode2["Passage"] = 4] = "Passage";
  })(OperatingMode = DoorLock2.OperatingMode || (DoorLock2.OperatingMode = {}));
  DoorLock2.TlvSetHolidayScheduleRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the index of the Holiday schedule.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.22.1
     */
    holidayIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8.bound({ min: 1 })),
    /**
     * This field shall indicate the starting time for the Holiday Day schedule in Epoch Time in Seconds with local
     * time offset based on the local timezone and DST offset on the day represented by the value.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.22.2
     */
    localStartTime: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvEpochS),
    /**
     * This field shall indicate the ending time for the Holiday Day schedule in Epoch Time in Seconds with local
     * time offset based on the local timezone and DST offset on the day represented by the value. LocalEndTime
     * shall be greater than LocalStartTime.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.22.3
     */
    localEndTime: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvEpochS),
    /**
     * This field shall indicate the operating mode to use during this Holiday schedule start/end time.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.22.4
     */
    operatingMode: (0, import_TlvObject.TlvField)(3, (0, import_TlvNumber.TlvEnum)())
  });
  DoorLock2.TlvGetHolidayScheduleRequest = (0, import_TlvObject.TlvObject)({ holidayIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8.bound({ min: 1 })) });
  DoorLock2.TlvGetHolidayScheduleResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the index of the Holiday schedule.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.24.1
     */
    holidayIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8.bound({ min: 1 })),
    /**
     * Status shall be one of the following values:
     *
     *   • FAILURE if the attribute NumberOfHolidaySchedulesSupported is zero.
     *
     *   • SUCCESS if the HolidayIndex is valid and there is a corresponding schedule entry.
     *
     *   • INVALID_COMMAND if the HolidayIndex is not within valid range
     *
     *   • NOT_FOUND if the HolidayIndex is within the valid range, however, there is not corresponding schedule
     *     entry found.
     *
     * If this field is SUCCESS, the optional fields for this command shall be present. For other (error) status
     * values, only the fields up to the status field shall be present.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.24.2
     */
    status: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the starting time for the Holiday schedule in Epoch Time in Seconds with local
     * time offset based on the local timezone and DST offset on the day represented by the value. This shall be
     * null if the schedule is not set for the HolidayIndex provided.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.24.3
     */
    localStartTime: (0, import_TlvObject.TlvOptionalField)(2, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvEpochS)),
    /**
     * This field shall indicate the ending time for the Holiday schedule in Epoch Time in Seconds with local time
     * offset based on the local timezone and DST offset on the day represented by the value. LocalEndTime shall be
     * greater than LocalStartTime. This shall be null if the schedule is not set for the HolidayIndex provided.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.24.4
     */
    localEndTime: (0, import_TlvObject.TlvOptionalField)(3, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvEpochS)),
    /**
     * This field shall indicate the operating mode to use during this Holiday schedule start/end time. This shall
     * be null if the schedule is not set for the HolidayIndex provided.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.24.5
     */
    operatingMode: (0, import_TlvObject.TlvOptionalField)(4, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)()))
  });
  DoorLock2.TlvClearHolidayScheduleRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the Holiday schedule index to clear or 0xFE to clear all Holiday schedules.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.25.1
     */
    holidayIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8)
  });
  DoorLock2.TlvSetPinCodeRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the user ID. The value of the UserID field shall be between 0 and the value of the
     * NumberOfPINUsersSupported attribute.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.6.1
     */
    userId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
    /**
     * This field shall indicate the user status. Only the values 1 (Occupied/Enabled) and 3 (Occupied/Disabled)
     * are allowed for UserStatus.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.6.2
     */
    userStatus: (0, import_TlvObject.TlvField)(1, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    userType: (0, import_TlvObject.TlvField)(2, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    pin: (0, import_TlvObject.TlvField)(3, import_TlvString.TlvByteString)
  });
  DoorLock2.TlvGetPinCodeRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the user ID. The value of the UserID field shall be between 0 and the value of the
     * NumberOfPINUsersSupported attribute.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.7.1
     */
    userId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16)
  });
  DoorLock2.TlvGetPinCodeResponse = (0, import_TlvObject.TlvObject)({
    userId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
    userStatus: (0, import_TlvObject.TlvField)(1, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    userType: (0, import_TlvObject.TlvField)(2, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    pinCode: (0, import_TlvObject.TlvField)(3, (0, import_TlvNullable.TlvNullable)(import_TlvString.TlvByteString))
  });
  DoorLock2.TlvClearPinCodeRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall specify a valid PIN code slot index or 0xFFFE to indicate all PIN code slots shall be
     * cleared.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.9.1
     */
    pinSlotIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16)
  });
  DoorLock2.EventMask = {
    /**
     * State of bit 0
     */
    bit0: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * State of bit 1
     */
    bit1: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * State of bit 2
     */
    bit2: (0, import_BitmapSchema.BitFlag)(2),
    /**
     * State of bit 3
     */
    bit3: (0, import_BitmapSchema.BitFlag)(3),
    /**
     * State of bit 4
     */
    bit4: (0, import_BitmapSchema.BitFlag)(4),
    /**
     * State of bit 5
     */
    bit5: (0, import_BitmapSchema.BitFlag)(5),
    /**
     * State of bit 6
     */
    bit6: (0, import_BitmapSchema.BitFlag)(6),
    /**
     * State of bit 7
     */
    bit7: (0, import_BitmapSchema.BitFlag)(7),
    /**
     * State of bit 8
     */
    bit8: (0, import_BitmapSchema.BitFlag)(8),
    /**
     * State of bit 9
     */
    bit9: (0, import_BitmapSchema.BitFlag)(9),
    /**
     * State of bit 10
     */
    bit10: (0, import_BitmapSchema.BitFlag)(10),
    /**
     * State of bit 11
     */
    bit11: (0, import_BitmapSchema.BitFlag)(11),
    /**
     * State of bit 12
     */
    bit12: (0, import_BitmapSchema.BitFlag)(12),
    /**
     * State of bit 13
     */
    bit13: (0, import_BitmapSchema.BitFlag)(13),
    /**
     * State of bit 14
     */
    bit14: (0, import_BitmapSchema.BitFlag)(14),
    /**
     * State of bit 15
     */
    bit15: (0, import_BitmapSchema.BitFlag)(15)
  };
  DoorLock2.KeypadProgrammingEventMask = {
    unknown: (0, import_BitmapSchema.BitFlag)(0),
    pinCodeChanged: (0, import_BitmapSchema.BitFlag)(1),
    pinAdded: (0, import_BitmapSchema.BitFlag)(2),
    pinCleared: (0, import_BitmapSchema.BitFlag)(3),
    pinChanged: (0, import_BitmapSchema.BitFlag)(4),
    /**
     * State of bit 0
     */
    bit0: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * State of bit 1
     */
    bit1: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * State of bit 2
     */
    bit2: (0, import_BitmapSchema.BitFlag)(2),
    /**
     * State of bit 3
     */
    bit3: (0, import_BitmapSchema.BitFlag)(3),
    /**
     * State of bit 4
     */
    bit4: (0, import_BitmapSchema.BitFlag)(4),
    /**
     * State of bit 5
     */
    bit5: (0, import_BitmapSchema.BitFlag)(5),
    /**
     * State of bit 6
     */
    bit6: (0, import_BitmapSchema.BitFlag)(6),
    /**
     * State of bit 7
     */
    bit7: (0, import_BitmapSchema.BitFlag)(7),
    /**
     * State of bit 8
     */
    bit8: (0, import_BitmapSchema.BitFlag)(8),
    /**
     * State of bit 9
     */
    bit9: (0, import_BitmapSchema.BitFlag)(9),
    /**
     * State of bit 10
     */
    bit10: (0, import_BitmapSchema.BitFlag)(10),
    /**
     * State of bit 11
     */
    bit11: (0, import_BitmapSchema.BitFlag)(11),
    /**
     * State of bit 12
     */
    bit12: (0, import_BitmapSchema.BitFlag)(12),
    /**
     * State of bit 13
     */
    bit13: (0, import_BitmapSchema.BitFlag)(13),
    /**
     * State of bit 14
     */
    bit14: (0, import_BitmapSchema.BitFlag)(14),
    /**
     * State of bit 15
     */
    bit15: (0, import_BitmapSchema.BitFlag)(15)
  };
  DoorLock2.RemoteProgrammingEventMask = {
    unknown: (0, import_BitmapSchema.BitFlag)(0),
    pinAdded: (0, import_BitmapSchema.BitFlag)(2),
    pinCleared: (0, import_BitmapSchema.BitFlag)(3),
    pinChanged: (0, import_BitmapSchema.BitFlag)(4),
    rfidCodeAdded: (0, import_BitmapSchema.BitFlag)(5),
    rfidCodeCleared: (0, import_BitmapSchema.BitFlag)(6),
    /**
     * State of bit 0
     */
    bit0: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * State of bit 1
     */
    bit1: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * State of bit 2
     */
    bit2: (0, import_BitmapSchema.BitFlag)(2),
    /**
     * State of bit 3
     */
    bit3: (0, import_BitmapSchema.BitFlag)(3),
    /**
     * State of bit 4
     */
    bit4: (0, import_BitmapSchema.BitFlag)(4),
    /**
     * State of bit 5
     */
    bit5: (0, import_BitmapSchema.BitFlag)(5),
    /**
     * State of bit 6
     */
    bit6: (0, import_BitmapSchema.BitFlag)(6),
    /**
     * State of bit 7
     */
    bit7: (0, import_BitmapSchema.BitFlag)(7),
    /**
     * State of bit 8
     */
    bit8: (0, import_BitmapSchema.BitFlag)(8),
    /**
     * State of bit 9
     */
    bit9: (0, import_BitmapSchema.BitFlag)(9),
    /**
     * State of bit 10
     */
    bit10: (0, import_BitmapSchema.BitFlag)(10),
    /**
     * State of bit 11
     */
    bit11: (0, import_BitmapSchema.BitFlag)(11),
    /**
     * State of bit 12
     */
    bit12: (0, import_BitmapSchema.BitFlag)(12),
    /**
     * State of bit 13
     */
    bit13: (0, import_BitmapSchema.BitFlag)(13),
    /**
     * State of bit 14
     */
    bit14: (0, import_BitmapSchema.BitFlag)(14),
    /**
     * State of bit 15
     */
    bit15: (0, import_BitmapSchema.BitFlag)(15)
  };
  DoorLock2.RfidProgrammingEventMask = {
    unknown: (0, import_BitmapSchema.BitFlag)(0),
    idAdded: (0, import_BitmapSchema.BitFlag)(5),
    idCleared: (0, import_BitmapSchema.BitFlag)(6),
    /**
     * State of bit 0
     */
    bit0: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * State of bit 1
     */
    bit1: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * State of bit 2
     */
    bit2: (0, import_BitmapSchema.BitFlag)(2),
    /**
     * State of bit 3
     */
    bit3: (0, import_BitmapSchema.BitFlag)(3),
    /**
     * State of bit 4
     */
    bit4: (0, import_BitmapSchema.BitFlag)(4),
    /**
     * State of bit 5
     */
    bit5: (0, import_BitmapSchema.BitFlag)(5),
    /**
     * State of bit 6
     */
    bit6: (0, import_BitmapSchema.BitFlag)(6),
    /**
     * State of bit 7
     */
    bit7: (0, import_BitmapSchema.BitFlag)(7),
    /**
     * State of bit 8
     */
    bit8: (0, import_BitmapSchema.BitFlag)(8),
    /**
     * State of bit 9
     */
    bit9: (0, import_BitmapSchema.BitFlag)(9),
    /**
     * State of bit 10
     */
    bit10: (0, import_BitmapSchema.BitFlag)(10),
    /**
     * State of bit 11
     */
    bit11: (0, import_BitmapSchema.BitFlag)(11),
    /**
     * State of bit 12
     */
    bit12: (0, import_BitmapSchema.BitFlag)(12),
    /**
     * State of bit 13
     */
    bit13: (0, import_BitmapSchema.BitFlag)(13),
    /**
     * State of bit 14
     */
    bit14: (0, import_BitmapSchema.BitFlag)(14),
    /**
     * State of bit 15
     */
    bit15: (0, import_BitmapSchema.BitFlag)(15)
  };
  DoorLock2.TlvSetUserStatusRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the user ID. The value of the UserID field shall be between 0 and the value of the
     * NumberOfPINUsersSupported attribute.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.11.1
     */
    userId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
    /**
     * UserStatus value of Available is not allowed. In order to clear a user id, the ClearUser Command shall be
     * used. For user status value please refer to UserStatusEnum.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.11.2
     */
    userStatus: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)())
  });
  DoorLock2.TlvGetUserStatusRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the user ID. The value of the UserID field shall be between 0 and the value of the
     * NumberOfPINUsersSupported attribute.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.12.1
     */
    userId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16)
  });
  DoorLock2.TlvGetUserStatusResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the user ID provided in the request.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.13.1
     */
    userId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
    /**
     * This field shall indicate the current status of the requested user ID.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.13.2
     */
    userStatus: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)())
  });
  DoorLock2.TlvSetUserTypeRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the user ID.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.26.1
     */
    userId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
    /**
     * This field shall indicate the user type.
     *
     * If UserType is currently YearDayScheduleUser, WeekDayScheduleUser, or ScheduleRestrictedUser and the new
     * UserType is UnrestrictedUser then all existing Year Day and/or Week Day schedules shall be ignored or
     * disabled (if this transition is supported by the door lock). If UserType is ScheduleRestrictedUser and the
     * new UserType is ScheduleRestrictedUser then all existing Year Day and/or Week Day schedules shall be applied
     * or enabled.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.26.2
     */
    userType: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)())
  });
  DoorLock2.TlvGetUserTypeRequest = (0, import_TlvObject.TlvObject)({ userId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16) });
  DoorLock2.TlvGetUserTypeResponse = (0, import_TlvObject.TlvObject)({
    userId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
    userType: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)())
  });
  DoorLock2.TlvSetRfidCodeRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the user ID.
     *
     * The value of the UserID field shall be between 0 and the value of the NumberOfRFIDUsersSupported attribute.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.29.1
     */
    userId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
    /**
     * This field shall indicate what the status is for a specific user ID. The values are according to “Set PIN”
     * while not all are supported.
     *
     * Only the values 1 (Occupied/Enabled) and 3 (Occupied/Disabled) are allowed for UserStatus.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.29.2
     */
    userStatus: (0, import_TlvObject.TlvField)(1, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    /**
     * The values are the same as used for SetPINCode command.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.29.3
     */
    userType: (0, import_TlvObject.TlvField)(2, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    rfidCode: (0, import_TlvObject.TlvField)(3, import_TlvString.TlvByteString)
  });
  DoorLock2.TlvGetRfidCodeRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the user ID.
     *
     * The value of the UserID field shall be between 0 and the value of the NumberOfRFIDUsersSupported attribute.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.30.1
     */
    userId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16)
  });
  DoorLock2.TlvGetRfidCodeResponse = (0, import_TlvObject.TlvObject)({
    userId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
    userStatus: (0, import_TlvObject.TlvField)(1, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    userType: (0, import_TlvObject.TlvField)(2, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    rfidCode: (0, import_TlvObject.TlvField)(3, (0, import_TlvNullable.TlvNullable)(import_TlvString.TlvByteString))
  });
  DoorLock2.TlvClearRfidCodeRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate a valid RFID code slot index or 0xFFFE to indicate all RFID code slots shall be
     * cleared.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.32.1
     */
    rfidSlotIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16)
  });
  DoorLock2.TlvUnboltDoorRequest = (0, import_TlvObject.TlvObject)({
    /**
     * See PINCode field.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.45.1
     */
    pinCode: (0, import_TlvObject.TlvOptionalField)(0, import_TlvString.TlvByteString)
  });
  let LockState;
  ((LockState2) => {
    LockState2[LockState2["NotFullyLocked"] = 0] = "NotFullyLocked";
    LockState2[LockState2["Locked"] = 1] = "Locked";
    LockState2[LockState2["Unlocked"] = 2] = "Unlocked";
    LockState2[LockState2["Unlatched"] = 3] = "Unlatched";
  })(LockState = DoorLock2.LockState || (DoorLock2.LockState = {}));
  let LockType;
  ((LockType2) => {
    LockType2[LockType2["DeadBolt"] = 0] = "DeadBolt";
    LockType2[LockType2["Magnetic"] = 1] = "Magnetic";
    LockType2[LockType2["Other"] = 2] = "Other";
    LockType2[LockType2["Mortise"] = 3] = "Mortise";
    LockType2[LockType2["Rim"] = 4] = "Rim";
    LockType2[LockType2["LatchBolt"] = 5] = "LatchBolt";
    LockType2[LockType2["CylindricalLock"] = 6] = "CylindricalLock";
    LockType2[LockType2["TubularLock"] = 7] = "TubularLock";
    LockType2[LockType2["InterconnectedLock"] = 8] = "InterconnectedLock";
    LockType2[LockType2["DeadLatch"] = 9] = "DeadLatch";
    LockType2[LockType2["DoorFurniture"] = 10] = "DoorFurniture";
    LockType2[LockType2["Eurocylinder"] = 11] = "Eurocylinder";
  })(LockType = DoorLock2.LockType || (DoorLock2.LockType = {}));
  let LedSetting;
  ((LedSetting2) => {
    LedSetting2[LedSetting2["NoLedSignal"] = 0] = "NoLedSignal";
    LedSetting2[LedSetting2["NoLedSignalAccessAllowed"] = 1] = "NoLedSignalAccessAllowed";
    LedSetting2[LedSetting2["LedSignalAll"] = 2] = "LedSignalAll";
  })(LedSetting = DoorLock2.LedSetting || (DoorLock2.LedSetting = {}));
  let SoundVolume;
  ((SoundVolume2) => {
    SoundVolume2[SoundVolume2["Silent"] = 0] = "Silent";
    SoundVolume2[SoundVolume2["Low"] = 1] = "Low";
    SoundVolume2[SoundVolume2["High"] = 2] = "High";
    SoundVolume2[SoundVolume2["Medium"] = 3] = "Medium";
  })(SoundVolume = DoorLock2.SoundVolume || (DoorLock2.SoundVolume = {}));
  DoorLock2.OperatingModes = {
    /**
     * Normal operation mode
     */
    normal: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * Vacation operation mode
     */
    vacation: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * Privacy operation mode
     */
    privacy: (0, import_BitmapSchema.BitFlag)(2),
    /**
     * No remote lock and unlock operation mode
     */
    noRemoteLockUnlock: (0, import_BitmapSchema.BitFlag)(3),
    /**
     * Passage operation mode
     */
    passage: (0, import_BitmapSchema.BitFlag)(4)
  };
  DoorLock2.ConfigurationRegister = {
    /**
     * The state of local programming functionality
     *
     * This bit shall indicate the state related to local programming:
     *
     *   • 0 = Local programming is disabled
     *
     *   • 1 = Local programming is enabled
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.6.4.1
     */
    localProgramming: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * The state of the keypad interface
     *
     * This bit shall indicate the state related to keypad interface:
     *
     *   • 0 = Keypad interface is disabled
     *
     *   • 1 = Keypad interface is enabled
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.6.4.2
     */
    keypadInterface: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * The state of the remote interface
     *
     * This bit shall indicate the state related to remote interface:
     *
     *   • 0 = Remote interface is disabled
     *
     *   • 1 = Remote interface is enabled
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.6.4.3
     */
    remoteInterface: (0, import_BitmapSchema.BitFlag)(2),
    /**
     * Sound volume is set to Silent value
     *
     * This bit shall indicate the state related to sound volume:
     *
     *   • 0 = Sound volume value is 0 (Silent)
     *
     *   • 1 = Sound volume value is equal to something other than 0
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.6.4.4
     */
    soundVolume: (0, import_BitmapSchema.BitFlag)(5),
    /**
     * Auto relock time it set to 0
     *
     * This bit shall indicate the state related to auto relock time:
     *
     *   • 0 = Auto relock time value is 0
     *
     *   • 1 = Auto relock time value is equal to something other than 0
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.6.4.5
     */
    autoRelockTime: (0, import_BitmapSchema.BitFlag)(6),
    /**
     * LEDs is disabled
     *
     * This bit shall indicate the state related to LED settings:
     *
     *   • 0 = LED settings value is 0 (NoLEDSignal)
     *
     *   • 1 = LED settings value is equal to something other than 0
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.6.4.6
     */
    ledSettings: (0, import_BitmapSchema.BitFlag)(7)
  };
  DoorLock2.LocalProgrammingFeatures = {
    /**
     * The state of the ability to add users, credentials or schedules on the device
     *
     * This bit shall indicate whether the door lock is able to add Users/Credentials/Schedules locally:
     *
     *   • 0 = This ability is disabled
     *
     *   • 1 = This ability is enabled
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.6.5.1
     */
    addUsersCredentialsSchedules: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * The state of the ability to modify users, credentials or schedules on the device
     *
     * This bit shall indicate whether the door lock is able to modify Users/Credentials/Schedules locally:
     *
     *   • 0 = This ability is disabled
     *
     *   • 1 = This ability is enabled
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.6.5.2
     */
    modifyUsersCredentialsSchedules: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * The state of the ability to clear users, credentials or schedules on the device
     *
     * This bit shall indicate whether the door lock is able to clear Users/Credentials/Schedules locally:
     *
     *   • 0 = This ability is disabled
     *
     *   • 1 = This ability is enabled
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.6.5.3
     */
    clearUsersCredentialsSchedules: (0, import_BitmapSchema.BitFlag)(2),
    /**
     * The state of the ability to adjust settings on the device
     *
     * This bit shall indicate whether the door lock is able to adjust lock settings locally:
     *
     *   • 0 = This ability is disabled
     *
     *   • 1 = This ability is enabled
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.6.5.4
     */
    adjustSettings: (0, import_BitmapSchema.BitFlag)(3)
  };
  DoorLock2.AlarmMask = {
    /**
     * Locking Mechanism Jammed
     */
    lockJammed: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * Lock Reset to Factory Defaults
     */
    lockFactoryReset: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * Reserved
     */
    na: (0, import_BitmapSchema.BitFlag)(2),
    /**
     * RF Module Power Cycled
     */
    lockRadioPowerCycled: (0, import_BitmapSchema.BitFlag)(3),
    /**
     * Tamper Alarm - wrong code entry limit
     */
    wrongCodeEntryLimit: (0, import_BitmapSchema.BitFlag)(4),
    /**
     * Tamper Alarm - front escutcheon removed from main
     */
    frontEscutcheonRemoved: (0, import_BitmapSchema.BitFlag)(5),
    /**
     * Forced Door Open under Door Locked Condition
     */
    doorForcedOpen: (0, import_BitmapSchema.BitFlag)(6)
  };
  DoorLock2.TlvLockDoorRequest = (0, import_TlvObject.TlvObject)({
    /**
     * If the RequirePINforRemoteOperation attribute is True then PINCode field shall be provided and the door lock
     * shall NOT grant access if it is not provided.
     *
     * If the PINCode field is provided, the door lock shall verify PINCode before granting access regardless of
     * the value of RequirePINForRemoteOperation attribute.
     *
     * When the PINCode field is provided an invalid PIN will count towards the WrongCodeEntryLimit and the
     * UserCodeTemporaryDisableTime will be triggered if the WrongCodeEntryLimit is exceeded. The lock shall ignore
     * any attempts to lock/unlock the door until the UserCodeTemporaryDisableTime expires.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.1.1
     */
    pinCode: (0, import_TlvObject.TlvOptionalField)(0, import_TlvString.TlvByteString)
  });
  DoorLock2.TlvUnlockDoorRequest = (0, import_TlvObject.TlvObject)({
    /**
     * See PINCode field.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.2.1
     */
    pinCode: (0, import_TlvObject.TlvOptionalField)(0, import_TlvString.TlvByteString)
  });
  DoorLock2.TlvUnlockWithTimeoutRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the timeout in seconds to wait before relocking the door lock. This value is
     * independent of the AutoRelockTime attribute value.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.3.1
     */
    timeout: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
    /**
     * See PINCode field.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.3.2
     */
    pinCode: (0, import_TlvObject.TlvOptionalField)(1, import_TlvString.TlvByteString)
  });
  let AlarmCode;
  ((AlarmCode2) => {
    AlarmCode2[AlarmCode2["LockJammed"] = 0] = "LockJammed";
    AlarmCode2[AlarmCode2["LockFactoryReset"] = 1] = "LockFactoryReset";
    AlarmCode2[AlarmCode2["LockRadioPowerCycled"] = 3] = "LockRadioPowerCycled";
    AlarmCode2[AlarmCode2["WrongCodeEntryLimit"] = 4] = "WrongCodeEntryLimit";
    AlarmCode2[AlarmCode2["FrontEsceutcheonRemoved"] = 5] = "FrontEsceutcheonRemoved";
    AlarmCode2[AlarmCode2["DoorForcedOpen"] = 6] = "DoorForcedOpen";
    AlarmCode2[AlarmCode2["DoorAjar"] = 7] = "DoorAjar";
    AlarmCode2[AlarmCode2["ForcedUser"] = 8] = "ForcedUser";
  })(AlarmCode = DoorLock2.AlarmCode || (DoorLock2.AlarmCode = {}));
  DoorLock2.TlvDoorLockAlarmEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the alarm code of the event that has happened.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.1.1
     */
    alarmCode: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)())
  });
  let LockOperationType;
  ((LockOperationType2) => {
    LockOperationType2[LockOperationType2["Lock"] = 0] = "Lock";
    LockOperationType2[LockOperationType2["Unlock"] = 1] = "Unlock";
    LockOperationType2[LockOperationType2["NonAccessUserEvent"] = 2] = "NonAccessUserEvent";
    LockOperationType2[LockOperationType2["ForcedUserEvent"] = 3] = "ForcedUserEvent";
    LockOperationType2[LockOperationType2["Unlatch"] = 4] = "Unlatch";
  })(LockOperationType = DoorLock2.LockOperationType || (DoorLock2.LockOperationType = {}));
  DoorLock2.TlvLockOperationEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the type of the lock operation that was performed.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.3.1
     */
    lockOperationType: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the source of the lock operation that was performed.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.3.2
     */
    operationSource: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the UserIndex who performed the lock operation. This shall be null if there is no
     * user index that can be determined for the given operation source. This shall NOT be null if a user index can
     * be determined. In particular, this shall NOT be null if the operation was associated with a valid credential.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.3.3
     */
    userIndex: (0, import_TlvObject.TlvField)(2, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16)),
    /**
     * This field shall indicate the fabric index of the fabric that performed the lock operation. This shall be
     * null if there is no fabric that can be determined for the given operation source. This shall NOT be null if
     * the operation source is "Remote".
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.3.4
     */
    fabricIndex: (0, import_TlvObject.TlvField)(3, (0, import_TlvNullable.TlvNullable)(import_FabricIndex.TlvFabricIndex)),
    /**
     * This field shall indicate the Node ID of the node that performed the lock operation. This shall be null if
     * there is no Node associated with the given operation source. This shall NOT be null if the operation source
     * is "Remote".
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.3.5
     */
    sourceNode: (0, import_TlvObject.TlvField)(4, (0, import_TlvNullable.TlvNullable)(import_NodeId.TlvNodeId)),
    /**
     * This field shall indicate the list of credentials used in performing the lock operation. This shall be null
     * if no credentials were involved.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.3.6
     */
    credentials: (0, import_TlvObject.TlvOptionalField)(5, (0, import_TlvNullable.TlvNullable)((0, import_TlvArray.TlvArray)(DoorLock2.TlvCredential, { minLength: 1 })))
  });
  let OperationError;
  ((OperationError2) => {
    OperationError2[OperationError2["Unspecified"] = 0] = "Unspecified";
    OperationError2[OperationError2["InvalidCredential"] = 1] = "InvalidCredential";
    OperationError2[OperationError2["DisabledUserDenied"] = 2] = "DisabledUserDenied";
    OperationError2[OperationError2["Restricted"] = 3] = "Restricted";
    OperationError2[OperationError2["InsufficientBattery"] = 4] = "InsufficientBattery";
  })(OperationError = DoorLock2.OperationError || (DoorLock2.OperationError = {}));
  DoorLock2.TlvLockOperationErrorEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the type of the lock operation that was performed.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.4.1
     */
    lockOperationType: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the source of the lock operation that was performed.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.4.2
     */
    operationSource: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the lock operation error triggered when the operation was performed.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.4.3
     */
    operationError: (0, import_TlvObject.TlvField)(2, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the lock UserIndex who performed the lock operation. This shall be null if there
     * is no user id that can be determined for the given operation source.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.4.4
     */
    userIndex: (0, import_TlvObject.TlvField)(3, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16)),
    /**
     * This field shall indicate the fabric index of the fabric that performed the lock operation. This shall be
     * null if there is no fabric that can be determined for the given operation source. This shall NOT be null if
     * the operation source is "Remote".
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.4.5
     */
    fabricIndex: (0, import_TlvObject.TlvField)(4, (0, import_TlvNullable.TlvNullable)(import_FabricIndex.TlvFabricIndex)),
    /**
     * This field shall indicate the Node ID of the node that performed the lock operation. This shall be null if
     * there is no Node associated with the given operation source. This shall NOT be null if the operation source
     * is "Remote".
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.4.6
     */
    sourceNode: (0, import_TlvObject.TlvField)(5, (0, import_TlvNullable.TlvNullable)(import_NodeId.TlvNodeId)),
    /**
     * This field shall indicate the list of credentials used in performing the lock operation. This shall be null
     * if no credentials were involved.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.4.7
     */
    credentials: (0, import_TlvObject.TlvOptionalField)(6, (0, import_TlvNullable.TlvNullable)((0, import_TlvArray.TlvArray)(DoorLock2.TlvCredential, { minLength: 1 })))
  });
  let OperationEventCode;
  ((OperationEventCode2) => {
    OperationEventCode2[OperationEventCode2["UnknownOrMfgSpecific"] = 0] = "UnknownOrMfgSpecific";
    OperationEventCode2[OperationEventCode2["Lock"] = 1] = "Lock";
    OperationEventCode2[OperationEventCode2["Unlock"] = 2] = "Unlock";
    OperationEventCode2[OperationEventCode2["LockFailureInvalidPiNorRfid"] = 3] = "LockFailureInvalidPiNorRfid";
    OperationEventCode2[OperationEventCode2["LockFailureInvalidSchedule"] = 4] = "LockFailureInvalidSchedule";
    OperationEventCode2[OperationEventCode2["UnlockFailureInvalidPiNorRfid"] = 5] = "UnlockFailureInvalidPiNorRfid";
    OperationEventCode2[OperationEventCode2["UnlockFailureInvalidSchedule"] = 6] = "UnlockFailureInvalidSchedule";
    OperationEventCode2[OperationEventCode2["OneTouchLock"] = 7] = "OneTouchLock";
    OperationEventCode2[OperationEventCode2["KeyLock"] = 8] = "KeyLock";
    OperationEventCode2[OperationEventCode2["KeyUnlock"] = 9] = "KeyUnlock";
    OperationEventCode2[OperationEventCode2["AutoLock"] = 10] = "AutoLock";
    OperationEventCode2[OperationEventCode2["ScheduleLock"] = 11] = "ScheduleLock";
    OperationEventCode2[OperationEventCode2["ScheduleUnlock"] = 12] = "ScheduleUnlock";
    OperationEventCode2[OperationEventCode2["ManualLock"] = 13] = "ManualLock";
    OperationEventCode2[OperationEventCode2["ManualUnlock"] = 14] = "ManualUnlock";
    OperationEventCode2[OperationEventCode2["NonAccessUserOperationEvent"] = 15] = "NonAccessUserOperationEvent";
  })(OperationEventCode = DoorLock2.OperationEventCode || (DoorLock2.OperationEventCode = {}));
  let ProgrammingEventCode;
  ((ProgrammingEventCode2) => {
    ProgrammingEventCode2[ProgrammingEventCode2["UnknownOrMfgSpecific"] = 0] = "UnknownOrMfgSpecific";
    ProgrammingEventCode2[ProgrammingEventCode2["ProgrammingCodeChanged"] = 1] = "ProgrammingCodeChanged";
    ProgrammingEventCode2[ProgrammingEventCode2["PinCodeAdded"] = 2] = "PinCodeAdded";
    ProgrammingEventCode2[ProgrammingEventCode2["PinCodeCleared"] = 3] = "PinCodeCleared";
    ProgrammingEventCode2[ProgrammingEventCode2["PinCodeChanged"] = 4] = "PinCodeChanged";
    ProgrammingEventCode2[ProgrammingEventCode2["RfidCodeAdded"] = 5] = "RfidCodeAdded";
    ProgrammingEventCode2[ProgrammingEventCode2["RfidCodeCleared"] = 6] = "RfidCodeCleared";
  })(ProgrammingEventCode = DoorLock2.ProgrammingEventCode || (DoorLock2.ProgrammingEventCode = {}));
  let StatusCode;
  ((StatusCode2) => {
    StatusCode2[StatusCode2["Duplicate"] = 2] = "Duplicate";
    StatusCode2[StatusCode2["Occupied"] = 3] = "Occupied";
  })(StatusCode = DoorLock2.StatusCode || (DoorLock2.StatusCode = {}));
  DoorLock2.DoorPositionSensorComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the current door state as defined in DoorStateEnum.
       *
       * Null only if an internal error prevents the retrieval of the current door state.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.5
       */
      doorState: (0, import_Cluster.Attribute)(3, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
      /**
       * This attribute shall hold the number of door open events that have occurred since it was last zeroed.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.6
       */
      doorOpenEvents: (0, import_Cluster.OptionalWritableAttribute)(4, import_TlvNumber.TlvUInt32, { writeAcl: import_model.AccessLevel.Manage }),
      /**
       * This attribute shall hold the number of door closed events that have occurred since it was last zeroed.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.7
       */
      doorClosedEvents: (0, import_Cluster.OptionalWritableAttribute)(5, import_TlvNumber.TlvUInt32, { writeAcl: import_model.AccessLevel.Manage }),
      /**
       * This attribute shall hold the number of minutes the door has been open since the last time it
       * transitioned from closed to open.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.8
       */
      openPeriod: (0, import_Cluster.OptionalWritableAttribute)(6, import_TlvNumber.TlvUInt16, { writeAcl: import_model.AccessLevel.Manage })
    },
    events: {
      /**
       * The door lock server sends out a DoorStateChange event when the door lock door state changes.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.2
       */
      doorStateChange: (0, import_Cluster.Event)(1, import_Cluster.EventPriority.Critical, DoorLock2.TlvDoorStateChangeEvent)
    }
  });
  DoorLock2.LoggingComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the number of available log records.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.9
       */
      numberOfLogRecordsSupported: (0, import_Cluster.FixedAttribute)(16, import_TlvNumber.TlvUInt16, { default: 0 }),
      /**
       * This attribute shall enable/disable event logging.
       *
       * When event logging is enabled, all event messages are stored on the lock for retrieval. Logging events
       * can be, but are not limited to, Tamper Alarm, Lock, Unlock, AutoRelock, User Code Added, User Code
       * Cleared, Schedule Added, and Schedule Cleared. For a full detail of all the possible alarms and events,
       * please refer to the full list in the Alarm and Event Masks Attribute Set.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.22
       */
      enableLogging: (0, import_Cluster.WritableAttribute)(32, import_TlvBoolean.TlvBoolean, { default: true, writeAcl: import_model.AccessLevel.Administer })
    },
    commands: {
      /**
       * Request a log record. Log number is between 1 – [Number of Log Records Supported attribute]. If log
       * number 0 is requested then the most recent log entry is returned.
       *
       * Log record format: The log record format is defined in the description of the GetLogRecordResponse
       * command.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.4
       */
      getLogRecord: (0, import_Cluster.Command)(
        4,
        DoorLock2.TlvGetLogRecordRequest,
        4,
        DoorLock2.TlvGetLogRecordResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      )
    }
  });
  DoorLock2.UserComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the number of total users supported by the lock.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.10
       */
      numberOfTotalUsersSupported: (0, import_Cluster.FixedAttribute)(17, import_TlvNumber.TlvUInt16, { default: 0 }),
      /**
       * This attribute shall contain a bitmap with the bits set for the values of CredentialRuleEnum supported
       * on this device.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.20
       */
      credentialRulesSupport: (0, import_Cluster.FixedAttribute)(
        27,
        (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt8, DoorLock2.CredentialRules),
        { default: (0, import_BitmapSchema.BitsFromPartial)(DoorLock2.CredentialRules, { single: true }) }
      ),
      /**
       * Indicates the number of credentials that could be assigned for each user.
       *
       * Depending on the value of NumberOfRFIDUsersSupported and NumberOfPINUsersSupported it may not be
       * possible to assign that number of credentials for a user.
       *
       * For example, if the device supports only PIN and RFID credential types,
       * NumberOfCredentialsSupportedPerUser is set to 10, NumberOfPINUsersSupported is set to 5 and
       * NumberOfRFIDUsersSupported is set to 3, it will not be possible to actually assign 10 credentials for a
       * user because maximum number of credentials in the database is 8.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.21
       */
      numberOfCredentialsSupportedPerUser: (0, import_Cluster.FixedAttribute)(28, import_TlvNumber.TlvUInt8, { default: 0 }),
      /**
       * Indicates the number of minutes a PIN, RFID, Fingerprint, or other credential associated with a user of
       * type ExpiringUser shall remain valid after its first use before expiring. When the credential expires
       * the UserStatus for the corresponding user record shall be set to OccupiedDisabled.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.39
       */
      expiringUserTimeout: (0, import_Cluster.OptionalWritableAttribute)(
        53,
        import_TlvNumber.TlvUInt16.bound({ min: 1, max: 2880 }),
        { writeAcl: import_model.AccessLevel.Administer }
      )
    },
    commands: {
      /**
       * Set user into the lock.
       *
       * Fields used for different use cases:
       *
       * Return status is a global status code or a cluster-specific status code from the Status Codes table and
       *
       * shall be one of the following values:
       *
       *   • SUCCESS, if setting User was successful.
       *
       *   • FAILURE, if some unexpected internal error occurred setting User.
       *
       *   • OCCUPIED, if OperationType is Add and UserIndex points to an occupied slot.
       *
       *   • INVALID_COMMAND, if one or more fields violate constraints or are invalid or if OperationType is
       *     Modify and UserIndex points to an available slot.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.34
       */
      setUser: (0, import_Cluster.Command)(
        26,
        DoorLock2.TlvSetUserRequest,
        26,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer, timed: true }
      ),
      /**
       * Retrieve user.
       *
       * An InvokeResponse command shall be sent with an appropriate error
       *
       * COMMAND, etc.) as needed otherwise the GetUserResponse Command shall be sent implying a status of
       * SUCCESS.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.35
       */
      getUser: (0, import_Cluster.Command)(27, DoorLock2.TlvGetUserRequest, 28, DoorLock2.TlvGetUserResponse, { invokeAcl: import_model.AccessLevel.Administer }),
      /**
       * Clears a user or all Users.
       *
       * For each user to clear, all associated credentials (e.g. PIN, RFID, fingerprint, etc.) shall be cleared
       * and the user entry values shall be reset to their default values (e.g. UserStatus shall be Available,
       * UserType shall be UnrestrictedUser) and all associated schedules shall be cleared.
       *
       * A LockUserChange event with the provided UserIndex shall be generated after successfully clearing users.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.37
       */
      clearUser: (0, import_Cluster.Command)(
        29,
        DoorLock2.TlvClearUserRequest,
        29,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer, timed: true }
      ),
      /**
       * Set a credential (e.g. PIN, RFID, Fingerprint, etc.) into the lock for a new user, existing user, or
       * ProgrammingUser.
       *
       * Fields used for different use cases:
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.40
       */
      setCredential: (0, import_Cluster.Command)(
        34,
        DoorLock2.TlvSetCredentialRequest,
        35,
        DoorLock2.TlvSetCredentialResponse,
        { invokeAcl: import_model.AccessLevel.Administer, timed: true }
      ),
      /**
       * Retrieve the status of a particular credential (e.g. PIN, RFID, Fingerprint, etc.) by index.
       *
       * An InvokeResponse command shall be sent with an appropriate error (e.g. FAILURE, INVALID_COMMAND, etc.)
       * as needed otherwise the GetCredentialStatusResponse command shall be sent implying a status of SUCCESS.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.42
       */
      getCredentialStatus: (0, import_Cluster.Command)(
        36,
        DoorLock2.TlvGetCredentialStatusRequest,
        37,
        DoorLock2.TlvGetCredentialStatusResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * Clear one, one type, or all credentials except ProgrammingPIN credential.
       *
       * Fields used for different use cases:
       *
       * For each credential cleared whose user doesn’t have another valid credential, the corresponding user
       * record shall be reset back to default values and its UserStatus value shall be set to Available and
       * UserType value shall be set to UnrestrictedUser and all schedules shall be cleared. In
       *
       * this case a LockUserChange event shall be generated for the user being cleared. Return status shall be
       * one of the following values:
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.44
       */
      clearCredential: (0, import_Cluster.Command)(
        38,
        DoorLock2.TlvClearCredentialRequest,
        38,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer, timed: true }
      )
    },
    events: {
      /**
       * The door lock server sends out a LockUserChange event when a lock user, schedule, or credential change
       * has occurred.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.5
       */
      lockUserChange: (0, import_Cluster.Event)(4, import_Cluster.EventPriority.Info, DoorLock2.TlvLockUserChangeEvent)
    }
  });
  DoorLock2.PinCredentialComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the number of PIN users supported.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.11
       */
      numberOfPinUsersSupported: (0, import_Cluster.FixedAttribute)(18, import_TlvNumber.TlvUInt16, { default: 0 }),
      /**
       * Indicates the maximum length in bytes of a PIN Code on this device.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.16
       */
      maxPinCodeLength: (0, import_Cluster.FixedAttribute)(23, import_TlvNumber.TlvUInt8),
      /**
       * Indicates the minimum length in bytes of a PIN Code on this device.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.17
       */
      minPinCodeLength: (0, import_Cluster.FixedAttribute)(24, import_TlvNumber.TlvUInt8)
    }
  });
  DoorLock2.RfidCredentialComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the number of RFID users supported.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.12
       */
      numberOfRfidUsersSupported: (0, import_Cluster.FixedAttribute)(19, import_TlvNumber.TlvUInt16, { default: 0 }),
      /**
       * Indicates the maximum length in bytes of a RFID Code on this device. The value depends on the RFID code
       * range specified by the manufacturer, if media anti-collision identifiers (UID) are used as RFID code, a
       * value of 20 (equals 10 Byte ISO 14443A UID) is recommended.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.18
       */
      maxRfidCodeLength: (0, import_Cluster.FixedAttribute)(25, import_TlvNumber.TlvUInt8),
      /**
       * Indicates the minimum length in bytes of a RFID Code on this device. The value depends on the RFID code
       * range specified by the manufacturer, if media anti-collision identifiers (UID) are used as RFID code, a
       * value of 8 (equals 4 Byte ISO 14443A UID) is recommended.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.19
       */
      minRfidCodeLength: (0, import_Cluster.FixedAttribute)(26, import_TlvNumber.TlvUInt8)
    }
  });
  DoorLock2.WeekDayAccessSchedulesComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the number of configurable week day schedule supported per user.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.13
       */
      numberOfWeekDaySchedulesSupportedPerUser: (0, import_Cluster.FixedAttribute)(20, import_TlvNumber.TlvUInt8, { default: 0 })
    },
    commands: {
      /**
       * Set a weekly repeating schedule for a specified user.
       *
       * † The Schedule ID and User ID are obsolete field names, use WeekDayIndex and UserIndex instead,
       * respectively.
       *
       * The associated UserType may be changed to ScheduleRestrictedUser by the lock when a Week Day schedule is
       * set.
       *
       * Return status shall be one of the following values:
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.14
       */
      setWeekDaySchedule: (0, import_Cluster.Command)(
        11,
        DoorLock2.TlvSetWeekDayScheduleRequest,
        11,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * Retrieve the specific weekly schedule for the specific user.
       *
       * † The Schedule ID and User ID are obsolete field names, use WeekDayIndex and UserIndex instead,
       * respectively.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.15
       */
      getWeekDaySchedule: (0, import_Cluster.Command)(
        12,
        DoorLock2.TlvGetWeekDayScheduleRequest,
        12,
        DoorLock2.TlvGetWeekDayScheduleResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * Clear the specific weekly schedule or all weekly schedules for the specific user.
       *
       * † The Schedule ID and User ID are obsolete field names, use WeekDayIndex and UserIndex instead,
       * respectively.
       *
       * Return status shall be one of the following values:
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.17
       */
      clearWeekDaySchedule: (0, import_Cluster.Command)(
        13,
        DoorLock2.TlvClearWeekDayScheduleRequest,
        13,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      )
    }
  });
  DoorLock2.YearDayAccessSchedulesComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the number of configurable year day schedule supported per user.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.14
       */
      numberOfYearDaySchedulesSupportedPerUser: (0, import_Cluster.FixedAttribute)(21, import_TlvNumber.TlvUInt8, { default: 0 })
    },
    commands: {
      /**
       * Set a time-specific schedule ID for a specified user.
       *
       * † The Schedule ID and User ID are obsolete field names, use YearDayIndex and UserIndex instead,
       * respectively.
       *
       * The associated UserType may be changed to ScheduleRestrictedUser by the lock when a Year Day schedule is
       * set.
       *
       * Return status shall be one of the following values:
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.18
       */
      setYearDaySchedule: (0, import_Cluster.Command)(
        14,
        DoorLock2.TlvSetYearDayScheduleRequest,
        14,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * Retrieve the specific year day schedule for the specific schedule and user indexes.
       *
       * † The Schedule ID and User ID are obsolete field names, use YearDayIndex and UserIndex instead,
       * respectively.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.19
       */
      getYearDaySchedule: (0, import_Cluster.Command)(
        15,
        DoorLock2.TlvGetYearDayScheduleRequest,
        15,
        DoorLock2.TlvGetYearDayScheduleResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * Clears the specific year day schedule or all year day schedules for the specific user.
       *
       * † The Schedule ID and User ID are obsolete field names, use YearDayIndex and UserIndex instead,
       * respectively.
       *
       * Return status shall be one of the following values:
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.21
       */
      clearYearDaySchedule: (0, import_Cluster.Command)(
        16,
        DoorLock2.TlvClearYearDayScheduleRequest,
        16,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      )
    }
  });
  DoorLock2.HolidaySchedulesComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the number of holiday schedules supported for the entire door lock device.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.15
       */
      numberOfHolidaySchedulesSupported: (0, import_Cluster.FixedAttribute)(22, import_TlvNumber.TlvUInt8, { default: 0 })
    },
    commands: {
      /**
       * Set the holiday Schedule by specifying local start time and local end time with respect to any Lock
       * Operating Mode.
       *
       * † The Holiday Schedule ID is an obsolete field name, use HolidayIndex instead. Return status shall be
       * one of the following values:
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.22
       */
      setHolidaySchedule: (0, import_Cluster.Command)(
        17,
        DoorLock2.TlvSetHolidayScheduleRequest,
        17,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * Get the holiday schedule for the specified index.
       *
       * † The Holiday Schedule ID is an obsolete field name, use HolidayIndex instead.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.23
       */
      getHolidaySchedule: (0, import_Cluster.Command)(
        18,
        DoorLock2.TlvGetHolidayScheduleRequest,
        18,
        DoorLock2.TlvGetHolidayScheduleResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * Clears the holiday schedule or all holiday schedules.
       *
       * † The Holiday Schedule ID is an obsolete field name, use HolidayIndex instead.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.25
       */
      clearHolidaySchedule: (0, import_Cluster.Command)(
        19,
        DoorLock2.TlvClearHolidayScheduleRequest,
        19,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      )
    }
  });
  DoorLock2.PinCredentialOrRfidCredentialComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the number of incorrect Pin codes or RFID presentment attempts a user is allowed to enter
       * before the lock will enter a lockout state. The value of this attribute is compared to all failing forms
       * of credential presentation, including Pin codes used in an Unlock Command when
       * RequirePINforRemoteOperation is set to true. Valid range is 1-255 incorrect attempts. The lockout state
       * will be for the duration of UserCodeTemporaryDisableTime. If the attribute accepts writes and an attempt
       * to write the value 0 is made, the device shall respond with CONSTRAINT_ERROR.
       *
       * The lock may reset the counter used to track incorrect credential presentations as required by internal
       * logic, environmental events, or other reasons. The lock shall reset the counter if a valid credential is
       * presented.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.35
       */
      wrongCodeEntryLimit: (0, import_Cluster.WritableAttribute)(
        48,
        import_TlvNumber.TlvUInt8.bound({ min: 1 }),
        { writeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * Indicates the number of seconds that the lock shuts down following wrong code entry. Valid range is
       * 1-255 seconds. Device can shut down to lock user out for specified amount of time. (Makes it difficult
       * to try and guess a PIN for the device.) If the attribute accepts writes and an attempt to write the
       * attribute to 0 is made, the device shall respond with CONSTRAINT_ERROR.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.36
       */
      userCodeTemporaryDisableTime: (0, import_Cluster.WritableAttribute)(
        49,
        import_TlvNumber.TlvUInt8.bound({ min: 1 }),
        { writeAcl: import_model.AccessLevel.Administer }
      )
    }
  });
  DoorLock2.PinCredentialNotUserComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the door locks ability to send PINs over the air. If the attribute is True it is ok for the
       * door lock server to send PINs over the air. This attribute determines the behavior of the server’s TX
       * operation. If it is false, then it is not ok for the device to send PIN in any messages over the air.
       *
       * The PIN field within any door lock cluster message shall keep the first octet unchanged and masks the
       * actual code by replacing with 0xFF. For example (PIN "1234" ): If the attribute value is True, 0x04 0x31
       * 0x32 0x33 0x34 shall be used in the PIN field in any door lock cluster message payload. If the attribute
       * value is False, 0x04 0xFF 0xFF 0xFF 0xFF shall be used.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.37
       */
      sendPinOverTheAir: (0, import_Cluster.OptionalWritableAttribute)(
        50,
        import_TlvBoolean.TlvBoolean,
        { default: true, writeAcl: import_model.AccessLevel.Administer }
      )
    },
    commands: {
      /**
       * Set a PIN Code into the lock.
       *
       * Return status is a global status code or a cluster-specific status code from the Status Codes table and
       * shall be one of the following values:
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.6
       */
      setPinCode: (0, import_Cluster.Command)(
        5,
        DoorLock2.TlvSetPinCodeRequest,
        5,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer, timed: true }
      ),
      /**
       * Retrieve a PIN Code.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.7
       */
      getPinCode: (0, import_Cluster.Command)(
        6,
        DoorLock2.TlvGetPinCodeRequest,
        6,
        DoorLock2.TlvGetPinCodeResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * Clear a PIN code or all PIN codes.
       *
       * † The User ID is an obsolete field name, use PINSlotIndex instead.
       *
       * For each PIN Code cleared whose user doesn’t have a RFID Code or other credential type, then
       * corresponding user record’s UserStatus value shall be set to Available, and UserType value shall be set
       * to UnrestrictedUser and all schedules shall be cleared.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.9
       */
      clearPinCode: (0, import_Cluster.Command)(
        7,
        DoorLock2.TlvClearPinCodeRequest,
        7,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer, timed: true }
      ),
      /**
       * Clear out all PINs on the lock.
       *
       * NOTE
       *
       * On the server, the clear all PIN codes command SHOULD have the same effect as the ClearPINCode command
       * with respect to the setting of user status, user type and schedules.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.10
       */
      clearAllPinCodes: (0, import_Cluster.Command)(
        8,
        import_TlvNoArguments.TlvNoArguments,
        8,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer, timed: true }
      )
    }
  });
  DoorLock2.CredentialOverTheAirAccessAndPinCredentialComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates if the door lock requires an optional PIN. If this attribute is set to True, the door lock
       * server requires that an optional PINs be included in the payload of remote lock operation events like
       * Lock, Unlock, Unlock with Timeout and Toggle in order to function.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.38
       */
      requirePinForRemoteOperation: (0, import_Cluster.WritableAttribute)(
        51,
        import_TlvBoolean.TlvBoolean,
        { default: true, writeAcl: import_model.AccessLevel.Administer }
      )
    }
  });
  DoorLock2.NotificationAndPinCredentialComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Event mask used to turn on and off the transmission of keypad operation events. This mask DOES NOT apply
       * to the storing of events in the event log. This mask only applies to the Operation Event Notification
       * Command.
       *
       * This mask DOES NOT apply to the Events mechanism of this cluster.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.41
       */
      keypadOperationEventMask: (0, import_Cluster.OptionalWritableAttribute)(
        65,
        (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt16, DoorLock2.EventMask),
        {
          default: (0, import_BitmapSchema.BitsFromPartial)(DoorLock2.EventMask, { bit0: true, bit1: true, bit2: true, bit3: true, bit4: true, bit5: true, bit6: true, bit7: true, bit8: true, bit9: true, bit10: true, bit11: true, bit12: true, bit13: true, bit14: true, bit15: true }),
          writeAcl: import_model.AccessLevel.Administer
        }
      ),
      /**
       * Event mask used to turn on and off keypad programming events. This mask DOES NOT apply to the storing of
       * events in the event log. This mask only applies to the Programming Event Notification Command.
       *
       * This mask DOES NOT apply to the Events mechanism of this cluster.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.45
       */
      keypadProgrammingEventMask: (0, import_Cluster.OptionalWritableAttribute)(
        69,
        (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt16, DoorLock2.KeypadProgrammingEventMask),
        {
          default: (0, import_BitmapSchema.BitsFromPartial)(DoorLock2.KeypadProgrammingEventMask, { unknown: true, pinCodeChanged: true, pinAdded: true, pinCleared: true, pinChanged: true, bit5: true, bit6: true, bit7: true, bit8: true, bit9: true, bit10: true, bit11: true, bit12: true, bit13: true, bit14: true, bit15: true }),
          writeAcl: import_model.AccessLevel.Administer
        }
      )
    }
  });
  DoorLock2.NotificationComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Event mask used to turn on and off the transmission of remote operation events. This mask DOES NOT apply
       * to the storing of events in the event log. This mask only applies to the Operation Event Notification
       * Command.
       *
       * This mask DOES NOT apply to the Events mechanism of this cluster.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.42
       */
      remoteOperationEventMask: (0, import_Cluster.OptionalWritableAttribute)(
        66,
        (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt16, DoorLock2.EventMask),
        {
          default: (0, import_BitmapSchema.BitsFromPartial)(DoorLock2.EventMask, { bit0: true, bit1: true, bit2: true, bit3: true, bit4: true, bit5: true, bit6: true, bit7: true, bit8: true, bit9: true, bit10: true, bit11: true, bit12: true, bit13: true, bit14: true, bit15: true }),
          writeAcl: import_model.AccessLevel.Administer
        }
      ),
      /**
       * Event mask used to turn on and off manual operation events. This mask DOES NOT apply to the storing of
       * events in the event log. This mask only applies to the Operation Event Notification Command.
       *
       * This mask DOES NOT apply to the Events mechanism of this cluster.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.43
       */
      manualOperationEventMask: (0, import_Cluster.OptionalWritableAttribute)(
        67,
        (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt16, DoorLock2.EventMask),
        {
          default: (0, import_BitmapSchema.BitsFromPartial)(DoorLock2.EventMask, { bit0: true, bit1: true, bit2: true, bit3: true, bit4: true, bit5: true, bit6: true, bit7: true, bit8: true, bit9: true, bit10: true, bit11: true, bit12: true, bit13: true, bit14: true, bit15: true }),
          writeAcl: import_model.AccessLevel.Administer
        }
      ),
      /**
       * Event mask used to turn on and off remote programming events. This mask DOES NOT apply to the storing of
       * events in the event log. This mask only applies to the Programming Event Notification Command.
       *
       * This mask DOES NOT apply to the Events mechanism of this cluster.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.46
       */
      remoteProgrammingEventMask: (0, import_Cluster.OptionalWritableAttribute)(
        70,
        (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt16, DoorLock2.RemoteProgrammingEventMask),
        {
          default: (0, import_BitmapSchema.BitsFromPartial)(DoorLock2.RemoteProgrammingEventMask, { unknown: true, bit1: true, pinAdded: true, pinCleared: true, pinChanged: true, rfidCodeAdded: true, rfidCodeCleared: true, bit7: true, bit8: true, bit9: true, bit10: true, bit11: true, bit12: true, bit13: true, bit14: true, bit15: true }),
          writeAcl: import_model.AccessLevel.Administer
        }
      )
    }
  });
  DoorLock2.NotificationAndRfidCredentialComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Event mask used to turn on and off RFID operation events. This mask DOES NOT apply to the storing of
       * events in the event log. This mask only applies to the Operation Event Notification Command.
       *
       * This mask DOES NOT apply to the Events mechanism of this cluster.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.44
       */
      rfidOperationEventMask: (0, import_Cluster.OptionalWritableAttribute)(
        68,
        (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt16, DoorLock2.EventMask),
        {
          default: (0, import_BitmapSchema.BitsFromPartial)(DoorLock2.EventMask, { bit0: true, bit1: true, bit2: true, bit3: true, bit4: true, bit5: true, bit6: true, bit7: true, bit8: true, bit9: true, bit10: true, bit11: true, bit12: true, bit13: true, bit14: true, bit15: true }),
          writeAcl: import_model.AccessLevel.Administer
        }
      ),
      /**
       * Event mask used to turn on and off RFID programming events. This mask DOES NOT apply to the storing of
       * events in the event log. This mask only applies to the Programming Event Notification Command.
       *
       * This mask DOES NOT apply to the Events mechanism of this cluster.
       *
       * This mask DOES NOT apply to the Events mechanism of this cluster.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.47
       */
      rfidProgrammingEventMask: (0, import_Cluster.OptionalWritableAttribute)(
        71,
        (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt16, DoorLock2.RfidProgrammingEventMask),
        {
          default: (0, import_BitmapSchema.BitsFromPartial)(DoorLock2.RfidProgrammingEventMask, { unknown: true, bit1: true, bit2: true, bit3: true, bit4: true, idAdded: true, idCleared: true, bit7: true, bit8: true, bit9: true, bit10: true, bit11: true, bit12: true, bit13: true, bit14: true, bit15: true }),
          writeAcl: import_model.AccessLevel.Administer
        }
      )
    }
  });
  DoorLock2.PinCredentialAndRfidCredentialAndFingerCredentialsNotUserComponent = import_MutableCluster.MutableCluster.Component({
    commands: {
      /**
       * Set the status of a user ID.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.11
       */
      setUserStatus: (0, import_Cluster.OptionalCommand)(
        9,
        DoorLock2.TlvSetUserStatusRequest,
        9,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * Get the status of a user.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.12
       */
      getUserStatus: (0, import_Cluster.OptionalCommand)(
        10,
        DoorLock2.TlvGetUserStatusRequest,
        10,
        DoorLock2.TlvGetUserStatusResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * Set the user type for a specified user.
       *
       * For user type value please refer to User Type Value.
       *
       * Return status shall be one of the following values:
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.26
       */
      setUserType: (0, import_Cluster.OptionalCommand)(
        20,
        DoorLock2.TlvSetUserTypeRequest,
        20,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * Retrieve the user type for a specific user.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.27
       */
      getUserType: (0, import_Cluster.OptionalCommand)(
        21,
        DoorLock2.TlvGetUserTypeRequest,
        21,
        DoorLock2.TlvGetUserTypeResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      )
    }
  });
  DoorLock2.NotUserComponent = import_MutableCluster.MutableCluster.Component({});
  DoorLock2.RfidCredentialNotUserComponent = import_MutableCluster.MutableCluster.Component({
    commands: {
      /**
       * Set an ID for RFID access into the lock.
       *
       * Return status is a global status code or a cluster-specific status code from the Status Codes table and
       * shall be one of the following values:
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.29
       */
      setRfidCode: (0, import_Cluster.Command)(
        22,
        DoorLock2.TlvSetRfidCodeRequest,
        22,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer, timed: true }
      ),
      /**
       * Retrieve an RFID code.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.30
       */
      getRfidCode: (0, import_Cluster.Command)(
        23,
        DoorLock2.TlvGetRfidCodeRequest,
        23,
        DoorLock2.TlvGetRfidCodeResponse,
        { invokeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * Clear an RFID code or all RFID codes.
       *
       * † The User ID is an obsolete field name, use RFIDSlotIndex instead.
       *
       * For each RFID Code cleared whose user doesn’t have a PIN Code or other credential type, then the
       * corresponding user record’s UserStatus value shall be set to Available, and UserType value shall be set
       * to UnrestrictedUser and all schedules shall be cleared.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.32
       */
      clearRfidCode: (0, import_Cluster.Command)(
        24,
        DoorLock2.TlvClearRfidCodeRequest,
        24,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer, timed: true }
      ),
      /**
       * Clear out all RFIDs on the lock. If you clear all RFID codes and this user didn’t have a PIN code, the
       * user status has to be set to "0 Available", the user type has to be set to the default value, and all
       * schedules which are supported have to be set to the default values.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.33
       */
      clearAllRfidCodes: (0, import_Cluster.Command)(
        25,
        import_TlvNoArguments.TlvNoArguments,
        25,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Administer, timed: true }
      )
    }
  });
  DoorLock2.UnboltingComponent = import_MutableCluster.MutableCluster.Component({
    commands: {
      /**
       * This command causes the lock device to unlock the door without pulling the latch. This command includes
       * an optional code for the lock. The door lock may require a code depending on the value of the
       * RequirePINForRemoteOperation attribute.
       *
       * NOTE
       *
       * If the attribute AutoRelockTime is supported, the lock will transition to the locked state when the auto
       * relock time has expired.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.45
       */
      unboltDoor: (0, import_Cluster.Command)(39, DoorLock2.TlvUnboltDoorRequest, 39, import_Cluster.TlvNoResponse, { timed: true })
    }
  });
  DoorLock2.Base = import_MutableCluster.MutableCluster.Component({
    id: 257,
    name: "DoorLock",
    revision: 7,
    features: {
      /**
       * PinCredential
       *
       * If the User Feature is also supported then any PIN Code stored in the lock shall be associated with a
       * User.
       *
       * A lock may support multiple credential types so if the User feature is supported the UserType,
       * UserStatus and Schedules are all associated with a User index and not directly with a PIN index. A User
       * index may have several credentials associated with it.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.4.1
       */
      pinCredential: (0, import_BitmapSchema.BitFlag)(0),
      /**
       * RfidCredential
       *
       * If the User Feature is also supported then any RFID credential stored in the lock shall be associated
       * with a User.
       *
       * A lock may support multiple credential types so if the User feature is supported the UserType,
       * UserStatus and Schedules are all associated with a User index and not directly with a RFID index. A User
       *
       * Index may have several credentials associated with it.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.4.2
       */
      rfidCredential: (0, import_BitmapSchema.BitFlag)(1),
      /**
       * FingerCredentials
       *
       * Currently the cluster only defines the metadata format for notifications when a fingerprint/ finger vein
       * credential is used to access the lock and doesn’t describe how to create fingerprint/finger vein
       * credentials. If the Users feature is also supported then the User that a fingerprint/finger vein is
       * associated with can also have its UserType, UserStatus and Schedule modified.
       *
       * A lock may support multiple credential types so if the User feature is supported the UserType,
       * UserStatus and Schedules are all associated with a User index and not directly with a Finger index. A
       * User Index may have several credentials associated with it.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.4.3
       */
      fingerCredentials: (0, import_BitmapSchema.BitFlag)(2),
      /**
       * Logging
       *
       * If Events are not supported the logging feature shall replace the Event reporting structure. If Events
       * are supported the logging feature shall NOT be supported.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.4.4
       */
      logging: (0, import_BitmapSchema.BitFlag)(3),
      /**
       * WeekDayAccessSchedules
       *
       * If the User feature is supported then Week Day Schedules are applied to a User and not a credential.
       *
       * Week Day Schedules are used to restrict access to a specified time window on certain days of the week.
       * The schedule is repeated each week. When a schedule is cleared this clears the access restrictions and
       * grants unrestricted access to the user. The lock may automatically adjust the UserType when a schedule
       * is created or cleared.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.4.5
       */
      weekDayAccessSchedules: (0, import_BitmapSchema.BitFlag)(4),
      /**
       * DoorPositionSensor
       *
       * If this feature is supported this indicates that the lock has the ability to determine the position of
       * the door which is separate from the state of the lock.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.4.6
       */
      doorPositionSensor: (0, import_BitmapSchema.BitFlag)(5),
      /**
       * FaceCredentials
       *
       * Currently the cluster only defines the metadata format for notifications when a face recognition, iris,
       * or retina credential is used to access the lock and doesn’t describe how to create face recognition,
       * iris, or retina credentials. If the Users feature is also supported then the User that a face
       * recognition, iris, or retina credential is associated with can also have its UserType, UserStatus and
       * Schedule modified.
       *
       * A lock may support multiple credential types so if the User feature is supported the UserType,
       * UserStatus and Schedules are all associated with a User and not directly with a credential.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.4.7
       */
      faceCredentials: (0, import_BitmapSchema.BitFlag)(6),
      /**
       * CredentialOverTheAirAccess
       *
       * If this feature is supported then the lock supports the ability to verify a credential provided in a
       * lock/unlock command. Currently the cluster only supports providing the PIN credential to the lock/unlock
       * commands. If this feature is supported then the PIN Credential feature shall also be supported.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.4.8
       */
      credentialOverTheAirAccess: (0, import_BitmapSchema.BitFlag)(7),
      /**
       * User
       *
       * If the User Feature is supported then a lock employs a User database. A User within the User database is
       * used to associate credentials and schedules to single user record within the lock. This also means the
       * UserType and UserStatus fields are associated with a User and not a credential.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.4.9
       */
      user: (0, import_BitmapSchema.BitFlag)(8),
      /**
       * Notification
       *
       * This is a feature used before support of events. This feature supports notification commands and masks
       * used to filter these notifications.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.4.10
       */
      notification: (0, import_BitmapSchema.BitFlag)(9),
      /**
       * YearDayAccessSchedules
       *
       * If the User feature is supported then Year Day Schedules are applied to a User and not a credential.
       *
       * Year Day Schedules are used to restrict access to a specified date and time window. When a schedule is
       * cleared this clears the access restrictions and grants unrestricted access to the user. The lock may
       * automatically adjust the UserType when a schedule is created or cleared.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.4.11
       */
      yearDayAccessSchedules: (0, import_BitmapSchema.BitFlag)(10),
      /**
       * HolidaySchedules
       *
       * This feature is used to setup Holiday Schedule in the lock device. A Holiday Schedule sets a start and
       * stop end date/time for the lock to use the specified operating mode set by the Holiday Schedule.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.4.12
       */
      holidaySchedules: (0, import_BitmapSchema.BitFlag)(11),
      /**
       * Unbolting
       *
       * Locks that support this feature differentiate between unbolting and unlocking. The Unbolt Door command
       * retracts the bolt without pulling the latch. The Unlock Door command fully unlocks the door by
       * retracting the bolt and briefly pulling the latch. While the latch is pulled, the lock state changes to
       * Unlatched. Locks without unbolting support don’t differentiate between unbolting and unlocking and
       * perform the same operation for both commands.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.4.13
       */
      unbolting: (0, import_BitmapSchema.BitFlag)(12)
    },
    attributes: {
      /**
       * This attribute may be NULL if the lock hardware does not currently know the status of the locking
       * mechanism. For example, a lock may not know the LockState status after a power cycle until the first
       * lock actuation is completed.
       *
       * The Not Fully Locked value is used by a lock to indicate that the state of the lock is somewhere between
       * Locked and Unlocked so it is only partially secured. For example, a deadbolt could be partially extended
       * and not in a dead latched state.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.2
       */
      lockState: (0, import_Cluster.Attribute)(0, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)()), { scene: true }),
      /**
       * Indicates the type of door lock as defined in LockTypeEnum.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.3
       */
      lockType: (0, import_Cluster.Attribute)(1, (0, import_TlvNumber.TlvEnum)()),
      /**
       * Indicates if the lock is currently able to (Enabled) or not able to (Disabled) process remote Lock,
       * Unlock, or Unlock with Timeout commands.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.4
       */
      actuatorEnabled: (0, import_Cluster.Attribute)(2, import_TlvBoolean.TlvBoolean),
      /**
       * Indicates the language for the on-screen or audible user interface using a 2- byte language code from
       * ISO-639-1.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.23
       */
      language: (0, import_Cluster.OptionalWritableAttribute)(
        33,
        import_TlvString.TlvString.bound({ maxLength: 3 }),
        { writeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * Indicates the settings for the LED support, as defined by LEDSettingEnum.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.24
       */
      ledSettings: (0, import_Cluster.OptionalWritableAttribute)(
        34,
        (0, import_TlvNumber.TlvEnum)(),
        { default: 0 /* NoLedSignal */, writeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * Indicates the number of seconds to wait after unlocking a lock before it automatically locks again.
       * 0=disabled. If set, unlock operations from any source will be timed. For one time unlock with timeout
       * use the specific command.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.25
       */
      autoRelockTime: (0, import_Cluster.OptionalWritableAttribute)(35, import_TlvNumber.TlvUInt32, { writeAcl: import_model.AccessLevel.Manage }),
      /**
       * Indicates the sound volume on a door lock as defined by SoundVolumeEnum.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.26
       */
      soundVolume: (0, import_Cluster.OptionalWritableAttribute)(
        36,
        (0, import_TlvNumber.TlvEnum)(),
        { default: 0 /* Silent */, writeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * Indicates the current operating mode of the lock as defined in OperatingModeEnum.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.27
       */
      operatingMode: (0, import_Cluster.WritableAttribute)(
        37,
        (0, import_TlvNumber.TlvEnum)(),
        { default: 0 /* Normal */, writeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * This attribute shall contain a bitmap with all operating bits of the OperatingMode attribute supported
       * by the lock. All operating modes NOT supported by a lock shall be set to one. The value of the
       * OperatingMode enumeration defines the related bit to be set.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.28
       */
      supportedOperatingModes: (0, import_Cluster.FixedAttribute)(
        38,
        (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt16, DoorLock2.OperatingModes),
        { default: (0, import_BitmapSchema.BitsFromPartial)(DoorLock2.OperatingModes, { vacation: true, privacy: true, passage: true }) }
      ),
      /**
       * Indicates the default configurations as they are physically set on the device (example: hardware dip
       * switch setting, etc…) and represents the default setting for some of the attributes within this cluster
       * (for example: LED, Auto Lock, Sound Volume, and Operating Mode attributes).
       *
       * This is a read-only attribute and is intended to allow clients to determine what changes may need to be
       * made without having to query all the included attributes. It may be beneficial for the clients to know
       * what the device’s original settings were in the event that the device needs to be restored to factory
       * default settings.
       *
       * If the Client device would like to query and modify the door lock server’s operating settings, it SHOULD
       * send read and write attribute requests to the specific attributes.
       *
       * For example, the Sound Volume attribute default value is Silent Mode. However, it is possible that the
       * current Sound Volume is High Volume. Therefore, if the client wants to query/modify the current Sound
       * Volume setting on the server, the client SHOULD read/write to the Sound Volume attribute.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.29
       */
      defaultConfigurationRegister: (0, import_Cluster.OptionalAttribute)(39, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt16, DoorLock2.ConfigurationRegister)),
      /**
       * This attribute shall enable/disable local programming on the door lock of certain features (see
       * LocalProgrammingFeatures attribute). If this value is set to TRUE then local programming is enabled on
       * the door lock for all features. If it is set to FALSE then local programming is disabled on the door
       * lock for those features whose bit is set to 0 in the LocalProgrammingFeatures attribute. Local
       * programming shall be enabled by default.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.30
       */
      enableLocalProgramming: (0, import_Cluster.OptionalWritableAttribute)(
        40,
        import_TlvBoolean.TlvBoolean,
        { default: true, writeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * This attribute shall enable/disable the ability to lock the door lock with a single touch on the door
       * lock.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.31
       */
      enableOneTouchLocking: (0, import_Cluster.OptionalWritableAttribute)(
        41,
        import_TlvBoolean.TlvBoolean,
        { default: true, writeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * This attribute shall enable/disable an inside LED that allows the user to see at a glance if the door is
       * locked.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.32
       */
      enableInsideStatusLed: (0, import_Cluster.OptionalWritableAttribute)(
        42,
        import_TlvBoolean.TlvBoolean,
        { default: true, writeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * This attribute shall enable/disable a button inside the door that is used to put the lock into privacy
       * mode. When the lock is in privacy mode it cannot be manipulated from the outside.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.33
       */
      enablePrivacyModeButton: (0, import_Cluster.OptionalWritableAttribute)(
        43,
        import_TlvBoolean.TlvBoolean,
        { default: true, writeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * Indicates the local programming features that will be disabled when EnableLocalProgramming attribute is
       * set to False. If a door lock doesn’t support disabling one aspect of local programming it shall return
       * CONSTRAINT_ERROR during a write operation of this attribute. If the EnableLocalProgramming attribute is
       * set to True then all local programming features shall be enabled regardless of the bits set to 0 in this
       * attribute.
       *
       * The features that can be disabled from local programming are defined in LocalProgrammingFeaturesBitmap.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.34
       */
      localProgrammingFeatures: (0, import_Cluster.OptionalWritableAttribute)(
        44,
        (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt8, DoorLock2.LocalProgrammingFeatures),
        { writeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * This attribute is only supported if the Alarms cluster is on the same endpoint. The alarm mask is used
       * to turn on/off alarms for particular functions. Alarms for an alarm group are enabled if the associated
       * alarm mask bit is set. Each bit represents a group of alarms. Entire alarm groups can be turned on or
       * off by setting or clearing the associated bit in the alarm mask.
       *
       * This mask DOES NOT apply to the Events mechanism of this cluster.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.9.40
       */
      alarmMask: (0, import_Cluster.OptionalWritableAttribute)(
        64,
        (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt16, DoorLock2.AlarmMask),
        {
          default: (0, import_BitmapSchema.BitsFromPartial)(DoorLock2.AlarmMask, { lockJammed: true, lockFactoryReset: true, na: true, lockRadioPowerCycled: true, wrongCodeEntryLimit: true, frontEscutcheonRemoved: true, doorForcedOpen: true }),
          writeAcl: import_model.AccessLevel.Administer
        }
      )
    },
    commands: {
      /**
       * This command causes the lock device to lock the door. This command includes an optional code for the
       * lock. The door lock may require a PIN depending on the value of the RequirePINForRemoteOperation
       * attribute.
       *
       * † The PIN/RFID Code is an obsolete field name, use PINCode instead.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.1
       */
      lockDoor: (0, import_Cluster.Command)(0, DoorLock2.TlvLockDoorRequest, 0, import_Cluster.TlvNoResponse, { timed: true }),
      /**
       * This command causes the lock device to unlock the door. This command includes an optional code for the
       * lock. The door lock may require a code depending on the value of the RequirePINForRemoteOperation
       * attribute.
       *
       * NOTE
       *
       * If the attribute AutoRelockTime is supported the lock will transition to the locked state when the auto
       * relock time has expired.
       *
       * † The PIN/RFID Code is an obsolete field name, use PINCode instead.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.2
       */
      unlockDoor: (0, import_Cluster.Command)(1, DoorLock2.TlvUnlockDoorRequest, 1, import_Cluster.TlvNoResponse, { timed: true }),
      /**
       * This command causes the lock device to unlock the door with a timeout parameter. After the time in
       * seconds specified in the timeout field, the lock device will relock itself automatically. This timeout
       * parameter is only temporary for this message transition and overrides the default relock time
       *
       * as specified in the AutoRelockTime attribute. If the door lock device is not capable of or does not want
       * to support temporary Relock Timeout, it SHOULD NOT support this optional command.
       *
       * † The PIN/RFID Code is an obsolete field name, use PINCode instead.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.10.3
       */
      unlockWithTimeout: (0, import_Cluster.OptionalCommand)(3, DoorLock2.TlvUnlockWithTimeoutRequest, 3, import_Cluster.TlvNoResponse, { timed: true })
    },
    events: {
      /**
       * The door lock server provides several alarms which can be sent when there is a critical state on the
       * door lock. The alarms available for the door lock server are listed in AlarmCodeEnum.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.1
       */
      doorLockAlarm: (0, import_Cluster.Event)(0, import_Cluster.EventPriority.Critical, DoorLock2.TlvDoorLockAlarmEvent),
      /**
       * The door lock server sends out a LockOperation event when the event is triggered by the various lock
       * operation sources.
       *
       *   • If the door lock server supports the Unbolt Door command, it shall generate a LockOperation event
       *     with LockOperationType set to Unlock after an Unbolt Door command succeeds.
       *
       *   • If the door lock server supports the Unbolting feature and an Unlock Door command is performed, it
       *     shall generate a LockOperation event with LockOperationType set to Unlatch when the unlatched state
       *     is reached and a LockOperation event with LockOperationType set to Unlock when the lock successfully
       *     completes the unlock → hold latch → release latch and return to unlock state operation.
       *
       *   • If the command fails during holding or releasing the latch but after passing the unlocked state, the
       *     door lock server shall generate a LockOperationError event with LockOperationType set to Unlatch and
       *     a LockOperation event with LockOperationType set to Unlock.
       *
       *     ◦ If it fails before reaching the unlocked state, the door lock server shall generate only a
       *       LockOperationError event with LockOperationType set to Unlock.
       *
       *   • Upon manual actuation, a door lock server that supports the Unbolting feature:
       *
       *     ◦ shall generate a LockOperation event of LockOperationType Unlatch when it is actuated from the
       *       outside.
       *
       *     ◦ may generate a LockOperation event of LockOperationType Unlatch when it is actuated from the
       *       inside.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.3
       */
      lockOperation: (0, import_Cluster.Event)(2, import_Cluster.EventPriority.Critical, DoorLock2.TlvLockOperationEvent),
      /**
       * The door lock server sends out a LockOperationError event when a lock operation fails for various
       * reasons.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 5.2.11.4
       */
      lockOperationError: (0, import_Cluster.Event)(3, import_Cluster.EventPriority.Critical, DoorLock2.TlvLockOperationErrorEvent)
    },
    /**
     * This metadata controls which DoorLockCluster elements matter.js activates for specific feature combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { doorPositionSensor: true }, component: DoorLock2.DoorPositionSensorComponent },
      { flags: { logging: true }, component: DoorLock2.LoggingComponent },
      { flags: { user: true }, component: DoorLock2.UserComponent },
      { flags: { pinCredential: true }, component: DoorLock2.PinCredentialComponent },
      { flags: { rfidCredential: true }, component: DoorLock2.RfidCredentialComponent },
      { flags: { weekDayAccessSchedules: true }, component: DoorLock2.WeekDayAccessSchedulesComponent },
      { flags: { yearDayAccessSchedules: true }, component: DoorLock2.YearDayAccessSchedulesComponent },
      { flags: { holidaySchedules: true }, component: DoorLock2.HolidaySchedulesComponent },
      { flags: { pinCredential: true }, component: DoorLock2.PinCredentialOrRfidCredentialComponent },
      { flags: { rfidCredential: true }, component: DoorLock2.PinCredentialOrRfidCredentialComponent },
      { flags: { pinCredential: true, user: false }, component: DoorLock2.PinCredentialNotUserComponent },
      {
        flags: { credentialOverTheAirAccess: true, pinCredential: true },
        component: DoorLock2.CredentialOverTheAirAccessAndPinCredentialComponent
      },
      { flags: { notification: true, pinCredential: true }, component: DoorLock2.NotificationAndPinCredentialComponent },
      { flags: { notification: true }, component: DoorLock2.NotificationComponent },
      { flags: { notification: true, rfidCredential: true }, component: DoorLock2.NotificationAndRfidCredentialComponent },
      {
        flags: { pinCredential: true, rfidCredential: true, fingerCredentials: true, user: false },
        component: DoorLock2.PinCredentialAndRfidCredentialAndFingerCredentialsNotUserComponent
      },
      { flags: { user: false }, component: DoorLock2.NotUserComponent },
      { flags: { rfidCredential: true, user: false }, component: DoorLock2.RfidCredentialNotUserComponent },
      { flags: { unbolting: true }, component: DoorLock2.UnboltingComponent },
      {
        flags: {
          user: true,
          pinCredential: true,
          rfidCredential: true,
          fingerCredentials: true,
          faceCredentials: true
        },
        component: false
      }
    )
  });
  DoorLock2.ClusterInstance = (0, import_MutableCluster.MutableCluster)({ ...DoorLock2.Base, base: (0, import_ClusterType.ClusterType)(DoorLock2.Base) }, DoorLock2.NotUserComponent);
  DoorLock2.Cluster = DoorLock2.ClusterInstance;
  const DPS = { doorPositionSensor: true };
  const LOG = { logging: true };
  const USR = { user: true };
  const PIN = { pinCredential: true };
  const RID = { rfidCredential: true };
  const WDSCH = { weekDayAccessSchedules: true };
  const YDSCH = { yearDayAccessSchedules: true };
  const HDSCH = { holidaySchedules: true };
  const PIN_NOT_USR = { pinCredential: true, user: false };
  const COTA_PIN = { credentialOverTheAirAccess: true, pinCredential: true };
  const NOT_PIN = { notification: true, pinCredential: true };
  const NOT = { notification: true };
  const NOT_RID = { notification: true, rfidCredential: true };
  const PIN_RID_FGP_NOT_USR = { pinCredential: true, rfidCredential: true, fingerCredentials: true, user: false };
  const RID_NOT_USR = { rfidCredential: true, user: false };
  const UBOLT = { unbolting: true };
  DoorLock2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: DoorLock2.Cluster.id,
    name: DoorLock2.Cluster.name,
    revision: DoorLock2.Cluster.revision,
    features: DoorLock2.Cluster.features,
    attributes: {
      ...DoorLock2.Cluster.attributes,
      doorState: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.DoorPositionSensorComponent.attributes.doorState,
        { mandatoryIf: [DPS] }
      ),
      doorOpenEvents: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.DoorPositionSensorComponent.attributes.doorOpenEvents,
        { optionalIf: [DPS] }
      ),
      doorClosedEvents: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.DoorPositionSensorComponent.attributes.doorClosedEvents,
        { optionalIf: [DPS] }
      ),
      openPeriod: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.DoorPositionSensorComponent.attributes.openPeriod,
        { optionalIf: [DPS] }
      ),
      numberOfLogRecordsSupported: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.LoggingComponent.attributes.numberOfLogRecordsSupported,
        { mandatoryIf: [LOG] }
      ),
      numberOfTotalUsersSupported: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.UserComponent.attributes.numberOfTotalUsersSupported,
        { mandatoryIf: [USR] }
      ),
      numberOfPinUsersSupported: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.PinCredentialComponent.attributes.numberOfPinUsersSupported,
        { mandatoryIf: [PIN] }
      ),
      numberOfRfidUsersSupported: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.RfidCredentialComponent.attributes.numberOfRfidUsersSupported,
        { mandatoryIf: [RID] }
      ),
      numberOfWeekDaySchedulesSupportedPerUser: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.WeekDayAccessSchedulesComponent.attributes.numberOfWeekDaySchedulesSupportedPerUser,
        { mandatoryIf: [WDSCH] }
      ),
      numberOfYearDaySchedulesSupportedPerUser: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.YearDayAccessSchedulesComponent.attributes.numberOfYearDaySchedulesSupportedPerUser,
        { mandatoryIf: [YDSCH] }
      ),
      numberOfHolidaySchedulesSupported: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.HolidaySchedulesComponent.attributes.numberOfHolidaySchedulesSupported,
        { mandatoryIf: [HDSCH] }
      ),
      maxPinCodeLength: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.PinCredentialComponent.attributes.maxPinCodeLength,
        { mandatoryIf: [PIN] }
      ),
      minPinCodeLength: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.PinCredentialComponent.attributes.minPinCodeLength,
        { mandatoryIf: [PIN] }
      ),
      maxRfidCodeLength: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.RfidCredentialComponent.attributes.maxRfidCodeLength,
        { mandatoryIf: [RID] }
      ),
      minRfidCodeLength: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.RfidCredentialComponent.attributes.minRfidCodeLength,
        { mandatoryIf: [RID] }
      ),
      credentialRulesSupport: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.UserComponent.attributes.credentialRulesSupport,
        { mandatoryIf: [USR] }
      ),
      numberOfCredentialsSupportedPerUser: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.UserComponent.attributes.numberOfCredentialsSupportedPerUser,
        { mandatoryIf: [USR] }
      ),
      enableLogging: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.LoggingComponent.attributes.enableLogging,
        { mandatoryIf: [LOG] }
      ),
      wrongCodeEntryLimit: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.PinCredentialOrRfidCredentialComponent.attributes.wrongCodeEntryLimit,
        { mandatoryIf: [PIN, RID] }
      ),
      userCodeTemporaryDisableTime: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.PinCredentialOrRfidCredentialComponent.attributes.userCodeTemporaryDisableTime,
        { mandatoryIf: [PIN, RID] }
      ),
      sendPinOverTheAir: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.PinCredentialNotUserComponent.attributes.sendPinOverTheAir,
        { optionalIf: [PIN_NOT_USR] }
      ),
      requirePinForRemoteOperation: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.CredentialOverTheAirAccessAndPinCredentialComponent.attributes.requirePinForRemoteOperation,
        { mandatoryIf: [COTA_PIN] }
      ),
      expiringUserTimeout: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.UserComponent.attributes.expiringUserTimeout,
        { optionalIf: [USR] }
      ),
      keypadOperationEventMask: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.NotificationAndPinCredentialComponent.attributes.keypadOperationEventMask,
        { optionalIf: [NOT_PIN] }
      ),
      remoteOperationEventMask: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.NotificationComponent.attributes.remoteOperationEventMask,
        { optionalIf: [NOT] }
      ),
      manualOperationEventMask: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.NotificationComponent.attributes.manualOperationEventMask,
        { optionalIf: [NOT] }
      ),
      rfidOperationEventMask: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.NotificationAndRfidCredentialComponent.attributes.rfidOperationEventMask,
        { optionalIf: [NOT_RID] }
      ),
      keypadProgrammingEventMask: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.NotificationAndPinCredentialComponent.attributes.keypadProgrammingEventMask,
        { optionalIf: [NOT_PIN] }
      ),
      remoteProgrammingEventMask: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.NotificationComponent.attributes.remoteProgrammingEventMask,
        { optionalIf: [NOT] }
      ),
      rfidProgrammingEventMask: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.NotificationAndRfidCredentialComponent.attributes.rfidProgrammingEventMask,
        { optionalIf: [NOT_RID] }
      )
    },
    commands: {
      ...DoorLock2.Cluster.commands,
      getLogRecord: import_MutableCluster.MutableCluster.AsConditional(DoorLock2.LoggingComponent.commands.getLogRecord, { mandatoryIf: [LOG] }),
      setPinCode: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.PinCredentialNotUserComponent.commands.setPinCode,
        { mandatoryIf: [PIN_NOT_USR] }
      ),
      getPinCode: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.PinCredentialNotUserComponent.commands.getPinCode,
        { mandatoryIf: [PIN_NOT_USR] }
      ),
      clearPinCode: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.PinCredentialNotUserComponent.commands.clearPinCode,
        { mandatoryIf: [PIN_NOT_USR] }
      ),
      clearAllPinCodes: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.PinCredentialNotUserComponent.commands.clearAllPinCodes,
        { mandatoryIf: [PIN_NOT_USR] }
      ),
      setUserStatus: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.PinCredentialAndRfidCredentialAndFingerCredentialsNotUserComponent.commands.setUserStatus,
        { optionalIf: [PIN_RID_FGP_NOT_USR] }
      ),
      getUserStatus: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.PinCredentialAndRfidCredentialAndFingerCredentialsNotUserComponent.commands.getUserStatus,
        { optionalIf: [PIN_RID_FGP_NOT_USR] }
      ),
      setWeekDaySchedule: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.WeekDayAccessSchedulesComponent.commands.setWeekDaySchedule,
        { mandatoryIf: [WDSCH] }
      ),
      getWeekDaySchedule: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.WeekDayAccessSchedulesComponent.commands.getWeekDaySchedule,
        { mandatoryIf: [WDSCH] }
      ),
      clearWeekDaySchedule: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.WeekDayAccessSchedulesComponent.commands.clearWeekDaySchedule,
        { mandatoryIf: [WDSCH] }
      ),
      setYearDaySchedule: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.YearDayAccessSchedulesComponent.commands.setYearDaySchedule,
        { mandatoryIf: [YDSCH] }
      ),
      getYearDaySchedule: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.YearDayAccessSchedulesComponent.commands.getYearDaySchedule,
        { mandatoryIf: [YDSCH] }
      ),
      clearYearDaySchedule: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.YearDayAccessSchedulesComponent.commands.clearYearDaySchedule,
        { mandatoryIf: [YDSCH] }
      ),
      setHolidaySchedule: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.HolidaySchedulesComponent.commands.setHolidaySchedule,
        { mandatoryIf: [HDSCH] }
      ),
      getHolidaySchedule: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.HolidaySchedulesComponent.commands.getHolidaySchedule,
        { mandatoryIf: [HDSCH] }
      ),
      clearHolidaySchedule: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.HolidaySchedulesComponent.commands.clearHolidaySchedule,
        { mandatoryIf: [HDSCH] }
      ),
      setUserType: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.PinCredentialAndRfidCredentialAndFingerCredentialsNotUserComponent.commands.setUserType,
        { optionalIf: [PIN_RID_FGP_NOT_USR] }
      ),
      getUserType: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.PinCredentialAndRfidCredentialAndFingerCredentialsNotUserComponent.commands.getUserType,
        { optionalIf: [PIN_RID_FGP_NOT_USR] }
      ),
      setRfidCode: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.RfidCredentialNotUserComponent.commands.setRfidCode,
        { mandatoryIf: [RID_NOT_USR] }
      ),
      getRfidCode: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.RfidCredentialNotUserComponent.commands.getRfidCode,
        { mandatoryIf: [RID_NOT_USR] }
      ),
      clearRfidCode: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.RfidCredentialNotUserComponent.commands.clearRfidCode,
        { mandatoryIf: [RID_NOT_USR] }
      ),
      clearAllRfidCodes: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.RfidCredentialNotUserComponent.commands.clearAllRfidCodes,
        { mandatoryIf: [RID_NOT_USR] }
      ),
      setUser: import_MutableCluster.MutableCluster.AsConditional(DoorLock2.UserComponent.commands.setUser, { mandatoryIf: [USR] }),
      getUser: import_MutableCluster.MutableCluster.AsConditional(DoorLock2.UserComponent.commands.getUser, { mandatoryIf: [USR] }),
      clearUser: import_MutableCluster.MutableCluster.AsConditional(DoorLock2.UserComponent.commands.clearUser, { mandatoryIf: [USR] }),
      setCredential: import_MutableCluster.MutableCluster.AsConditional(DoorLock2.UserComponent.commands.setCredential, { mandatoryIf: [USR] }),
      getCredentialStatus: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.UserComponent.commands.getCredentialStatus,
        { mandatoryIf: [USR] }
      ),
      clearCredential: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.UserComponent.commands.clearCredential,
        { mandatoryIf: [USR] }
      ),
      unboltDoor: import_MutableCluster.MutableCluster.AsConditional(DoorLock2.UnboltingComponent.commands.unboltDoor, { mandatoryIf: [UBOLT] })
    },
    events: {
      ...DoorLock2.Cluster.events,
      doorStateChange: import_MutableCluster.MutableCluster.AsConditional(
        DoorLock2.DoorPositionSensorComponent.events.doorStateChange,
        { mandatoryIf: [DPS] }
      ),
      lockUserChange: import_MutableCluster.MutableCluster.AsConditional(DoorLock2.UserComponent.events.lockUserChange, { mandatoryIf: [USR] })
    }
  });
  DoorLock2.Complete = DoorLock2.CompleteInstance;
})(DoorLock || (DoorLock = {}));
const DoorLockCluster = DoorLock.Cluster;
import_ClusterRegistry.ClusterRegistry.register(DoorLock.Complete);
//# sourceMappingURL=door-lock.js.map
