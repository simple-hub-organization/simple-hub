/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/*** THIS FILE IS GENERATED, DO NOT EDIT ***/
import { MutableCluster } from "../cluster/mutation/MutableCluster.js";
import { Attribute, OptionalFixedAttribute, OptionalAttribute, WritableAttribute, OptionalWritableAttribute, FixedAttribute, Command } from "../cluster/Cluster.js";
import { BitFlag, BitField } from "../schema/BitmapSchema.js";
import { TypeFromSchema } from "../tlv/TlvSchema.js";
import { Identity } from "#general";
export declare namespace Thermostat {
    /**
     * These are optional features supported by ThermostatCluster.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.4
     */
    enum Feature {
        /**
         * Heating (HEAT)
         *
         * Thermostat is capable of managing a heating device
         */
        Heating = "Heating",
        /**
         * Cooling (COOL)
         *
         * Thermostat is capable of managing a cooling device
         */
        Cooling = "Cooling",
        /**
         * Occupancy (OCC)
         *
         * Supports Occupied and Unoccupied setpoints
         */
        Occupancy = "Occupancy",
        /**
         * ScheduleConfiguration (SCH)
         *
         * Supports remote configuration of a weekly schedule of setpoint transitions
         */
        ScheduleConfiguration = "ScheduleConfiguration",
        /**
         * Setback (SB)
         *
         * Supports configurable setback (or span)
         */
        Setback = "Setback",
        /**
         * AutoMode (AUTO)
         *
         * Supports a System Mode of Auto
         */
        AutoMode = "AutoMode",
        /**
         * LocalTemperatureNotExposed (LTNE)
         *
         * This feature indicates that the Calculated Local Temperature used internally is unavailable to report
         * externally, for example due to the temperature control being done by a separate subsystem which does not
         * offer a view into the currently measured temperature, but allows setpoints to be provided.
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.4.1
         */
        LocalTemperatureNotExposed = "LocalTemperatureNotExposed"
    }
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.22
     */
    enum ThermostatRunningMode {
        /**
         * The Thermostat does not generate demand for Cooling or Heating
         */
        Off = 0,
        /**
         * Demand is only generated for Cooling
         */
        Cool = 3,
        /**
         * Demand is only generated for Heating
         */
        Heat = 4
    }
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.20
     */
    enum StartOfWeek {
        Sunday = 0,
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6
    }
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.10
     */
    const ScheduleDayOfWeek: {
        /**
         * Sunday
         */
        sunday: BitFlag;
        /**
         * Monday
         */
        monday: BitFlag;
        /**
         * Tuesday
         */
        tuesday: BitFlag;
        /**
         * Wednesday
         */
        wednesday: BitFlag;
        /**
         * Thursday
         */
        thursday: BitFlag;
        /**
         * Friday
         */
        friday: BitFlag;
        /**
         * Saturday
         */
        saturday: BitFlag;
        /**
         * Away or Vacation
         */
        away: BitFlag;
    };
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.11
     */
    const ScheduleMode: {
        /**
         * Adjust Heat Setpoint
         */
        heatSetpointPresent: BitFlag;
        /**
         * Adjust Cool Setpoint
         */
        coolSetpointPresent: BitFlag;
    };
    /**
     * This represents a single transition in a Thermostat schedule
     *
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24
     */
    const TlvWeeklyScheduleTransition: import("../tlv/TlvObject.js").ObjectSchema<{
        /**
         * This field shall represent the start time of the schedule transition during the associated day. The time
         * will be represented by a 16 bits unsigned integer to designate the minutes since midnight. For example, 6am
         * will be represented by 360 minutes since midnight and 11:30pm will be represented by 1410 minutes since
         * midnight.
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.1
         */
        transitionTime: import("../tlv/TlvObject.js").FieldType<number>;
        /**
         * This field shall represent the heat setpoint to be applied at this associated transition start time.
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.2
         */
        heatSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
        /**
         * This field shall represent the cool setpoint to be applied at this associated transition start time.
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.3
         */
        coolSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
    }>;
    /**
     * This represents a single transition in a Thermostat schedule
     *
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24
     */
    interface WeeklyScheduleTransition extends TypeFromSchema<typeof TlvWeeklyScheduleTransition> {
    }
    /**
     * Input to the Thermostat setWeeklySchedule command
     *
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4
     */
    const TlvSetWeeklyScheduleRequest: import("../tlv/TlvObject.js").ObjectSchema<{
        /**
         * This field shall indicate how many individual transitions to expect for this sequence of commands. If a
         * device supports more than 10 transitions in its schedule they can send this by sending more than 1 “Set
         * Weekly Schedule” command, each containing the separate information that the device needs to set.
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.1
         */
        numberOfTransitionsForSequence: import("../tlv/TlvObject.js").FieldType<number>;
        /**
         * This field shall represent the day of the week at which all the transitions within the payload of the
         * command SHOULD be associated to. This field is a bitmap and therefore the associated setpoint could overlap
         * onto multiple days (you could set one transition time for all “week days” or whatever combination of days
         * the implementation requests).
         *
         * Each setpoint transition will begin with the day of week for this transition. There can be up to 10
         * transitions for each command.
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.2
         */
        dayOfWeekForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
            /**
             * Sunday
             */
            sunday: BitFlag;
            /**
             * Monday
             */
            monday: BitFlag;
            /**
             * Tuesday
             */
            tuesday: BitFlag;
            /**
             * Wednesday
             */
            wednesday: BitFlag;
            /**
             * Thursday
             */
            thursday: BitFlag;
            /**
             * Friday
             */
            friday: BitFlag;
            /**
             * Saturday
             */
            saturday: BitFlag;
            /**
             * Away or Vacation
             */
            away: BitFlag;
        }>>;
        /**
         * This field shall indicate how the application decodes the setpoint fields of each transition in the
         * Transitions list.
         *
         * If the HeatSetpointPresent bit is On, the HeatSetpoint field shall NOT be null in every entry of the
         * Transitions list.
         *
         * If the HeatSetpointPresent bit is Off, the HeatSetpoint field shall be null in every entry of the
         * Transitions list.
         *
         * If the CoolSetpointPresent bit is On, the CoolSetpoint field shall NOT be null in every entry of the
         * Transitions list.
         *
         * If the CoolSetpointPresent bit is Off, the CoolSetpoint field shall be null in every entry of the
         * Transitions list.
         *
         * At least one of the bits in the Mode For Sequence byte shall be on.
         *
         * Both bits must be respected, even if the HEAT or COOL feature is not supported, to ensure the command is
         * decoded and handled correctly.
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.3
         */
        modeForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
            /**
             * Adjust Heat Setpoint
             */
            heatSetpointPresent: BitFlag;
            /**
             * Adjust Cool Setpoint
             */
            coolSetpointPresent: BitFlag;
        }>>;
        /**
         * This field shall contain the list of setpoint transitions used to update the specified daily schedules
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.4
         */
        transitions: import("../tlv/TlvObject.js").FieldType<import("../tlv/TlvObject.js").TypeFromFields<{
            /**
             * This field shall represent the start time of the schedule transition during the associated day. The time
             * will be represented by a 16 bits unsigned integer to designate the minutes since midnight. For example, 6am
             * will be represented by 360 minutes since midnight and 11:30pm will be represented by 1410 minutes since
             * midnight.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.1
             */
            transitionTime: import("../tlv/TlvObject.js").FieldType<number>;
            /**
             * This field shall represent the heat setpoint to be applied at this associated transition start time.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.2
             */
            heatSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
            /**
             * This field shall represent the cool setpoint to be applied at this associated transition start time.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.3
             */
            coolSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
        }>[]>;
    }>;
    /**
     * Input to the Thermostat setWeeklySchedule command
     *
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4
     */
    interface SetWeeklyScheduleRequest extends TypeFromSchema<typeof TlvSetWeeklyScheduleRequest> {
    }
    /**
     * Input to the Thermostat getWeeklySchedule command
     *
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5
     */
    const TlvGetWeeklyScheduleRequest: import("../tlv/TlvObject.js").ObjectSchema<{
        /**
         * This field shall indicate the number of days the client would like to return the setpoint values for and
         * could be any combination of single days or the entire week.
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5.1
         */
        daysToReturn: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
            /**
             * Sunday
             */
            sunday: BitFlag;
            /**
             * Monday
             */
            monday: BitFlag;
            /**
             * Tuesday
             */
            tuesday: BitFlag;
            /**
             * Wednesday
             */
            wednesday: BitFlag;
            /**
             * Thursday
             */
            thursday: BitFlag;
            /**
             * Friday
             */
            friday: BitFlag;
            /**
             * Saturday
             */
            saturday: BitFlag;
            /**
             * Away or Vacation
             */
            away: BitFlag;
        }>>;
        /**
         * This field shall indicate the mode the client would like to return the set point values for and could be any
         * combination of heat only, cool only or heat & cool.
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5.2
         */
        modeToReturn: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
            /**
             * Adjust Heat Setpoint
             */
            heatSetpointPresent: BitFlag;
            /**
             * Adjust Cool Setpoint
             */
            coolSetpointPresent: BitFlag;
        }>>;
    }>;
    /**
     * Input to the Thermostat getWeeklySchedule command
     *
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5
     */
    interface GetWeeklyScheduleRequest extends TypeFromSchema<typeof TlvGetWeeklyScheduleRequest> {
    }
    /**
     * This command has the same payload format as the Set Weekly Schedule.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.6
     */
    const TlvGetWeeklyScheduleResponse: import("../tlv/TlvObject.js").ObjectSchema<{
        numberOfTransitionsForSequence: import("../tlv/TlvObject.js").FieldType<number>;
        dayOfWeekForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
            /**
             * Sunday
             */
            sunday: BitFlag;
            /**
             * Monday
             */
            monday: BitFlag;
            /**
             * Tuesday
             */
            tuesday: BitFlag;
            /**
             * Wednesday
             */
            wednesday: BitFlag;
            /**
             * Thursday
             */
            thursday: BitFlag;
            /**
             * Friday
             */
            friday: BitFlag;
            /**
             * Saturday
             */
            saturday: BitFlag;
            /**
             * Away or Vacation
             */
            away: BitFlag;
        }>>;
        modeForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
            /**
             * Adjust Heat Setpoint
             */
            heatSetpointPresent: BitFlag;
            /**
             * Adjust Cool Setpoint
             */
            coolSetpointPresent: BitFlag;
        }>>;
        transitions: import("../tlv/TlvObject.js").FieldType<import("../tlv/TlvObject.js").TypeFromFields<{
            /**
             * This field shall represent the start time of the schedule transition during the associated day. The time
             * will be represented by a 16 bits unsigned integer to designate the minutes since midnight. For example, 6am
             * will be represented by 360 minutes since midnight and 11:30pm will be represented by 1410 minutes since
             * midnight.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.1
             */
            transitionTime: import("../tlv/TlvObject.js").FieldType<number>;
            /**
             * This field shall represent the heat setpoint to be applied at this associated transition start time.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.2
             */
            heatSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
            /**
             * This field shall represent the cool setpoint to be applied at this associated transition start time.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.3
             */
            coolSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
        }>[]>;
    }>;
    /**
     * This command has the same payload format as the Set Weekly Schedule.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.6
     */
    interface GetWeeklyScheduleResponse extends TypeFromSchema<typeof TlvGetWeeklyScheduleResponse> {
    }
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6
     */
    const HvacSystemType: {
        /**
         * Stage of cooling the HVAC system is using.
         *
         * These bits shall indicate what stage of cooling the HVAC system is using.
         *
         *   • 00 = Cool Stage 1
         *
         *   • 01 = Cool Stage 2
         *
         *   • 10 = Cool Stage 3
         *
         *   • 11 = Reserved
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.1
         */
        coolingStage: BitField;
        /**
         * Stage of heating the HVAC system is using.
         *
         * These bits shall indicate what stage of heating the HVAC system is using.
         *
         *   • 00 = Heat Stage 1
         *
         *   • 01 = Heat Stage 2
         *
         *   • 10 = Heat Stage 3
         *
         *   • 11 = Reserved
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.2
         */
        heatingStage: BitField;
        /**
         * Is the heating type Heat Pump.
         *
         * This bit shall indicate whether the HVAC system is conventional or a heat pump.
         *
         *   • 0 = Conventional
         *
         *   • 1 = Heat Pump
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.3
         */
        heatingIsHeatPump: BitFlag;
        /**
         * Does the HVAC system use fuel.
         *
         * This bit shall indicate whether the HVAC system uses fuel.
         *
         *   • 0 = Does not use fuel
         *
         *   • 1 = Uses fuel
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.4
         */
        heatingUsesFuel: BitFlag;
    };
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.9
     */
    const RemoteSensing: {
        /**
         * Calculated Local Temperature is derived from a remote node
         */
        localTemperature: BitFlag;
        /**
         * OutdoorTemperature is derived from a remote node
         *
         * This bit shall be supported if the OutdoorTemperature attribute is supported.
         *
         * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.9.1
         */
        outdoorTemperature: BitFlag;
        /**
         * Occupancy is derived from a remote node
         */
        occupancy: BitFlag;
    };
    /**
     * NOTE
     *
     * CoolingAndHeating
     *
     * A thermostat indicating it supports CoolingAndHeating (or CoolingAndHeatingWithReheat) SHOULD be able to request
     * heating or cooling on demand and will usually support the Auto SystemMode.
     *
     * Systems which support cooling or heating, requiring external intervention to change modes or where the whole
     * building must be in the same mode, SHOULD report CoolingOnly or HeatingOnly based on the current capability.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.18
     */
    enum ControlSequenceOfOperation {
        /**
         * Heat and Emergency are not possible
         */
        CoolingOnly = 0,
        /**
         * Heat and Emergency are not possible
         */
        CoolingWithReheat = 1,
        /**
         * Cool and precooling (see Terms) are not possible
         */
        HeatingOnly = 2,
        /**
         * Cool and precooling are not possible
         */
        HeatingWithReheat = 3,
        /**
         * All modes are possible
         */
        CoolingAndHeating = 4,
        /**
         * All modes are possible
         */
        CoolingAndHeatingWithReheat = 5
    }
    /**
     * Table 35. Interpretation of Heat, Cool and Auto SystemModeEnum Values
     *
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.21
     */
    enum SystemMode {
        /**
         * The Thermostat does not generate demand for Cooling or Heating
         */
        Off = 0,
        /**
         * Demand is generated for either Cooling or Heating, as required
         */
        Auto = 1,
        /**
         * Demand is only generated for Cooling
         */
        Cool = 3,
        /**
         * Demand is only generated for Heating
         */
        Heat = 4,
        /**
         * 2nd stage heating is in use to achieve desired temperature
         */
        EmergencyHeat = 5,
        /**
         * (see Terms)
         */
        Precooling = 6,
        FanOnly = 7,
        Dry = 8,
        Sleep = 9
    }
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.23
     */
    enum TemperatureSetpointHold {
        /**
         * Follow scheduling program
         */
        SetpointHoldOff = 0,
        /**
         * Maintain current setpoint, regardless of schedule transitions
         */
        SetpointHoldOn = 1
    }
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.7
     */
    const ProgrammingOperationMode: {
        /**
         * Schedule programming mode. This enables any programmed weekly schedule configurations.
         */
        scheduleActive: BitFlag;
        /**
         * Auto/recovery mode
         */
        autoRecovery: BitFlag;
        /**
         * Economy/EnergyStar mode
         */
        economy: BitFlag;
    };
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.8
     */
    const RelayState: {
        /**
         * Heat State On
         */
        heat: BitFlag;
        /**
         * Cool State On
         */
        cool: BitFlag;
        /**
         * Fan State On
         */
        fan: BitFlag;
        /**
         * Heat 2nd State On
         */
        heatStage2: BitFlag;
        /**
         * Cool 2nd State On
         */
        coolStage2: BitFlag;
        /**
         * Fan 2nd State On
         */
        fanStage2: BitFlag;
        /**
         * Fan 3rd Stage On
         */
        fanStage3: BitFlag;
    };
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.19
     */
    enum SetpointChangeSource {
        /**
         * Manual, user-initiated setpoint change via the thermostat
         */
        Manual = 0,
        /**
         * Schedule/internal programming-initiated setpoint change
         */
        Schedule = 1,
        /**
         * Externally-initiated setpoint change (e.g., DRLC cluster command, attribute write)
         */
        External = 2
    }
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.16
     */
    enum AcType {
        /**
         * Unknown AC Type
         */
        Unknown = 0,
        /**
         * Cooling and Fixed Speed
         */
        CoolingFixed = 1,
        /**
         * Heat Pump and Fixed Speed
         */
        HeatPumpFixed = 2,
        /**
         * Cooling and Inverter
         */
        CoolingInverter = 3,
        /**
         * Heat Pump and Inverter
         */
        HeatPumpInverter = 4
    }
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.15
     */
    enum AcRefrigerantType {
        /**
         * Unknown Refrigerant Type
         */
        Unknown = 0,
        /**
         * R22 Refrigerant
         */
        R22 = 1,
        /**
         * R410a Refrigerant
         */
        R410A = 2,
        /**
         * R407c Refrigerant
         */
        R407C = 3
    }
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.13
     */
    enum AcCompressorType {
        /**
         * Unknown compressor type
         */
        Unknown = 0,
        /**
         * Max working ambient 43 °C
         */
        T1 = 1,
        /**
         * Max working ambient 35 °C
         */
        T2 = 2,
        /**
         * Max working ambient 52 °C
         */
        T3 = 3
    }
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.4
     */
    const AcErrorCode: {
        /**
         * Compressor Failure or Refrigerant Leakage
         */
        compressorFail: BitFlag;
        /**
         * Room Temperature Sensor Failure
         */
        roomSensorFail: BitFlag;
        /**
         * Outdoor Temperature Sensor Failure
         */
        outdoorSensorFail: BitFlag;
        /**
         * Indoor Coil Temperature Sensor Failure
         */
        coilSensorFail: BitFlag;
        /**
         * Fan Failure
         */
        fanFail: BitFlag;
    };
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.14
     */
    enum AcLouverPosition {
        /**
         * Fully Closed
         */
        Closed = 1,
        /**
         * Fully Open
         */
        Open = 2,
        /**
         * Quarter Open
         */
        Quarter = 3,
        /**
         * Half Open
         */
        Half = 4,
        /**
         * Three Quarters Open
         */
        ThreeQuarters = 5
    }
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.12
     */
    enum AcCapacityFormat {
        /**
         * British Thermal Unit per Hour
         */
        BtUh = 0
    }
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.17
     */
    enum SetpointRaiseLowerMode {
        /**
         * Adjust Heat Setpoint
         */
        Heat = 0,
        /**
         * Adjust Cool Setpoint
         */
        Cool = 1,
        /**
         * Adjust Heat Setpoint and Cool Setpoint
         */
        Both = 2
    }
    /**
     * Input to the Thermostat setpointRaiseLower command
     *
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.1
     */
    const TlvSetpointRaiseLowerRequest: import("../tlv/TlvObject.js").ObjectSchema<{
        mode: import("../tlv/TlvObject.js").FieldType<SetpointRaiseLowerMode>;
        amount: import("../tlv/TlvObject.js").FieldType<number>;
    }>;
    /**
     * Input to the Thermostat setpointRaiseLower command
     *
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.1
     */
    interface SetpointRaiseLowerRequest extends TypeFromSchema<typeof TlvSetpointRaiseLowerRequest> {
    }
    /**
     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.5
     */
    const AlarmCode: {
        /**
         * Initialization failure. The device failed to complete initialization at power-up.
         */
        initialization: BitFlag;
        /**
         * Hardware failure
         */
        hardware: BitFlag;
        /**
         * Self-calibration failure
         */
        selfCalibration: BitFlag;
    };
    /**
     * A ThermostatCluster supports these elements if it supports feature Occupancy.
     */
    const OccupancyComponent: {
        readonly attributes: {
            /**
             * Indicates whether the heated/cooled space is occupied or not, as measured locally or remotely (over the
             * network).
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.5
             */
            readonly occupancy: Attribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                occupied: BitFlag;
            }>, any>;
        };
    };
    /**
     * A ThermostatCluster supports these elements if it supports feature Heating.
     */
    const HeatingComponent: {
        readonly attributes: {
            /**
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9
             */
            readonly absMinHeatSetpointLimit: OptionalFixedAttribute<number, any>;
            /**
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9
             */
            readonly absMaxHeatSetpointLimit: OptionalFixedAttribute<number, any>;
            /**
             * Indicates the level of heating demanded by the PI loop in percent. This value is 0 when the thermostat
             * is in “off” or “cooling” mode.
             *
             * This attribute is reported regularly and may be used to control a heating device.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.11
             */
            readonly piHeatingDemand: OptionalAttribute<number, any>;
            /**
             * Indicates the heating mode setpoint when the room is occupied.
             *
             * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute such that these
             * constraints are violated, a response with the status code CONSTRAINT_ERROR shall be returned.
             *
             * If the occupancy status of the room is unknown, this attribute shall be used as the heating mode
             * setpoint.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.15
             */
            readonly occupiedHeatingSetpoint: WritableAttribute<number, any>;
            /**
             * Indicates the minimum level that the heating setpoint may be set to.
             *
             * This attribute, and the following three attributes, allow the user to define setpoint limits more
             * constrictive than the manufacturer imposed ones. Limiting users (e.g., in a commercial building) to such
             * setpoint limits can help conserve power.
             *
             * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
             * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
             * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
             * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
             * response with the status code CONSTRAINT_ERROR shall be returned.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.18
             */
            readonly minHeatSetpointLimit: OptionalWritableAttribute<number, any>;
            /**
             * Indicates the maximum level that the heating setpoint may be set to.
             *
             * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
             * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
             * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
             * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
             * response with the status code CONSTRAINT_ERROR shall be returned.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.19
             */
            readonly maxHeatSetpointLimit: OptionalWritableAttribute<number, any>;
        };
    };
    /**
     * A ThermostatCluster supports these elements if it supports feature Cooling.
     */
    const CoolingComponent: {
        readonly attributes: {
            /**
             * Indicates the absolute minimum level that the cooling setpoint may be set to. This is a limitation
             * imposed by the manufacturer.
             *
             * Refer to Setpoint Limits for constraints
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.8
             */
            readonly absMinCoolSetpointLimit: OptionalFixedAttribute<number, any>;
            /**
             * Indicates the absolute maximum level that the cooling setpoint may be set to. This is a limitation
             * imposed by the manufacturer.
             *
             * Refer to Setpoint Limits for constraints
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.9
             */
            readonly absMaxCoolSetpointLimit: OptionalFixedAttribute<number, any>;
            /**
             * Indicates the level of cooling demanded by the PI (proportional integral) control loop in use by the
             * thermostat (if any), in percent. This value is 0 when the thermostat is in “off” or “heating” mode.
             *
             * This attribute is reported regularly and may be used to control a cooling device.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.10
             */
            readonly piCoolingDemand: OptionalAttribute<number, any>;
            /**
             * Indicates the cooling mode setpoint when the room is occupied.
             *
             * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute such that these
             * constraints are violated, a response with the status code CONSTRAINT_ERROR shall be returned.
             *
             * If the occupancy status of the room is unknown, this attribute shall be used as the cooling mode
             * setpoint.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.14
             */
            readonly occupiedCoolingSetpoint: WritableAttribute<number, any>;
            /**
             * Indicates the minimum level that the cooling setpoint may be set to.
             *
             * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
             * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
             * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
             * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
             * response with the status code CONSTRAINT_ERROR shall be returned.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.20
             */
            readonly minCoolSetpointLimit: OptionalWritableAttribute<number, any>;
            /**
             * Indicates the maximum level that the cooling setpoint may be set to.
             *
             * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
             * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
             * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
             * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
             * response with the status code CONSTRAINT_ERROR shall be returned.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.21
             */
            readonly maxCoolSetpointLimit: OptionalWritableAttribute<number, any>;
        };
    };
    /**
     * A ThermostatCluster supports these elements if doesn't support feature LTNE.
     */
    const NotLocalTemperatureNotExposedComponent: {
        readonly attributes: {
            /**
             * Indicates the offset the Thermostat server shall make to the measured temperature (locally or remotely)
             * to adjust the Calculated Local Temperature prior to using, displaying or reporting it.
             *
             * The purpose of this attribute is to adjust the calibration of the Thermostat server per the user’s
             * preferences (e.g., to match if there are multiple servers displaying different values for the same HVAC
             * area) or compensate for variability amongst temperature sensors.
             *
             * If a Thermostat client attempts to write LocalTemperatureCalibration attribute to an unsupported value
             * (e.g., out of the range supported by the Thermostat server), the Thermostat server shall respond with a
             * status of SUCCESS and set the value of LocalTemperatureCalibration to the upper or lower limit reached.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.13
             */
            readonly localTemperatureCalibration: OptionalWritableAttribute<number, any>;
        };
    };
    /**
     * A ThermostatCluster supports these elements if it supports features Cooling and Occupancy.
     */
    const CoolingAndOccupancyComponent: {
        readonly attributes: {
            /**
             * Indicates the cooling mode setpoint when the room is unoccupied.
             *
             * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute such that these
             * constraints are violated, a response with the status code CONSTRAINT_ERROR shall be returned.
             *
             * If the occupancy status of the room is unknown, this attribute shall NOT be used.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.16
             */
            readonly unoccupiedCoolingSetpoint: WritableAttribute<number, any>;
        };
    };
    /**
     * A ThermostatCluster supports these elements if it supports features Heating and Occupancy.
     */
    const HeatingAndOccupancyComponent: {
        readonly attributes: {
            /**
             * Indicates the heating mode setpoint when the room is unoccupied.
             *
             * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute such that these
             * constraints are violated, a response with the status code CONSTRAINT_ERROR shall be returned.
             *
             * If the occupancy status of the room is unknown, this attribute shall NOT be used.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.17
             */
            readonly unoccupiedHeatingSetpoint: WritableAttribute<number, any>;
        };
    };
    /**
     * A ThermostatCluster supports these elements if it supports feature AutoMode.
     */
    const AutoModeComponent: {
        readonly attributes: {
            /**
             * On devices which support the AUTO feature, this attribute shall indicate the minimum difference between
             * the Heat Setpoint and the Cool Setpoint.
             *
             * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
             * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
             * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
             * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
             * response with the status code CONSTRAINT_ERROR shall be returned.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.22
             */
            readonly minSetpointDeadBand: WritableAttribute<number, any>;
            /**
             * Indicates the running mode of the thermostat. This attribute uses the same values as SystemModeEnum but
             * can only be Off, Cool or Heat. This attribute is intended to provide additional information when the
             * thermostat’s system mode is in auto mode.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.27
             */
            readonly thermostatRunningMode: OptionalAttribute<ThermostatRunningMode, any>;
        };
    };
    /**
     * A ThermostatCluster supports these elements if it supports feature ScheduleConfiguration.
     */
    const ScheduleConfigurationComponent: {
        readonly attributes: {
            /**
             * Indicates the day of the week that this thermostat considers to be the start of week for weekly setpoint
             * scheduling.
             *
             * This attribute may be able to be used as the base to determine if the device supports weekly scheduling
             * by reading the attribute. Successful response means that the weekly scheduling is supported.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.28
             */
            readonly startOfWeek: FixedAttribute<StartOfWeek, any>;
            /**
             * Indicates how many weekly schedule transitions the thermostat is capable of handling.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.29
             */
            readonly numberOfWeeklyTransitions: FixedAttribute<number, any>;
            /**
             * Indicates how many daily schedule transitions the thermostat is capable of handling.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.30
             */
            readonly numberOfDailyTransitions: FixedAttribute<number, any>;
        };
        readonly commands: {
            /**
             * Upon receipt, the weekly schedule for updating setpoints shall be stored in the thermostat and SHOULD
             * begin at the time of receipt. A status code shall be sent in response.
             *
             * When a command is received that requires a total number of transitions greater than the device supports,
             * the status of the response shall be INSUFFICIENT_SPACE.
             *
             * When any of the setpoints sent in the sequence is out of range (AbsMin/MaxSetPointLimit), or when the
             * Mode for Sequence field includes a mode not supported by the device, the status of the response shall be
             * CONSTRAINT_ERROR and no setpoints from the entire sequence SHOULD be used.
             *
             * When an overlapping transition is detected, the status of the response shall be FAILURE.
             *
             * When a device which does not support multiple days in a command receives a command with more than one
             * bit set in the DayOfWeekForSequence field, or when a device which does not support multiple modes in a
             * command receives a command with more than one bit set in the ModeForSequence field, or when the contents
             * of the Transitions field does not agree with NumberOfTransitionsForSequence, DayOfWeekForSequence or
             * ModeForSequence, the status of the response shall be INVALID_COMMAND.
             *
             * When the transitions could be added successfully, the status of the response shall be SUCCESS.
             *
             * The set weekly schedule command is used to update the thermostat weekly setpoint schedule from a
             * management system. If the thermostat already has a weekly setpoint schedule programmed, then it SHOULD
             * replace each daily setpoint set as it receives the updates from the management system. For example, if
             * the thermostat has 4 setpoints for every day of the week and is sent a Set Weekly Schedule command with
             * one setpoint for Saturday then the thermostat SHOULD remove all 4 setpoints for Saturday and replace
             * those with the updated setpoint but leave all other days unchanged. If the schedule is larger than what
             * fits in one frame or contains more than 10 transitions, the schedule shall then be sent using multiple
             * Set Weekly Schedule Commands.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4
             */
            readonly setWeeklySchedule: Command<import("../tlv/TlvObject.js").TypeFromFields<{
                /**
                 * This field shall indicate how many individual transitions to expect for this sequence of commands. If a
                 * device supports more than 10 transitions in its schedule they can send this by sending more than 1 “Set
                 * Weekly Schedule” command, each containing the separate information that the device needs to set.
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.1
                 */
                numberOfTransitionsForSequence: import("../tlv/TlvObject.js").FieldType<number>;
                /**
                 * This field shall represent the day of the week at which all the transitions within the payload of the
                 * command SHOULD be associated to. This field is a bitmap and therefore the associated setpoint could overlap
                 * onto multiple days (you could set one transition time for all “week days” or whatever combination of days
                 * the implementation requests).
                 *
                 * Each setpoint transition will begin with the day of week for this transition. There can be up to 10
                 * transitions for each command.
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.2
                 */
                dayOfWeekForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                    /**
                     * Sunday
                     */
                    sunday: BitFlag;
                    /**
                     * Monday
                     */
                    monday: BitFlag;
                    /**
                     * Tuesday
                     */
                    tuesday: BitFlag;
                    /**
                     * Wednesday
                     */
                    wednesday: BitFlag;
                    /**
                     * Thursday
                     */
                    thursday: BitFlag;
                    /**
                     * Friday
                     */
                    friday: BitFlag;
                    /**
                     * Saturday
                     */
                    saturday: BitFlag;
                    /**
                     * Away or Vacation
                     */
                    away: BitFlag;
                }>>;
                /**
                 * This field shall indicate how the application decodes the setpoint fields of each transition in the
                 * Transitions list.
                 *
                 * If the HeatSetpointPresent bit is On, the HeatSetpoint field shall NOT be null in every entry of the
                 * Transitions list.
                 *
                 * If the HeatSetpointPresent bit is Off, the HeatSetpoint field shall be null in every entry of the
                 * Transitions list.
                 *
                 * If the CoolSetpointPresent bit is On, the CoolSetpoint field shall NOT be null in every entry of the
                 * Transitions list.
                 *
                 * If the CoolSetpointPresent bit is Off, the CoolSetpoint field shall be null in every entry of the
                 * Transitions list.
                 *
                 * At least one of the bits in the Mode For Sequence byte shall be on.
                 *
                 * Both bits must be respected, even if the HEAT or COOL feature is not supported, to ensure the command is
                 * decoded and handled correctly.
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.3
                 */
                modeForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                    /**
                     * Adjust Heat Setpoint
                     */
                    heatSetpointPresent: BitFlag;
                    /**
                     * Adjust Cool Setpoint
                     */
                    coolSetpointPresent: BitFlag;
                }>>;
                /**
                 * This field shall contain the list of setpoint transitions used to update the specified daily schedules
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.4
                 */
                transitions: import("../tlv/TlvObject.js").FieldType<import("../tlv/TlvObject.js").TypeFromFields<{
                    /**
                     * This field shall represent the start time of the schedule transition during the associated day. The time
                     * will be represented by a 16 bits unsigned integer to designate the minutes since midnight. For example, 6am
                     * will be represented by 360 minutes since midnight and 11:30pm will be represented by 1410 minutes since
                     * midnight.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.1
                     */
                    transitionTime: import("../tlv/TlvObject.js").FieldType<number>;
                    /**
                     * This field shall represent the heat setpoint to be applied at this associated transition start time.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.2
                     */
                    heatSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                    /**
                     * This field shall represent the cool setpoint to be applied at this associated transition start time.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.3
                     */
                    coolSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                }>[]>;
            }>, void, any>;
            /**
             * Upon receipt, the unit SHOULD send in return the Get Weekly Schedule Response command. The Days to
             * Return and Mode to Return fields are defined as bitmask for the flexibility to support multiple days and
             * multiple modes within one command. If thermostat cannot handle incoming command with multiple days
             * and/or multiple modes within one command, it shall send default response of INVALID_COMMAND in return.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5
             */
            readonly getWeeklySchedule: Command<import("../tlv/TlvObject.js").TypeFromFields<{
                /**
                 * This field shall indicate the number of days the client would like to return the setpoint values for and
                 * could be any combination of single days or the entire week.
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5.1
                 */
                daysToReturn: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                    /**
                     * Sunday
                     */
                    sunday: BitFlag;
                    /**
                     * Monday
                     */
                    monday: BitFlag;
                    /**
                     * Tuesday
                     */
                    tuesday: BitFlag;
                    /**
                     * Wednesday
                     */
                    wednesday: BitFlag;
                    /**
                     * Thursday
                     */
                    thursday: BitFlag;
                    /**
                     * Friday
                     */
                    friday: BitFlag;
                    /**
                     * Saturday
                     */
                    saturday: BitFlag;
                    /**
                     * Away or Vacation
                     */
                    away: BitFlag;
                }>>;
                /**
                 * This field shall indicate the mode the client would like to return the set point values for and could be any
                 * combination of heat only, cool only or heat & cool.
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5.2
                 */
                modeToReturn: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                    /**
                     * Adjust Heat Setpoint
                     */
                    heatSetpointPresent: BitFlag;
                    /**
                     * Adjust Cool Setpoint
                     */
                    coolSetpointPresent: BitFlag;
                }>>;
            }>, import("../tlv/TlvObject.js").TypeFromFields<{
                numberOfTransitionsForSequence: import("../tlv/TlvObject.js").FieldType<number>;
                dayOfWeekForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                    /**
                     * Sunday
                     */
                    sunday: BitFlag;
                    /**
                     * Monday
                     */
                    monday: BitFlag;
                    /**
                     * Tuesday
                     */
                    tuesday: BitFlag;
                    /**
                     * Wednesday
                     */
                    wednesday: BitFlag;
                    /**
                     * Thursday
                     */
                    thursday: BitFlag;
                    /**
                     * Friday
                     */
                    friday: BitFlag;
                    /**
                     * Saturday
                     */
                    saturday: BitFlag;
                    /**
                     * Away or Vacation
                     */
                    away: BitFlag;
                }>>;
                modeForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                    /**
                     * Adjust Heat Setpoint
                     */
                    heatSetpointPresent: BitFlag;
                    /**
                     * Adjust Cool Setpoint
                     */
                    coolSetpointPresent: BitFlag;
                }>>;
                transitions: import("../tlv/TlvObject.js").FieldType<import("../tlv/TlvObject.js").TypeFromFields<{
                    /**
                     * This field shall represent the start time of the schedule transition during the associated day. The time
                     * will be represented by a 16 bits unsigned integer to designate the minutes since midnight. For example, 6am
                     * will be represented by 360 minutes since midnight and 11:30pm will be represented by 1410 minutes since
                     * midnight.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.1
                     */
                    transitionTime: import("../tlv/TlvObject.js").FieldType<number>;
                    /**
                     * This field shall represent the heat setpoint to be applied at this associated transition start time.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.2
                     */
                    heatSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                    /**
                     * This field shall represent the cool setpoint to be applied at this associated transition start time.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.3
                     */
                    coolSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                }>[]>;
            }>, any>;
            /**
             * This command is used to clear the weekly schedule. The Clear weekly schedule has no payload.
             *
             * Upon receipt, all transitions currently stored shall be cleared and a default response of SUCCESS shall
             * be sent in response. There are no error responses to this command.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.7
             */
            readonly clearWeeklySchedule: Command<void, void, any>;
        };
    };
    /**
     * A ThermostatCluster supports these elements if it supports feature Setback.
     */
    const SetbackComponent: {
        readonly attributes: {
            /**
             * Indicates the amount that the Thermostat server will allow the Calculated Local Temperature to float
             * above the OccupiedCoolingSetpoint (i.e., OccupiedCoolingSetpoint + OccupiedSetback) or below the
             * OccupiedHeatingSetpoint setpoint (i.e., OccupiedHeatingSetpoint – OccupiedSetback) before initiating a
             * state change to bring the temperature back to the user’s desired setpoint. This attribute is sometimes
             * also referred to as the “span.”
             *
             * The purpose of this attribute is to allow remote configuration of the span between the desired setpoint
             * and the measured temperature to help prevent over-cycling and reduce energy bills, though this may
             * result in lower comfort on the part of some users.
             *
             * The null value indicates the attribute is unused.
             *
             * If the Thermostat client attempts to write OccupiedSetback to a value greater than OccupiedSetbackMax,
             * the Thermostat server shall set its OccupiedSetback value to OccupiedSetbackMax and shall send a Write
             * Attribute Response command with a Status Code field enumeration of SUCCESS response.
             *
             * If the Thermostat client attempts to write OccupiedSetback to a value less than OccupiedSetbackMin, the
             * Thermostat server shall set its OccupiedSetback value to OccupiedSetbackMin and shall send a Write
             * Attribute Response command with a Status Code field enumeration of SUCCESS response.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.38
             */
            readonly occupiedSetback: WritableAttribute<number | null, any>;
            /**
             * Indicates the minimum value that the Thermostat server will allow the OccupiedSetback attribute to be
             * configured by a user.
             *
             * The null value indicates the attribute is unused.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.39
             */
            readonly occupiedSetbackMin: FixedAttribute<number | null, any>;
            /**
             * Indicates the maximum value that the Thermostat server will allow the OccupiedSetback attribute to be
             * configured by a user.
             *
             * The null value indicates the attribute is unused.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.40
             */
            readonly occupiedSetbackMax: FixedAttribute<number | null, any>;
        };
    };
    /**
     * A ThermostatCluster supports these elements if it supports features Setback and Occupancy.
     */
    const SetbackAndOccupancyComponent: {
        readonly attributes: {
            /**
             * Indicates the amount that the Thermostat server will allow the Calculated Local Temperature to float
             * above the UnoccupiedCoolingSetpoint (i.e., UnoccupiedCoolingSetpoint + UnoccupiedSetback) or below the
             * UnoccupiedHeatingSetpoint setpoint (i.e., UnoccupiedHeatingSetpoint - UnoccupiedSetback) before
             * initiating a state change to bring the temperature back to the user’s desired setpoint. This attribute
             * is sometimes also referred to as the “span.”
             *
             * The purpose of this attribute is to allow remote configuration of the span between the desired setpoint
             * and the measured temperature to help prevent over-cycling and reduce energy bills, though this may
             * result in lower comfort on the part of some users.
             *
             * The null value indicates the attribute is unused.
             *
             * If the Thermostat client attempts to write UnoccupiedSetback to a value greater than
             * UnoccupiedSetbackMax, the Thermostat server shall set its UnoccupiedSetback value to
             * UnoccupiedSetbackMax and shall send a Write Attribute Response command with a Status Code field
             * enumeration of SUCCESS response.
             *
             * If the Thermostat client attempts to write UnoccupiedSetback to a value less than UnoccupiedSetbackMin,
             * the Thermostat server shall set its UnoccupiedSetback value to UnoccupiedSetbackMin and shall send a
             * Write Attribute Response command with a Status Code field enumeration of SUCCESS response.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.41
             */
            readonly unoccupiedSetback: WritableAttribute<number | null, any>;
            /**
             * Indicates the minimum value that the Thermostat server will allow the UnoccupiedSetback attribute to be
             * configured by a user.
             *
             * The null value indicates the attribute is unused.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.42
             */
            readonly unoccupiedSetbackMin: FixedAttribute<number | null, any>;
            /**
             * Indicates the maximum value that the Thermostat server will allow the UnoccupiedSetback attribute to be
             * configured by a user.
             *
             * The null value indicates the attribute is unused.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.43
             */
            readonly unoccupiedSetbackMax: FixedAttribute<number | null, any>;
        };
    };
    /**
     * These elements and properties are present in all Thermostat clusters.
     */
    const Base: {
        readonly id: 513;
        readonly name: "Thermostat";
        readonly revision: 6;
        readonly features: {
            /**
             * Heating
             *
             * Thermostat is capable of managing a heating device
             */
            readonly heating: BitFlag;
            /**
             * Cooling
             *
             * Thermostat is capable of managing a cooling device
             */
            readonly cooling: BitFlag;
            /**
             * Occupancy
             *
             * Supports Occupied and Unoccupied setpoints
             */
            readonly occupancy: BitFlag;
            /**
             * ScheduleConfiguration
             *
             * Supports remote configuration of a weekly schedule of setpoint transitions
             */
            readonly scheduleConfiguration: BitFlag;
            /**
             * Setback
             *
             * Supports configurable setback (or span)
             */
            readonly setback: BitFlag;
            /**
             * AutoMode
             *
             * Supports a System Mode of Auto
             */
            readonly autoMode: BitFlag;
            /**
             * LocalTemperatureNotExposed
             *
             * This feature indicates that the Calculated Local Temperature used internally is unavailable to report
             * externally, for example due to the temperature control being done by a separate subsystem which does not
             * offer a view into the currently measured temperature, but allows setpoints to be provided.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.4.1
             */
            readonly localTemperatureNotExposed: BitFlag;
        };
        readonly attributes: {
            /**
             * Indicates the current Calculated Local Temperature, when available.
             *
             *   • If the LTNE feature is not supported:
             *
             *     ◦ If the LocalTemperatureCalibration is invalid or currently unavailable, the attribute shall report
             *       null.
             *
             *     ◦ If the LocalTemperatureCalibration is valid, the attribute shall report that value.
             *
             *   • Otherwise, if the LTNE feature is supported, there is no feedback externally available for the
             *     LocalTemperatureCalibration. In that case, the LocalTemperature attribute shall always report null.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.3
             */
            readonly localTemperature: Attribute<number | null, any>;
            /**
             * Indicates the outdoor temperature, as measured locally or remotely (over the network).
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.4
             */
            readonly outdoorTemperature: OptionalAttribute<number | null, any>;
            /**
             * Indicates the HVAC system type controlled by the thermostat. If the thermostat uses physical DIP
             * switches to set these parameters, this information shall be available read-only from the DIP switches.
             * If these parameters are set via software, there shall be read/write access in order to provide remote
             * programming capability.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.12
             * @deprecated
             */
            readonly hvacSystemTypeConfiguration: OptionalWritableAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Stage of cooling the HVAC system is using.
                 *
                 * These bits shall indicate what stage of cooling the HVAC system is using.
                 *
                 *   • 00 = Cool Stage 1
                 *
                 *   • 01 = Cool Stage 2
                 *
                 *   • 10 = Cool Stage 3
                 *
                 *   • 11 = Reserved
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.1
                 */
                coolingStage: BitField;
                /**
                 * Stage of heating the HVAC system is using.
                 *
                 * These bits shall indicate what stage of heating the HVAC system is using.
                 *
                 *   • 00 = Heat Stage 1
                 *
                 *   • 01 = Heat Stage 2
                 *
                 *   • 10 = Heat Stage 3
                 *
                 *   • 11 = Reserved
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.2
                 */
                heatingStage: BitField;
                /**
                 * Is the heating type Heat Pump.
                 *
                 * This bit shall indicate whether the HVAC system is conventional or a heat pump.
                 *
                 *   • 0 = Conventional
                 *
                 *   • 1 = Heat Pump
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.3
                 */
                heatingIsHeatPump: BitFlag;
                /**
                 * Does the HVAC system use fuel.
                 *
                 * This bit shall indicate whether the HVAC system uses fuel.
                 *
                 *   • 0 = Does not use fuel
                 *
                 *   • 1 = Uses fuel
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.4
                 */
                heatingUsesFuel: BitFlag;
            }>, any>;
            /**
             * Indicates when the local temperature, outdoor temperature and occupancy are being sensed by remote
             * networked sensors, rather than internal sensors.
             *
             * If the LTNE feature is present in the server, the LocalTemperature RemoteSensing bit value shall always
             * report a value of 0.
             *
             * If the LocalTemperature RemoteSensing bit is written with a value of 1 when the LTNE feature is present,
             * the write shall fail and the server shall report a CONSTRAINT_ERROR.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.23
             */
            readonly remoteSensing: OptionalWritableAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Calculated Local Temperature is derived from a remote node
                 */
                localTemperature: BitFlag;
                /**
                 * OutdoorTemperature is derived from a remote node
                 *
                 * This bit shall be supported if the OutdoorTemperature attribute is supported.
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.9.1
                 */
                outdoorTemperature: BitFlag;
                /**
                 * Occupancy is derived from a remote node
                 */
                occupancy: BitFlag;
            }>, any>;
            /**
             * Indicates the overall operating environment of the thermostat, and thus the possible system modes that
             * the thermostat can operate in.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.24
             */
            readonly controlSequenceOfOperation: WritableAttribute<ControlSequenceOfOperation, any>;
            /**
             * Indicates the current operating mode of the thermostat. Its value shall be limited by the
             * ControlSequenceOfOperation attribute.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.25
             */
            readonly systemMode: WritableAttribute<SystemMode, any>;
            /**
             * Indicates the temperature hold status on the thermostat. If hold status is on, the thermostat SHOULD
             * maintain the temperature setpoint for the current mode until a system mode change. If hold status is
             * off, the thermostat SHOULD follow the setpoint transitions specified by its internal scheduling program.
             * If the thermostat supports setpoint hold for a specific duration, it SHOULD also implement the
             * TemperatureSetpointHoldDuration attribute.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.31
             */
            readonly temperatureSetpointHold: OptionalWritableAttribute<TemperatureSetpointHold, any>;
            /**
             * Indicates the period in minutes for which a setpoint hold is active. Thermostats that support hold for a
             * specified duration SHOULD implement this attribute. The null value indicates the field is unused. All
             * other values are reserved.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.32
             */
            readonly temperatureSetpointHoldDuration: OptionalWritableAttribute<number | null, any>;
            /**
             * Indicates the operational state of the thermostat’s programming. The thermostat shall modify its
             * programming operation when this attribute is modified by a client and update this attribute when its
             * programming operation is modified locally by a user. The thermostat may support more than one active
             * ProgrammingOperationModeBitmap. For example, the thermostat may operate simultaneously in Schedule
             * Programming Mode and Recovery Mode.
             *
             * Thermostats which contain a schedule may use this attribute to control how that schedule is used, even
             * if they do not support the ScheduleConfiguration feature.
             *
             * When ScheduleActive is not set, the setpoint is altered only by manual up/down changes at the thermostat
             * or remotely, not by internal schedule programming.
             *
             * NOTE
             *
             * Modifying the ScheduleActive bit does not clear or delete previous weekly schedule programming
             * configurations.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.33
             */
            readonly thermostatProgrammingOperationMode: OptionalWritableAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Schedule programming mode. This enables any programmed weekly schedule configurations.
                 */
                scheduleActive: BitFlag;
                /**
                 * Auto/recovery mode
                 */
                autoRecovery: BitFlag;
                /**
                 * Economy/EnergyStar mode
                 */
                economy: BitFlag;
            }>, any>;
            /**
             * Indicates the current relay state of the heat, cool, and fan relays. Unimplemented outputs shall be
             * treated as if they were Off.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.34
             */
            readonly thermostatRunningState: OptionalAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Heat State On
                 */
                heat: BitFlag;
                /**
                 * Cool State On
                 */
                cool: BitFlag;
                /**
                 * Fan State On
                 */
                fan: BitFlag;
                /**
                 * Heat 2nd State On
                 */
                heatStage2: BitFlag;
                /**
                 * Cool 2nd State On
                 */
                coolStage2: BitFlag;
                /**
                 * Fan 2nd State On
                 */
                fanStage2: BitFlag;
                /**
                 * Fan 3rd Stage On
                 */
                fanStage3: BitFlag;
            }>, any>;
            /**
             * Indicates the source of the current active OccupiedCoolingSetpoint or OccupiedHeatingSetpoint (i.e., who
             * or what determined the current setpoint).
             *
             * This attribute enables service providers to determine whether changes to setpoints were initiated due to
             * occupant comfort, scheduled programming or some other source (e.g., electric utility or other service
             * provider). Because automation services may initiate frequent setpoint changes, this attribute clearly
             * differentiates the source of setpoint changes made at the thermostat.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.35
             */
            readonly setpointChangeSource: OptionalAttribute<SetpointChangeSource, any>;
            /**
             * Indicates the delta between the current active OccupiedCoolingSetpoint or OccupiedHeatingSetpoint and
             * the previous active setpoint. This attribute is meant to accompany the SetpointChangeSource attribute;
             * devices implementing SetpointChangeAmount SHOULD also implement SetpointChangeSource.
             *
             * The null value indicates that the previous setpoint was unknown.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.36
             */
            readonly setpointChangeAmount: OptionalAttribute<number | null, any>;
            /**
             * Indicates the time in UTC at which the SetpointChangeAmount attribute change was recorded.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.37
             */
            readonly setpointChangeSourceTimestamp: OptionalAttribute<number, any>;
            /**
             * Indicates the delta between the Calculated Local Temperature and the OccupiedHeatingSetpoint or
             * UnoccupiedHeatingSetpoint attributes at which the Thermostat server will operate in emergency heat mode.
             *
             * If the difference between the Calculated Local Temperature and OccupiedCoolingSetpoint or
             * UnoccupiedCoolingSetpoint is greater than or equal to the EmergencyHeatDelta and the Thermostat server’s
             * SystemMode attribute is in a heating-related mode, then the Thermostat server shall immediately switch
             * to the SystemMode attribute value that provides the highest stage of heating (e.g., emergency heat) and
             * continue operating in that running state until the OccupiedHeatingSetpoint value is reached. For example:
             *
             *   • Calculated Local Temperature = 10.0°C
             *
             *   • OccupiedHeatingSetpoint = 16.0°C
             *
             *   • EmergencyHeatDelta = 2.0°C
             *
             * ⇒ OccupiedHeatingSetpoint - Calculated Local Temperature ≥? EmergencyHeatDelta
             *
             * ⇒ 16°C - 10°C ≥? 2°C
             *
             * ⇒ TRUE >>> Thermostat server changes its SystemMode to operate in 2nd stage or emergency heat mode
             *
             * The purpose of this attribute is to provide Thermostat clients the ability to configure rapid heating
             * when a setpoint is of a specified amount greater than the measured temperature. This allows the heated
             * space to be quickly heated to the desired level set by the user.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.44
             */
            readonly emergencyHeatDelta: OptionalWritableAttribute<number, any>;
            /**
             * Indicates the type of Mini Split ACTypeEnum of Mini Split AC is defined depending on how Cooling and
             * Heating condition is achieved by Mini Split AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.45
             */
            readonly acType: OptionalWritableAttribute<AcType, any>;
            /**
             * Indicates capacity of Mini Split AC in terms of the format defined by the ACCapacityFormat attribute
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.46
             */
            readonly acCapacity: OptionalWritableAttribute<number, any>;
            /**
             * Indicates type of refrigerant used within the Mini Split AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.47
             */
            readonly acRefrigerantType: OptionalWritableAttribute<AcRefrigerantType, any>;
            /**
             * Indicates the type of compressor used within the Mini Split AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.48
             */
            readonly acCompressorType: OptionalWritableAttribute<AcCompressorType, any>;
            /**
             * Indicates the type of errors encountered within the Mini Split AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.49
             */
            readonly acErrorCode: OptionalWritableAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Compressor Failure or Refrigerant Leakage
                 */
                compressorFail: BitFlag;
                /**
                 * Room Temperature Sensor Failure
                 */
                roomSensorFail: BitFlag;
                /**
                 * Outdoor Temperature Sensor Failure
                 */
                outdoorSensorFail: BitFlag;
                /**
                 * Indoor Coil Temperature Sensor Failure
                 */
                coilSensorFail: BitFlag;
                /**
                 * Fan Failure
                 */
                fanFail: BitFlag;
            }>, any>;
            /**
             * Indicates the position of Louver on the AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.50
             */
            readonly acLouverPosition: OptionalWritableAttribute<AcLouverPosition, any>;
            /**
             * Indicates the temperature of the AC coil, as measured locally or remotely (over the network).
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.51
             */
            readonly acCoilTemperature: OptionalAttribute<number | null, any>;
            /**
             * Indicates the format for the ACCapacity attribute.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.52
             */
            readonly acCapacityFormat: OptionalWritableAttribute<AcCapacityFormat, any>;
        };
        readonly commands: {
            /**
             * Upon receipt, the attributes for the indicated setpoint(s) shall have the amount specified in the Amount
             * field added to them. If the resulting value is outside the limits imposed by MinCoolSetpointLimit,
             * MaxCoolSetpointLimit, MinHeatSetpointLimit and MaxHeatSetpointLimit, the value is clamped to those
             * limits. This is not considered an error condition.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.1
             */
            readonly setpointRaiseLower: Command<import("../tlv/TlvObject.js").TypeFromFields<{
                mode: import("../tlv/TlvObject.js").FieldType<SetpointRaiseLowerMode>;
                amount: import("../tlv/TlvObject.js").FieldType<number>;
            }>, void, any>;
        };
        /**
         * This metadata controls which ThermostatCluster elements matter.js activates for specific feature
         * combinations.
         */
        readonly extensions: readonly [{
            readonly flags: {
                readonly occupancy: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates whether the heated/cooled space is occupied or not, as measured locally or remotely (over the
                     * network).
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.5
                     */
                    readonly occupancy: Attribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                        occupied: BitFlag;
                    }>, any>;
                };
            };
        }, {
            readonly flags: {
                readonly heating: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9
                     */
                    readonly absMinHeatSetpointLimit: OptionalFixedAttribute<number, any>;
                    /**
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9
                     */
                    readonly absMaxHeatSetpointLimit: OptionalFixedAttribute<number, any>;
                    /**
                     * Indicates the level of heating demanded by the PI loop in percent. This value is 0 when the thermostat
                     * is in “off” or “cooling” mode.
                     *
                     * This attribute is reported regularly and may be used to control a heating device.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.11
                     */
                    readonly piHeatingDemand: OptionalAttribute<number, any>;
                    /**
                     * Indicates the heating mode setpoint when the room is occupied.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute such that these
                     * constraints are violated, a response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * If the occupancy status of the room is unknown, this attribute shall be used as the heating mode
                     * setpoint.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.15
                     */
                    readonly occupiedHeatingSetpoint: WritableAttribute<number, any>;
                    /**
                     * Indicates the minimum level that the heating setpoint may be set to.
                     *
                     * This attribute, and the following three attributes, allow the user to define setpoint limits more
                     * constrictive than the manufacturer imposed ones. Limiting users (e.g., in a commercial building) to such
                     * setpoint limits can help conserve power.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
                     * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
                     * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
                     * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
                     * response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.18
                     */
                    readonly minHeatSetpointLimit: OptionalWritableAttribute<number, any>;
                    /**
                     * Indicates the maximum level that the heating setpoint may be set to.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
                     * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
                     * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
                     * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
                     * response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.19
                     */
                    readonly maxHeatSetpointLimit: OptionalWritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly cooling: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates the absolute minimum level that the cooling setpoint may be set to. This is a limitation
                     * imposed by the manufacturer.
                     *
                     * Refer to Setpoint Limits for constraints
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.8
                     */
                    readonly absMinCoolSetpointLimit: OptionalFixedAttribute<number, any>;
                    /**
                     * Indicates the absolute maximum level that the cooling setpoint may be set to. This is a limitation
                     * imposed by the manufacturer.
                     *
                     * Refer to Setpoint Limits for constraints
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.9
                     */
                    readonly absMaxCoolSetpointLimit: OptionalFixedAttribute<number, any>;
                    /**
                     * Indicates the level of cooling demanded by the PI (proportional integral) control loop in use by the
                     * thermostat (if any), in percent. This value is 0 when the thermostat is in “off” or “heating” mode.
                     *
                     * This attribute is reported regularly and may be used to control a cooling device.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.10
                     */
                    readonly piCoolingDemand: OptionalAttribute<number, any>;
                    /**
                     * Indicates the cooling mode setpoint when the room is occupied.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute such that these
                     * constraints are violated, a response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * If the occupancy status of the room is unknown, this attribute shall be used as the cooling mode
                     * setpoint.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.14
                     */
                    readonly occupiedCoolingSetpoint: WritableAttribute<number, any>;
                    /**
                     * Indicates the minimum level that the cooling setpoint may be set to.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
                     * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
                     * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
                     * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
                     * response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.20
                     */
                    readonly minCoolSetpointLimit: OptionalWritableAttribute<number, any>;
                    /**
                     * Indicates the maximum level that the cooling setpoint may be set to.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
                     * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
                     * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
                     * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
                     * response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.21
                     */
                    readonly maxCoolSetpointLimit: OptionalWritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly localTemperatureNotExposed: false;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates the offset the Thermostat server shall make to the measured temperature (locally or remotely)
                     * to adjust the Calculated Local Temperature prior to using, displaying or reporting it.
                     *
                     * The purpose of this attribute is to adjust the calibration of the Thermostat server per the user’s
                     * preferences (e.g., to match if there are multiple servers displaying different values for the same HVAC
                     * area) or compensate for variability amongst temperature sensors.
                     *
                     * If a Thermostat client attempts to write LocalTemperatureCalibration attribute to an unsupported value
                     * (e.g., out of the range supported by the Thermostat server), the Thermostat server shall respond with a
                     * status of SUCCESS and set the value of LocalTemperatureCalibration to the upper or lower limit reached.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.13
                     */
                    readonly localTemperatureCalibration: OptionalWritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly cooling: true;
                readonly occupancy: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates the cooling mode setpoint when the room is unoccupied.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute such that these
                     * constraints are violated, a response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * If the occupancy status of the room is unknown, this attribute shall NOT be used.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.16
                     */
                    readonly unoccupiedCoolingSetpoint: WritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly heating: true;
                readonly occupancy: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates the heating mode setpoint when the room is unoccupied.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute such that these
                     * constraints are violated, a response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * If the occupancy status of the room is unknown, this attribute shall NOT be used.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.17
                     */
                    readonly unoccupiedHeatingSetpoint: WritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly autoMode: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * On devices which support the AUTO feature, this attribute shall indicate the minimum difference between
                     * the Heat Setpoint and the Cool Setpoint.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
                     * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
                     * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
                     * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
                     * response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.22
                     */
                    readonly minSetpointDeadBand: WritableAttribute<number, any>;
                    /**
                     * Indicates the running mode of the thermostat. This attribute uses the same values as SystemModeEnum but
                     * can only be Off, Cool or Heat. This attribute is intended to provide additional information when the
                     * thermostat’s system mode is in auto mode.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.27
                     */
                    readonly thermostatRunningMode: OptionalAttribute<ThermostatRunningMode, any>;
                };
            };
        }, {
            readonly flags: {
                readonly scheduleConfiguration: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates the day of the week that this thermostat considers to be the start of week for weekly setpoint
                     * scheduling.
                     *
                     * This attribute may be able to be used as the base to determine if the device supports weekly scheduling
                     * by reading the attribute. Successful response means that the weekly scheduling is supported.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.28
                     */
                    readonly startOfWeek: FixedAttribute<StartOfWeek, any>;
                    /**
                     * Indicates how many weekly schedule transitions the thermostat is capable of handling.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.29
                     */
                    readonly numberOfWeeklyTransitions: FixedAttribute<number, any>;
                    /**
                     * Indicates how many daily schedule transitions the thermostat is capable of handling.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.30
                     */
                    readonly numberOfDailyTransitions: FixedAttribute<number, any>;
                };
                readonly commands: {
                    /**
                     * Upon receipt, the weekly schedule for updating setpoints shall be stored in the thermostat and SHOULD
                     * begin at the time of receipt. A status code shall be sent in response.
                     *
                     * When a command is received that requires a total number of transitions greater than the device supports,
                     * the status of the response shall be INSUFFICIENT_SPACE.
                     *
                     * When any of the setpoints sent in the sequence is out of range (AbsMin/MaxSetPointLimit), or when the
                     * Mode for Sequence field includes a mode not supported by the device, the status of the response shall be
                     * CONSTRAINT_ERROR and no setpoints from the entire sequence SHOULD be used.
                     *
                     * When an overlapping transition is detected, the status of the response shall be FAILURE.
                     *
                     * When a device which does not support multiple days in a command receives a command with more than one
                     * bit set in the DayOfWeekForSequence field, or when a device which does not support multiple modes in a
                     * command receives a command with more than one bit set in the ModeForSequence field, or when the contents
                     * of the Transitions field does not agree with NumberOfTransitionsForSequence, DayOfWeekForSequence or
                     * ModeForSequence, the status of the response shall be INVALID_COMMAND.
                     *
                     * When the transitions could be added successfully, the status of the response shall be SUCCESS.
                     *
                     * The set weekly schedule command is used to update the thermostat weekly setpoint schedule from a
                     * management system. If the thermostat already has a weekly setpoint schedule programmed, then it SHOULD
                     * replace each daily setpoint set as it receives the updates from the management system. For example, if
                     * the thermostat has 4 setpoints for every day of the week and is sent a Set Weekly Schedule command with
                     * one setpoint for Saturday then the thermostat SHOULD remove all 4 setpoints for Saturday and replace
                     * those with the updated setpoint but leave all other days unchanged. If the schedule is larger than what
                     * fits in one frame or contains more than 10 transitions, the schedule shall then be sent using multiple
                     * Set Weekly Schedule Commands.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4
                     */
                    readonly setWeeklySchedule: Command<import("../tlv/TlvObject.js").TypeFromFields<{
                        /**
                         * This field shall indicate how many individual transitions to expect for this sequence of commands. If a
                         * device supports more than 10 transitions in its schedule they can send this by sending more than 1 “Set
                         * Weekly Schedule” command, each containing the separate information that the device needs to set.
                         *
                         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.1
                         */
                        numberOfTransitionsForSequence: import("../tlv/TlvObject.js").FieldType<number>;
                        /**
                         * This field shall represent the day of the week at which all the transitions within the payload of the
                         * command SHOULD be associated to. This field is a bitmap and therefore the associated setpoint could overlap
                         * onto multiple days (you could set one transition time for all “week days” or whatever combination of days
                         * the implementation requests).
                         *
                         * Each setpoint transition will begin with the day of week for this transition. There can be up to 10
                         * transitions for each command.
                         *
                         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.2
                         */
                        dayOfWeekForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                            /**
                             * Sunday
                             */
                            sunday: BitFlag;
                            /**
                             * Monday
                             */
                            monday: BitFlag;
                            /**
                             * Tuesday
                             */
                            tuesday: BitFlag;
                            /**
                             * Wednesday
                             */
                            wednesday: BitFlag;
                            /**
                             * Thursday
                             */
                            thursday: BitFlag;
                            /**
                             * Friday
                             */
                            friday: BitFlag;
                            /**
                             * Saturday
                             */
                            saturday: BitFlag;
                            /**
                             * Away or Vacation
                             */
                            away: BitFlag;
                        }>>;
                        /**
                         * This field shall indicate how the application decodes the setpoint fields of each transition in the
                         * Transitions list.
                         *
                         * If the HeatSetpointPresent bit is On, the HeatSetpoint field shall NOT be null in every entry of the
                         * Transitions list.
                         *
                         * If the HeatSetpointPresent bit is Off, the HeatSetpoint field shall be null in every entry of the
                         * Transitions list.
                         *
                         * If the CoolSetpointPresent bit is On, the CoolSetpoint field shall NOT be null in every entry of the
                         * Transitions list.
                         *
                         * If the CoolSetpointPresent bit is Off, the CoolSetpoint field shall be null in every entry of the
                         * Transitions list.
                         *
                         * At least one of the bits in the Mode For Sequence byte shall be on.
                         *
                         * Both bits must be respected, even if the HEAT or COOL feature is not supported, to ensure the command is
                         * decoded and handled correctly.
                         *
                         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.3
                         */
                        modeForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                            /**
                             * Adjust Heat Setpoint
                             */
                            heatSetpointPresent: BitFlag;
                            /**
                             * Adjust Cool Setpoint
                             */
                            coolSetpointPresent: BitFlag;
                        }>>;
                        /**
                         * This field shall contain the list of setpoint transitions used to update the specified daily schedules
                         *
                         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.4
                         */
                        transitions: import("../tlv/TlvObject.js").FieldType<import("../tlv/TlvObject.js").TypeFromFields<{
                            /**
                             * This field shall represent the start time of the schedule transition during the associated day. The time
                             * will be represented by a 16 bits unsigned integer to designate the minutes since midnight. For example, 6am
                             * will be represented by 360 minutes since midnight and 11:30pm will be represented by 1410 minutes since
                             * midnight.
                             *
                             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.1
                             */
                            transitionTime: import("../tlv/TlvObject.js").FieldType<number>;
                            /**
                             * This field shall represent the heat setpoint to be applied at this associated transition start time.
                             *
                             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.2
                             */
                            heatSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                            /**
                             * This field shall represent the cool setpoint to be applied at this associated transition start time.
                             *
                             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.3
                             */
                            coolSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                        }>[]>;
                    }>, void, any>;
                    /**
                     * Upon receipt, the unit SHOULD send in return the Get Weekly Schedule Response command. The Days to
                     * Return and Mode to Return fields are defined as bitmask for the flexibility to support multiple days and
                     * multiple modes within one command. If thermostat cannot handle incoming command with multiple days
                     * and/or multiple modes within one command, it shall send default response of INVALID_COMMAND in return.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5
                     */
                    readonly getWeeklySchedule: Command<import("../tlv/TlvObject.js").TypeFromFields<{
                        /**
                         * This field shall indicate the number of days the client would like to return the setpoint values for and
                         * could be any combination of single days or the entire week.
                         *
                         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5.1
                         */
                        daysToReturn: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                            /**
                             * Sunday
                             */
                            sunday: BitFlag;
                            /**
                             * Monday
                             */
                            monday: BitFlag;
                            /**
                             * Tuesday
                             */
                            tuesday: BitFlag;
                            /**
                             * Wednesday
                             */
                            wednesday: BitFlag;
                            /**
                             * Thursday
                             */
                            thursday: BitFlag;
                            /**
                             * Friday
                             */
                            friday: BitFlag;
                            /**
                             * Saturday
                             */
                            saturday: BitFlag;
                            /**
                             * Away or Vacation
                             */
                            away: BitFlag;
                        }>>;
                        /**
                         * This field shall indicate the mode the client would like to return the set point values for and could be any
                         * combination of heat only, cool only or heat & cool.
                         *
                         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5.2
                         */
                        modeToReturn: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                            /**
                             * Adjust Heat Setpoint
                             */
                            heatSetpointPresent: BitFlag;
                            /**
                             * Adjust Cool Setpoint
                             */
                            coolSetpointPresent: BitFlag;
                        }>>;
                    }>, import("../tlv/TlvObject.js").TypeFromFields<{
                        numberOfTransitionsForSequence: import("../tlv/TlvObject.js").FieldType<number>;
                        dayOfWeekForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                            /**
                             * Sunday
                             */
                            sunday: BitFlag;
                            /**
                             * Monday
                             */
                            monday: BitFlag;
                            /**
                             * Tuesday
                             */
                            tuesday: BitFlag;
                            /**
                             * Wednesday
                             */
                            wednesday: BitFlag;
                            /**
                             * Thursday
                             */
                            thursday: BitFlag;
                            /**
                             * Friday
                             */
                            friday: BitFlag;
                            /**
                             * Saturday
                             */
                            saturday: BitFlag;
                            /**
                             * Away or Vacation
                             */
                            away: BitFlag;
                        }>>;
                        modeForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                            /**
                             * Adjust Heat Setpoint
                             */
                            heatSetpointPresent: BitFlag;
                            /**
                             * Adjust Cool Setpoint
                             */
                            coolSetpointPresent: BitFlag;
                        }>>;
                        transitions: import("../tlv/TlvObject.js").FieldType<import("../tlv/TlvObject.js").TypeFromFields<{
                            /**
                             * This field shall represent the start time of the schedule transition during the associated day. The time
                             * will be represented by a 16 bits unsigned integer to designate the minutes since midnight. For example, 6am
                             * will be represented by 360 minutes since midnight and 11:30pm will be represented by 1410 minutes since
                             * midnight.
                             *
                             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.1
                             */
                            transitionTime: import("../tlv/TlvObject.js").FieldType<number>;
                            /**
                             * This field shall represent the heat setpoint to be applied at this associated transition start time.
                             *
                             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.2
                             */
                            heatSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                            /**
                             * This field shall represent the cool setpoint to be applied at this associated transition start time.
                             *
                             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.3
                             */
                            coolSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                        }>[]>;
                    }>, any>;
                    /**
                     * This command is used to clear the weekly schedule. The Clear weekly schedule has no payload.
                     *
                     * Upon receipt, all transitions currently stored shall be cleared and a default response of SUCCESS shall
                     * be sent in response. There are no error responses to this command.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.7
                     */
                    readonly clearWeeklySchedule: Command<void, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly setback: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates the amount that the Thermostat server will allow the Calculated Local Temperature to float
                     * above the OccupiedCoolingSetpoint (i.e., OccupiedCoolingSetpoint + OccupiedSetback) or below the
                     * OccupiedHeatingSetpoint setpoint (i.e., OccupiedHeatingSetpoint – OccupiedSetback) before initiating a
                     * state change to bring the temperature back to the user’s desired setpoint. This attribute is sometimes
                     * also referred to as the “span.”
                     *
                     * The purpose of this attribute is to allow remote configuration of the span between the desired setpoint
                     * and the measured temperature to help prevent over-cycling and reduce energy bills, though this may
                     * result in lower comfort on the part of some users.
                     *
                     * The null value indicates the attribute is unused.
                     *
                     * If the Thermostat client attempts to write OccupiedSetback to a value greater than OccupiedSetbackMax,
                     * the Thermostat server shall set its OccupiedSetback value to OccupiedSetbackMax and shall send a Write
                     * Attribute Response command with a Status Code field enumeration of SUCCESS response.
                     *
                     * If the Thermostat client attempts to write OccupiedSetback to a value less than OccupiedSetbackMin, the
                     * Thermostat server shall set its OccupiedSetback value to OccupiedSetbackMin and shall send a Write
                     * Attribute Response command with a Status Code field enumeration of SUCCESS response.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.38
                     */
                    readonly occupiedSetback: WritableAttribute<number | null, any>;
                    /**
                     * Indicates the minimum value that the Thermostat server will allow the OccupiedSetback attribute to be
                     * configured by a user.
                     *
                     * The null value indicates the attribute is unused.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.39
                     */
                    readonly occupiedSetbackMin: FixedAttribute<number | null, any>;
                    /**
                     * Indicates the maximum value that the Thermostat server will allow the OccupiedSetback attribute to be
                     * configured by a user.
                     *
                     * The null value indicates the attribute is unused.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.40
                     */
                    readonly occupiedSetbackMax: FixedAttribute<number | null, any>;
                };
            };
        }, {
            readonly flags: {
                readonly setback: true;
                readonly occupancy: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates the amount that the Thermostat server will allow the Calculated Local Temperature to float
                     * above the UnoccupiedCoolingSetpoint (i.e., UnoccupiedCoolingSetpoint + UnoccupiedSetback) or below the
                     * UnoccupiedHeatingSetpoint setpoint (i.e., UnoccupiedHeatingSetpoint - UnoccupiedSetback) before
                     * initiating a state change to bring the temperature back to the user’s desired setpoint. This attribute
                     * is sometimes also referred to as the “span.”
                     *
                     * The purpose of this attribute is to allow remote configuration of the span between the desired setpoint
                     * and the measured temperature to help prevent over-cycling and reduce energy bills, though this may
                     * result in lower comfort on the part of some users.
                     *
                     * The null value indicates the attribute is unused.
                     *
                     * If the Thermostat client attempts to write UnoccupiedSetback to a value greater than
                     * UnoccupiedSetbackMax, the Thermostat server shall set its UnoccupiedSetback value to
                     * UnoccupiedSetbackMax and shall send a Write Attribute Response command with a Status Code field
                     * enumeration of SUCCESS response.
                     *
                     * If the Thermostat client attempts to write UnoccupiedSetback to a value less than UnoccupiedSetbackMin,
                     * the Thermostat server shall set its UnoccupiedSetback value to UnoccupiedSetbackMin and shall send a
                     * Write Attribute Response command with a Status Code field enumeration of SUCCESS response.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.41
                     */
                    readonly unoccupiedSetback: WritableAttribute<number | null, any>;
                    /**
                     * Indicates the minimum value that the Thermostat server will allow the UnoccupiedSetback attribute to be
                     * configured by a user.
                     *
                     * The null value indicates the attribute is unused.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.42
                     */
                    readonly unoccupiedSetbackMin: FixedAttribute<number | null, any>;
                    /**
                     * Indicates the maximum value that the Thermostat server will allow the UnoccupiedSetback attribute to be
                     * configured by a user.
                     *
                     * The null value indicates the attribute is unused.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.43
                     */
                    readonly unoccupiedSetbackMax: FixedAttribute<number | null, any>;
                };
            };
        }, {
            readonly flags: {
                readonly autoMode: true;
                readonly heating: false;
            };
            readonly component: false;
        }, {
            readonly flags: {
                readonly autoMode: true;
                readonly cooling: false;
            };
            readonly component: false;
        }, {
            readonly flags: {
                readonly heating: false;
                readonly cooling: false;
            };
            readonly component: false;
        }];
    };
    /**
     * @see {@link Cluster}
     */
    const ClusterInstance: MutableCluster.ExtensibleOnly<{
        readonly id: 513;
        readonly name: "Thermostat";
        readonly revision: 6;
        readonly features: {
            /**
             * Heating
             *
             * Thermostat is capable of managing a heating device
             */
            readonly heating: BitFlag;
            /**
             * Cooling
             *
             * Thermostat is capable of managing a cooling device
             */
            readonly cooling: BitFlag;
            /**
             * Occupancy
             *
             * Supports Occupied and Unoccupied setpoints
             */
            readonly occupancy: BitFlag;
            /**
             * ScheduleConfiguration
             *
             * Supports remote configuration of a weekly schedule of setpoint transitions
             */
            readonly scheduleConfiguration: BitFlag;
            /**
             * Setback
             *
             * Supports configurable setback (or span)
             */
            readonly setback: BitFlag;
            /**
             * AutoMode
             *
             * Supports a System Mode of Auto
             */
            readonly autoMode: BitFlag;
            /**
             * LocalTemperatureNotExposed
             *
             * This feature indicates that the Calculated Local Temperature used internally is unavailable to report
             * externally, for example due to the temperature control being done by a separate subsystem which does not
             * offer a view into the currently measured temperature, but allows setpoints to be provided.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.4.1
             */
            readonly localTemperatureNotExposed: BitFlag;
        };
        readonly attributes: {
            /**
             * Indicates the current Calculated Local Temperature, when available.
             *
             *   • If the LTNE feature is not supported:
             *
             *     ◦ If the LocalTemperatureCalibration is invalid or currently unavailable, the attribute shall report
             *       null.
             *
             *     ◦ If the LocalTemperatureCalibration is valid, the attribute shall report that value.
             *
             *   • Otherwise, if the LTNE feature is supported, there is no feedback externally available for the
             *     LocalTemperatureCalibration. In that case, the LocalTemperature attribute shall always report null.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.3
             */
            readonly localTemperature: Attribute<number | null, any>;
            /**
             * Indicates the outdoor temperature, as measured locally or remotely (over the network).
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.4
             */
            readonly outdoorTemperature: OptionalAttribute<number | null, any>;
            /**
             * Indicates the HVAC system type controlled by the thermostat. If the thermostat uses physical DIP
             * switches to set these parameters, this information shall be available read-only from the DIP switches.
             * If these parameters are set via software, there shall be read/write access in order to provide remote
             * programming capability.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.12
             * @deprecated
             */
            readonly hvacSystemTypeConfiguration: OptionalWritableAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Stage of cooling the HVAC system is using.
                 *
                 * These bits shall indicate what stage of cooling the HVAC system is using.
                 *
                 *   • 00 = Cool Stage 1
                 *
                 *   • 01 = Cool Stage 2
                 *
                 *   • 10 = Cool Stage 3
                 *
                 *   • 11 = Reserved
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.1
                 */
                coolingStage: BitField;
                /**
                 * Stage of heating the HVAC system is using.
                 *
                 * These bits shall indicate what stage of heating the HVAC system is using.
                 *
                 *   • 00 = Heat Stage 1
                 *
                 *   • 01 = Heat Stage 2
                 *
                 *   • 10 = Heat Stage 3
                 *
                 *   • 11 = Reserved
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.2
                 */
                heatingStage: BitField;
                /**
                 * Is the heating type Heat Pump.
                 *
                 * This bit shall indicate whether the HVAC system is conventional or a heat pump.
                 *
                 *   • 0 = Conventional
                 *
                 *   • 1 = Heat Pump
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.3
                 */
                heatingIsHeatPump: BitFlag;
                /**
                 * Does the HVAC system use fuel.
                 *
                 * This bit shall indicate whether the HVAC system uses fuel.
                 *
                 *   • 0 = Does not use fuel
                 *
                 *   • 1 = Uses fuel
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.4
                 */
                heatingUsesFuel: BitFlag;
            }>, any>;
            /**
             * Indicates when the local temperature, outdoor temperature and occupancy are being sensed by remote
             * networked sensors, rather than internal sensors.
             *
             * If the LTNE feature is present in the server, the LocalTemperature RemoteSensing bit value shall always
             * report a value of 0.
             *
             * If the LocalTemperature RemoteSensing bit is written with a value of 1 when the LTNE feature is present,
             * the write shall fail and the server shall report a CONSTRAINT_ERROR.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.23
             */
            readonly remoteSensing: OptionalWritableAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Calculated Local Temperature is derived from a remote node
                 */
                localTemperature: BitFlag;
                /**
                 * OutdoorTemperature is derived from a remote node
                 *
                 * This bit shall be supported if the OutdoorTemperature attribute is supported.
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.9.1
                 */
                outdoorTemperature: BitFlag;
                /**
                 * Occupancy is derived from a remote node
                 */
                occupancy: BitFlag;
            }>, any>;
            /**
             * Indicates the overall operating environment of the thermostat, and thus the possible system modes that
             * the thermostat can operate in.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.24
             */
            readonly controlSequenceOfOperation: WritableAttribute<ControlSequenceOfOperation, any>;
            /**
             * Indicates the current operating mode of the thermostat. Its value shall be limited by the
             * ControlSequenceOfOperation attribute.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.25
             */
            readonly systemMode: WritableAttribute<SystemMode, any>;
            /**
             * Indicates the temperature hold status on the thermostat. If hold status is on, the thermostat SHOULD
             * maintain the temperature setpoint for the current mode until a system mode change. If hold status is
             * off, the thermostat SHOULD follow the setpoint transitions specified by its internal scheduling program.
             * If the thermostat supports setpoint hold for a specific duration, it SHOULD also implement the
             * TemperatureSetpointHoldDuration attribute.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.31
             */
            readonly temperatureSetpointHold: OptionalWritableAttribute<TemperatureSetpointHold, any>;
            /**
             * Indicates the period in minutes for which a setpoint hold is active. Thermostats that support hold for a
             * specified duration SHOULD implement this attribute. The null value indicates the field is unused. All
             * other values are reserved.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.32
             */
            readonly temperatureSetpointHoldDuration: OptionalWritableAttribute<number | null, any>;
            /**
             * Indicates the operational state of the thermostat’s programming. The thermostat shall modify its
             * programming operation when this attribute is modified by a client and update this attribute when its
             * programming operation is modified locally by a user. The thermostat may support more than one active
             * ProgrammingOperationModeBitmap. For example, the thermostat may operate simultaneously in Schedule
             * Programming Mode and Recovery Mode.
             *
             * Thermostats which contain a schedule may use this attribute to control how that schedule is used, even
             * if they do not support the ScheduleConfiguration feature.
             *
             * When ScheduleActive is not set, the setpoint is altered only by manual up/down changes at the thermostat
             * or remotely, not by internal schedule programming.
             *
             * NOTE
             *
             * Modifying the ScheduleActive bit does not clear or delete previous weekly schedule programming
             * configurations.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.33
             */
            readonly thermostatProgrammingOperationMode: OptionalWritableAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Schedule programming mode. This enables any programmed weekly schedule configurations.
                 */
                scheduleActive: BitFlag;
                /**
                 * Auto/recovery mode
                 */
                autoRecovery: BitFlag;
                /**
                 * Economy/EnergyStar mode
                 */
                economy: BitFlag;
            }>, any>;
            /**
             * Indicates the current relay state of the heat, cool, and fan relays. Unimplemented outputs shall be
             * treated as if they were Off.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.34
             */
            readonly thermostatRunningState: OptionalAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Heat State On
                 */
                heat: BitFlag;
                /**
                 * Cool State On
                 */
                cool: BitFlag;
                /**
                 * Fan State On
                 */
                fan: BitFlag;
                /**
                 * Heat 2nd State On
                 */
                heatStage2: BitFlag;
                /**
                 * Cool 2nd State On
                 */
                coolStage2: BitFlag;
                /**
                 * Fan 2nd State On
                 */
                fanStage2: BitFlag;
                /**
                 * Fan 3rd Stage On
                 */
                fanStage3: BitFlag;
            }>, any>;
            /**
             * Indicates the source of the current active OccupiedCoolingSetpoint or OccupiedHeatingSetpoint (i.e., who
             * or what determined the current setpoint).
             *
             * This attribute enables service providers to determine whether changes to setpoints were initiated due to
             * occupant comfort, scheduled programming or some other source (e.g., electric utility or other service
             * provider). Because automation services may initiate frequent setpoint changes, this attribute clearly
             * differentiates the source of setpoint changes made at the thermostat.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.35
             */
            readonly setpointChangeSource: OptionalAttribute<SetpointChangeSource, any>;
            /**
             * Indicates the delta between the current active OccupiedCoolingSetpoint or OccupiedHeatingSetpoint and
             * the previous active setpoint. This attribute is meant to accompany the SetpointChangeSource attribute;
             * devices implementing SetpointChangeAmount SHOULD also implement SetpointChangeSource.
             *
             * The null value indicates that the previous setpoint was unknown.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.36
             */
            readonly setpointChangeAmount: OptionalAttribute<number | null, any>;
            /**
             * Indicates the time in UTC at which the SetpointChangeAmount attribute change was recorded.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.37
             */
            readonly setpointChangeSourceTimestamp: OptionalAttribute<number, any>;
            /**
             * Indicates the delta between the Calculated Local Temperature and the OccupiedHeatingSetpoint or
             * UnoccupiedHeatingSetpoint attributes at which the Thermostat server will operate in emergency heat mode.
             *
             * If the difference between the Calculated Local Temperature and OccupiedCoolingSetpoint or
             * UnoccupiedCoolingSetpoint is greater than or equal to the EmergencyHeatDelta and the Thermostat server’s
             * SystemMode attribute is in a heating-related mode, then the Thermostat server shall immediately switch
             * to the SystemMode attribute value that provides the highest stage of heating (e.g., emergency heat) and
             * continue operating in that running state until the OccupiedHeatingSetpoint value is reached. For example:
             *
             *   • Calculated Local Temperature = 10.0°C
             *
             *   • OccupiedHeatingSetpoint = 16.0°C
             *
             *   • EmergencyHeatDelta = 2.0°C
             *
             * ⇒ OccupiedHeatingSetpoint - Calculated Local Temperature ≥? EmergencyHeatDelta
             *
             * ⇒ 16°C - 10°C ≥? 2°C
             *
             * ⇒ TRUE >>> Thermostat server changes its SystemMode to operate in 2nd stage or emergency heat mode
             *
             * The purpose of this attribute is to provide Thermostat clients the ability to configure rapid heating
             * when a setpoint is of a specified amount greater than the measured temperature. This allows the heated
             * space to be quickly heated to the desired level set by the user.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.44
             */
            readonly emergencyHeatDelta: OptionalWritableAttribute<number, any>;
            /**
             * Indicates the type of Mini Split ACTypeEnum of Mini Split AC is defined depending on how Cooling and
             * Heating condition is achieved by Mini Split AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.45
             */
            readonly acType: OptionalWritableAttribute<AcType, any>;
            /**
             * Indicates capacity of Mini Split AC in terms of the format defined by the ACCapacityFormat attribute
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.46
             */
            readonly acCapacity: OptionalWritableAttribute<number, any>;
            /**
             * Indicates type of refrigerant used within the Mini Split AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.47
             */
            readonly acRefrigerantType: OptionalWritableAttribute<AcRefrigerantType, any>;
            /**
             * Indicates the type of compressor used within the Mini Split AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.48
             */
            readonly acCompressorType: OptionalWritableAttribute<AcCompressorType, any>;
            /**
             * Indicates the type of errors encountered within the Mini Split AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.49
             */
            readonly acErrorCode: OptionalWritableAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Compressor Failure or Refrigerant Leakage
                 */
                compressorFail: BitFlag;
                /**
                 * Room Temperature Sensor Failure
                 */
                roomSensorFail: BitFlag;
                /**
                 * Outdoor Temperature Sensor Failure
                 */
                outdoorSensorFail: BitFlag;
                /**
                 * Indoor Coil Temperature Sensor Failure
                 */
                coilSensorFail: BitFlag;
                /**
                 * Fan Failure
                 */
                fanFail: BitFlag;
            }>, any>;
            /**
             * Indicates the position of Louver on the AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.50
             */
            readonly acLouverPosition: OptionalWritableAttribute<AcLouverPosition, any>;
            /**
             * Indicates the temperature of the AC coil, as measured locally or remotely (over the network).
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.51
             */
            readonly acCoilTemperature: OptionalAttribute<number | null, any>;
            /**
             * Indicates the format for the ACCapacity attribute.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.52
             */
            readonly acCapacityFormat: OptionalWritableAttribute<AcCapacityFormat, any>;
        };
        readonly commands: {
            /**
             * Upon receipt, the attributes for the indicated setpoint(s) shall have the amount specified in the Amount
             * field added to them. If the resulting value is outside the limits imposed by MinCoolSetpointLimit,
             * MaxCoolSetpointLimit, MinHeatSetpointLimit and MaxHeatSetpointLimit, the value is clamped to those
             * limits. This is not considered an error condition.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.1
             */
            readonly setpointRaiseLower: Command<import("../tlv/TlvObject.js").TypeFromFields<{
                mode: import("../tlv/TlvObject.js").FieldType<SetpointRaiseLowerMode>;
                amount: import("../tlv/TlvObject.js").FieldType<number>;
            }>, void, any>;
        };
        /**
         * This metadata controls which ThermostatCluster elements matter.js activates for specific feature
         * combinations.
         */
        readonly extensions: readonly [{
            readonly flags: {
                readonly occupancy: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates whether the heated/cooled space is occupied or not, as measured locally or remotely (over the
                     * network).
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.5
                     */
                    readonly occupancy: Attribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                        occupied: BitFlag;
                    }>, any>;
                };
            };
        }, {
            readonly flags: {
                readonly heating: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9
                     */
                    readonly absMinHeatSetpointLimit: OptionalFixedAttribute<number, any>;
                    /**
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9
                     */
                    readonly absMaxHeatSetpointLimit: OptionalFixedAttribute<number, any>;
                    /**
                     * Indicates the level of heating demanded by the PI loop in percent. This value is 0 when the thermostat
                     * is in “off” or “cooling” mode.
                     *
                     * This attribute is reported regularly and may be used to control a heating device.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.11
                     */
                    readonly piHeatingDemand: OptionalAttribute<number, any>;
                    /**
                     * Indicates the heating mode setpoint when the room is occupied.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute such that these
                     * constraints are violated, a response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * If the occupancy status of the room is unknown, this attribute shall be used as the heating mode
                     * setpoint.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.15
                     */
                    readonly occupiedHeatingSetpoint: WritableAttribute<number, any>;
                    /**
                     * Indicates the minimum level that the heating setpoint may be set to.
                     *
                     * This attribute, and the following three attributes, allow the user to define setpoint limits more
                     * constrictive than the manufacturer imposed ones. Limiting users (e.g., in a commercial building) to such
                     * setpoint limits can help conserve power.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
                     * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
                     * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
                     * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
                     * response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.18
                     */
                    readonly minHeatSetpointLimit: OptionalWritableAttribute<number, any>;
                    /**
                     * Indicates the maximum level that the heating setpoint may be set to.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
                     * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
                     * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
                     * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
                     * response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.19
                     */
                    readonly maxHeatSetpointLimit: OptionalWritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly cooling: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates the absolute minimum level that the cooling setpoint may be set to. This is a limitation
                     * imposed by the manufacturer.
                     *
                     * Refer to Setpoint Limits for constraints
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.8
                     */
                    readonly absMinCoolSetpointLimit: OptionalFixedAttribute<number, any>;
                    /**
                     * Indicates the absolute maximum level that the cooling setpoint may be set to. This is a limitation
                     * imposed by the manufacturer.
                     *
                     * Refer to Setpoint Limits for constraints
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.9
                     */
                    readonly absMaxCoolSetpointLimit: OptionalFixedAttribute<number, any>;
                    /**
                     * Indicates the level of cooling demanded by the PI (proportional integral) control loop in use by the
                     * thermostat (if any), in percent. This value is 0 when the thermostat is in “off” or “heating” mode.
                     *
                     * This attribute is reported regularly and may be used to control a cooling device.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.10
                     */
                    readonly piCoolingDemand: OptionalAttribute<number, any>;
                    /**
                     * Indicates the cooling mode setpoint when the room is occupied.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute such that these
                     * constraints are violated, a response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * If the occupancy status of the room is unknown, this attribute shall be used as the cooling mode
                     * setpoint.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.14
                     */
                    readonly occupiedCoolingSetpoint: WritableAttribute<number, any>;
                    /**
                     * Indicates the minimum level that the cooling setpoint may be set to.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
                     * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
                     * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
                     * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
                     * response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.20
                     */
                    readonly minCoolSetpointLimit: OptionalWritableAttribute<number, any>;
                    /**
                     * Indicates the maximum level that the cooling setpoint may be set to.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
                     * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
                     * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
                     * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
                     * response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.21
                     */
                    readonly maxCoolSetpointLimit: OptionalWritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly localTemperatureNotExposed: false;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates the offset the Thermostat server shall make to the measured temperature (locally or remotely)
                     * to adjust the Calculated Local Temperature prior to using, displaying or reporting it.
                     *
                     * The purpose of this attribute is to adjust the calibration of the Thermostat server per the user’s
                     * preferences (e.g., to match if there are multiple servers displaying different values for the same HVAC
                     * area) or compensate for variability amongst temperature sensors.
                     *
                     * If a Thermostat client attempts to write LocalTemperatureCalibration attribute to an unsupported value
                     * (e.g., out of the range supported by the Thermostat server), the Thermostat server shall respond with a
                     * status of SUCCESS and set the value of LocalTemperatureCalibration to the upper or lower limit reached.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.13
                     */
                    readonly localTemperatureCalibration: OptionalWritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly cooling: true;
                readonly occupancy: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates the cooling mode setpoint when the room is unoccupied.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute such that these
                     * constraints are violated, a response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * If the occupancy status of the room is unknown, this attribute shall NOT be used.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.16
                     */
                    readonly unoccupiedCoolingSetpoint: WritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly heating: true;
                readonly occupancy: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates the heating mode setpoint when the room is unoccupied.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute such that these
                     * constraints are violated, a response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * If the occupancy status of the room is unknown, this attribute shall NOT be used.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.17
                     */
                    readonly unoccupiedHeatingSetpoint: WritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly autoMode: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * On devices which support the AUTO feature, this attribute shall indicate the minimum difference between
                     * the Heat Setpoint and the Cool Setpoint.
                     *
                     * Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value which
                     * conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to permit
                     * this attribute to be set to the desired value. If an attempt is made to set this attribute to a value
                     * which is not consistent with the constraints and cannot be resolved by modifying setpoints then a
                     * response with the status code CONSTRAINT_ERROR shall be returned.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.22
                     */
                    readonly minSetpointDeadBand: WritableAttribute<number, any>;
                    /**
                     * Indicates the running mode of the thermostat. This attribute uses the same values as SystemModeEnum but
                     * can only be Off, Cool or Heat. This attribute is intended to provide additional information when the
                     * thermostat’s system mode is in auto mode.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.27
                     */
                    readonly thermostatRunningMode: OptionalAttribute<ThermostatRunningMode, any>;
                };
            };
        }, {
            readonly flags: {
                readonly scheduleConfiguration: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates the day of the week that this thermostat considers to be the start of week for weekly setpoint
                     * scheduling.
                     *
                     * This attribute may be able to be used as the base to determine if the device supports weekly scheduling
                     * by reading the attribute. Successful response means that the weekly scheduling is supported.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.28
                     */
                    readonly startOfWeek: FixedAttribute<StartOfWeek, any>;
                    /**
                     * Indicates how many weekly schedule transitions the thermostat is capable of handling.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.29
                     */
                    readonly numberOfWeeklyTransitions: FixedAttribute<number, any>;
                    /**
                     * Indicates how many daily schedule transitions the thermostat is capable of handling.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.30
                     */
                    readonly numberOfDailyTransitions: FixedAttribute<number, any>;
                };
                readonly commands: {
                    /**
                     * Upon receipt, the weekly schedule for updating setpoints shall be stored in the thermostat and SHOULD
                     * begin at the time of receipt. A status code shall be sent in response.
                     *
                     * When a command is received that requires a total number of transitions greater than the device supports,
                     * the status of the response shall be INSUFFICIENT_SPACE.
                     *
                     * When any of the setpoints sent in the sequence is out of range (AbsMin/MaxSetPointLimit), or when the
                     * Mode for Sequence field includes a mode not supported by the device, the status of the response shall be
                     * CONSTRAINT_ERROR and no setpoints from the entire sequence SHOULD be used.
                     *
                     * When an overlapping transition is detected, the status of the response shall be FAILURE.
                     *
                     * When a device which does not support multiple days in a command receives a command with more than one
                     * bit set in the DayOfWeekForSequence field, or when a device which does not support multiple modes in a
                     * command receives a command with more than one bit set in the ModeForSequence field, or when the contents
                     * of the Transitions field does not agree with NumberOfTransitionsForSequence, DayOfWeekForSequence or
                     * ModeForSequence, the status of the response shall be INVALID_COMMAND.
                     *
                     * When the transitions could be added successfully, the status of the response shall be SUCCESS.
                     *
                     * The set weekly schedule command is used to update the thermostat weekly setpoint schedule from a
                     * management system. If the thermostat already has a weekly setpoint schedule programmed, then it SHOULD
                     * replace each daily setpoint set as it receives the updates from the management system. For example, if
                     * the thermostat has 4 setpoints for every day of the week and is sent a Set Weekly Schedule command with
                     * one setpoint for Saturday then the thermostat SHOULD remove all 4 setpoints for Saturday and replace
                     * those with the updated setpoint but leave all other days unchanged. If the schedule is larger than what
                     * fits in one frame or contains more than 10 transitions, the schedule shall then be sent using multiple
                     * Set Weekly Schedule Commands.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4
                     */
                    readonly setWeeklySchedule: Command<import("../tlv/TlvObject.js").TypeFromFields<{
                        /**
                         * This field shall indicate how many individual transitions to expect for this sequence of commands. If a
                         * device supports more than 10 transitions in its schedule they can send this by sending more than 1 “Set
                         * Weekly Schedule” command, each containing the separate information that the device needs to set.
                         *
                         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.1
                         */
                        numberOfTransitionsForSequence: import("../tlv/TlvObject.js").FieldType<number>;
                        /**
                         * This field shall represent the day of the week at which all the transitions within the payload of the
                         * command SHOULD be associated to. This field is a bitmap and therefore the associated setpoint could overlap
                         * onto multiple days (you could set one transition time for all “week days” or whatever combination of days
                         * the implementation requests).
                         *
                         * Each setpoint transition will begin with the day of week for this transition. There can be up to 10
                         * transitions for each command.
                         *
                         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.2
                         */
                        dayOfWeekForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                            /**
                             * Sunday
                             */
                            sunday: BitFlag;
                            /**
                             * Monday
                             */
                            monday: BitFlag;
                            /**
                             * Tuesday
                             */
                            tuesday: BitFlag;
                            /**
                             * Wednesday
                             */
                            wednesday: BitFlag;
                            /**
                             * Thursday
                             */
                            thursday: BitFlag;
                            /**
                             * Friday
                             */
                            friday: BitFlag;
                            /**
                             * Saturday
                             */
                            saturday: BitFlag;
                            /**
                             * Away or Vacation
                             */
                            away: BitFlag;
                        }>>;
                        /**
                         * This field shall indicate how the application decodes the setpoint fields of each transition in the
                         * Transitions list.
                         *
                         * If the HeatSetpointPresent bit is On, the HeatSetpoint field shall NOT be null in every entry of the
                         * Transitions list.
                         *
                         * If the HeatSetpointPresent bit is Off, the HeatSetpoint field shall be null in every entry of the
                         * Transitions list.
                         *
                         * If the CoolSetpointPresent bit is On, the CoolSetpoint field shall NOT be null in every entry of the
                         * Transitions list.
                         *
                         * If the CoolSetpointPresent bit is Off, the CoolSetpoint field shall be null in every entry of the
                         * Transitions list.
                         *
                         * At least one of the bits in the Mode For Sequence byte shall be on.
                         *
                         * Both bits must be respected, even if the HEAT or COOL feature is not supported, to ensure the command is
                         * decoded and handled correctly.
                         *
                         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.3
                         */
                        modeForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                            /**
                             * Adjust Heat Setpoint
                             */
                            heatSetpointPresent: BitFlag;
                            /**
                             * Adjust Cool Setpoint
                             */
                            coolSetpointPresent: BitFlag;
                        }>>;
                        /**
                         * This field shall contain the list of setpoint transitions used to update the specified daily schedules
                         *
                         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.4
                         */
                        transitions: import("../tlv/TlvObject.js").FieldType<import("../tlv/TlvObject.js").TypeFromFields<{
                            /**
                             * This field shall represent the start time of the schedule transition during the associated day. The time
                             * will be represented by a 16 bits unsigned integer to designate the minutes since midnight. For example, 6am
                             * will be represented by 360 minutes since midnight and 11:30pm will be represented by 1410 minutes since
                             * midnight.
                             *
                             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.1
                             */
                            transitionTime: import("../tlv/TlvObject.js").FieldType<number>;
                            /**
                             * This field shall represent the heat setpoint to be applied at this associated transition start time.
                             *
                             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.2
                             */
                            heatSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                            /**
                             * This field shall represent the cool setpoint to be applied at this associated transition start time.
                             *
                             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.3
                             */
                            coolSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                        }>[]>;
                    }>, void, any>;
                    /**
                     * Upon receipt, the unit SHOULD send in return the Get Weekly Schedule Response command. The Days to
                     * Return and Mode to Return fields are defined as bitmask for the flexibility to support multiple days and
                     * multiple modes within one command. If thermostat cannot handle incoming command with multiple days
                     * and/or multiple modes within one command, it shall send default response of INVALID_COMMAND in return.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5
                     */
                    readonly getWeeklySchedule: Command<import("../tlv/TlvObject.js").TypeFromFields<{
                        /**
                         * This field shall indicate the number of days the client would like to return the setpoint values for and
                         * could be any combination of single days or the entire week.
                         *
                         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5.1
                         */
                        daysToReturn: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                            /**
                             * Sunday
                             */
                            sunday: BitFlag;
                            /**
                             * Monday
                             */
                            monday: BitFlag;
                            /**
                             * Tuesday
                             */
                            tuesday: BitFlag;
                            /**
                             * Wednesday
                             */
                            wednesday: BitFlag;
                            /**
                             * Thursday
                             */
                            thursday: BitFlag;
                            /**
                             * Friday
                             */
                            friday: BitFlag;
                            /**
                             * Saturday
                             */
                            saturday: BitFlag;
                            /**
                             * Away or Vacation
                             */
                            away: BitFlag;
                        }>>;
                        /**
                         * This field shall indicate the mode the client would like to return the set point values for and could be any
                         * combination of heat only, cool only or heat & cool.
                         *
                         * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5.2
                         */
                        modeToReturn: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                            /**
                             * Adjust Heat Setpoint
                             */
                            heatSetpointPresent: BitFlag;
                            /**
                             * Adjust Cool Setpoint
                             */
                            coolSetpointPresent: BitFlag;
                        }>>;
                    }>, import("../tlv/TlvObject.js").TypeFromFields<{
                        numberOfTransitionsForSequence: import("../tlv/TlvObject.js").FieldType<number>;
                        dayOfWeekForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                            /**
                             * Sunday
                             */
                            sunday: BitFlag;
                            /**
                             * Monday
                             */
                            monday: BitFlag;
                            /**
                             * Tuesday
                             */
                            tuesday: BitFlag;
                            /**
                             * Wednesday
                             */
                            wednesday: BitFlag;
                            /**
                             * Thursday
                             */
                            thursday: BitFlag;
                            /**
                             * Friday
                             */
                            friday: BitFlag;
                            /**
                             * Saturday
                             */
                            saturday: BitFlag;
                            /**
                             * Away or Vacation
                             */
                            away: BitFlag;
                        }>>;
                        modeForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                            /**
                             * Adjust Heat Setpoint
                             */
                            heatSetpointPresent: BitFlag;
                            /**
                             * Adjust Cool Setpoint
                             */
                            coolSetpointPresent: BitFlag;
                        }>>;
                        transitions: import("../tlv/TlvObject.js").FieldType<import("../tlv/TlvObject.js").TypeFromFields<{
                            /**
                             * This field shall represent the start time of the schedule transition during the associated day. The time
                             * will be represented by a 16 bits unsigned integer to designate the minutes since midnight. For example, 6am
                             * will be represented by 360 minutes since midnight and 11:30pm will be represented by 1410 minutes since
                             * midnight.
                             *
                             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.1
                             */
                            transitionTime: import("../tlv/TlvObject.js").FieldType<number>;
                            /**
                             * This field shall represent the heat setpoint to be applied at this associated transition start time.
                             *
                             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.2
                             */
                            heatSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                            /**
                             * This field shall represent the cool setpoint to be applied at this associated transition start time.
                             *
                             * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.3
                             */
                            coolSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                        }>[]>;
                    }>, any>;
                    /**
                     * This command is used to clear the weekly schedule. The Clear weekly schedule has no payload.
                     *
                     * Upon receipt, all transitions currently stored shall be cleared and a default response of SUCCESS shall
                     * be sent in response. There are no error responses to this command.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.7
                     */
                    readonly clearWeeklySchedule: Command<void, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly setback: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates the amount that the Thermostat server will allow the Calculated Local Temperature to float
                     * above the OccupiedCoolingSetpoint (i.e., OccupiedCoolingSetpoint + OccupiedSetback) or below the
                     * OccupiedHeatingSetpoint setpoint (i.e., OccupiedHeatingSetpoint – OccupiedSetback) before initiating a
                     * state change to bring the temperature back to the user’s desired setpoint. This attribute is sometimes
                     * also referred to as the “span.”
                     *
                     * The purpose of this attribute is to allow remote configuration of the span between the desired setpoint
                     * and the measured temperature to help prevent over-cycling and reduce energy bills, though this may
                     * result in lower comfort on the part of some users.
                     *
                     * The null value indicates the attribute is unused.
                     *
                     * If the Thermostat client attempts to write OccupiedSetback to a value greater than OccupiedSetbackMax,
                     * the Thermostat server shall set its OccupiedSetback value to OccupiedSetbackMax and shall send a Write
                     * Attribute Response command with a Status Code field enumeration of SUCCESS response.
                     *
                     * If the Thermostat client attempts to write OccupiedSetback to a value less than OccupiedSetbackMin, the
                     * Thermostat server shall set its OccupiedSetback value to OccupiedSetbackMin and shall send a Write
                     * Attribute Response command with a Status Code field enumeration of SUCCESS response.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.38
                     */
                    readonly occupiedSetback: WritableAttribute<number | null, any>;
                    /**
                     * Indicates the minimum value that the Thermostat server will allow the OccupiedSetback attribute to be
                     * configured by a user.
                     *
                     * The null value indicates the attribute is unused.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.39
                     */
                    readonly occupiedSetbackMin: FixedAttribute<number | null, any>;
                    /**
                     * Indicates the maximum value that the Thermostat server will allow the OccupiedSetback attribute to be
                     * configured by a user.
                     *
                     * The null value indicates the attribute is unused.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.40
                     */
                    readonly occupiedSetbackMax: FixedAttribute<number | null, any>;
                };
            };
        }, {
            readonly flags: {
                readonly setback: true;
                readonly occupancy: true;
            };
            readonly component: {
                readonly attributes: {
                    /**
                     * Indicates the amount that the Thermostat server will allow the Calculated Local Temperature to float
                     * above the UnoccupiedCoolingSetpoint (i.e., UnoccupiedCoolingSetpoint + UnoccupiedSetback) or below the
                     * UnoccupiedHeatingSetpoint setpoint (i.e., UnoccupiedHeatingSetpoint - UnoccupiedSetback) before
                     * initiating a state change to bring the temperature back to the user’s desired setpoint. This attribute
                     * is sometimes also referred to as the “span.”
                     *
                     * The purpose of this attribute is to allow remote configuration of the span between the desired setpoint
                     * and the measured temperature to help prevent over-cycling and reduce energy bills, though this may
                     * result in lower comfort on the part of some users.
                     *
                     * The null value indicates the attribute is unused.
                     *
                     * If the Thermostat client attempts to write UnoccupiedSetback to a value greater than
                     * UnoccupiedSetbackMax, the Thermostat server shall set its UnoccupiedSetback value to
                     * UnoccupiedSetbackMax and shall send a Write Attribute Response command with a Status Code field
                     * enumeration of SUCCESS response.
                     *
                     * If the Thermostat client attempts to write UnoccupiedSetback to a value less than UnoccupiedSetbackMin,
                     * the Thermostat server shall set its UnoccupiedSetback value to UnoccupiedSetbackMin and shall send a
                     * Write Attribute Response command with a Status Code field enumeration of SUCCESS response.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.41
                     */
                    readonly unoccupiedSetback: WritableAttribute<number | null, any>;
                    /**
                     * Indicates the minimum value that the Thermostat server will allow the UnoccupiedSetback attribute to be
                     * configured by a user.
                     *
                     * The null value indicates the attribute is unused.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.42
                     */
                    readonly unoccupiedSetbackMin: FixedAttribute<number | null, any>;
                    /**
                     * Indicates the maximum value that the Thermostat server will allow the UnoccupiedSetback attribute to be
                     * configured by a user.
                     *
                     * The null value indicates the attribute is unused.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.43
                     */
                    readonly unoccupiedSetbackMax: FixedAttribute<number | null, any>;
                };
            };
        }, {
            readonly flags: {
                readonly autoMode: true;
                readonly heating: false;
            };
            readonly component: false;
        }, {
            readonly flags: {
                readonly autoMode: true;
                readonly cooling: false;
            };
            readonly component: false;
        }, {
            readonly flags: {
                readonly heating: false;
                readonly cooling: false;
            };
            readonly component: false;
        }];
    }>;
    /**
     * This cluster provides an interface to the functionality of a thermostat.
     *
     * Per the Matter specification you cannot use {@link ThermostatCluster} without enabling certain feature
     * combinations. You must use the {@link with} factory method to obtain a working cluster.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 4.3
     */
    interface Cluster extends Identity<typeof ClusterInstance> {
    }
    const Cluster: Cluster;
    /**
     * @see {@link Complete}
     */
    const CompleteInstance: MutableCluster<{
        readonly id: 513;
        readonly name: "Thermostat";
        readonly revision: 6;
        readonly features: {
            /**
             * Heating
             *
             * Thermostat is capable of managing a heating device
             */
            readonly heating: BitFlag;
            /**
             * Cooling
             *
             * Thermostat is capable of managing a cooling device
             */
            readonly cooling: BitFlag;
            /**
             * Occupancy
             *
             * Supports Occupied and Unoccupied setpoints
             */
            readonly occupancy: BitFlag;
            /**
             * ScheduleConfiguration
             *
             * Supports remote configuration of a weekly schedule of setpoint transitions
             */
            readonly scheduleConfiguration: BitFlag;
            /**
             * Setback
             *
             * Supports configurable setback (or span)
             */
            readonly setback: BitFlag;
            /**
             * AutoMode
             *
             * Supports a System Mode of Auto
             */
            readonly autoMode: BitFlag;
            /**
             * LocalTemperatureNotExposed
             *
             * This feature indicates that the Calculated Local Temperature used internally is unavailable to report
             * externally, for example due to the temperature control being done by a separate subsystem which does not
             * offer a view into the currently measured temperature, but allows setpoints to be provided.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.4.1
             */
            readonly localTemperatureNotExposed: BitFlag;
        };
        readonly attributes: {
            readonly occupancy: Attribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                occupied: BitFlag;
            }>, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    occupancy: boolean;
                }];
            };
            readonly absMinHeatSetpointLimit: OptionalFixedAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | [{
                    heating: boolean;
                }];
                readonly mandatoryIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
            };
            readonly absMaxHeatSetpointLimit: OptionalFixedAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | [{
                    heating: boolean;
                }];
                readonly mandatoryIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
            };
            readonly absMinCoolSetpointLimit: OptionalFixedAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | [{
                    cooling: boolean;
                }];
                readonly mandatoryIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
            };
            readonly absMaxCoolSetpointLimit: OptionalFixedAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | [{
                    cooling: boolean;
                }];
                readonly mandatoryIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
            };
            readonly piCoolingDemand: OptionalAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | [{
                    cooling: boolean;
                }];
                readonly mandatoryIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
            };
            readonly piHeatingDemand: OptionalAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | [{
                    heating: boolean;
                }];
                readonly mandatoryIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
            };
            readonly localTemperatureCalibration: OptionalWritableAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [];
                readonly mandatoryIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
            };
            readonly occupiedCoolingSetpoint: WritableAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    cooling: boolean;
                }];
            };
            readonly occupiedHeatingSetpoint: WritableAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    heating: boolean;
                }];
            };
            readonly unoccupiedCoolingSetpoint: WritableAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    cooling: boolean;
                    occupancy: boolean;
                }];
            };
            readonly unoccupiedHeatingSetpoint: WritableAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    heating: boolean;
                    occupancy: boolean;
                }];
            };
            readonly minHeatSetpointLimit: OptionalWritableAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | [{
                    heating: boolean;
                }];
                readonly mandatoryIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
            };
            readonly maxHeatSetpointLimit: OptionalWritableAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | [{
                    heating: boolean;
                }];
                readonly mandatoryIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
            };
            readonly minCoolSetpointLimit: OptionalWritableAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | [{
                    cooling: boolean;
                }];
                readonly mandatoryIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
            };
            readonly maxCoolSetpointLimit: OptionalWritableAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | [{
                    cooling: boolean;
                }];
                readonly mandatoryIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
            };
            readonly minSetpointDeadBand: WritableAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    autoMode: boolean;
                }];
            };
            readonly thermostatRunningMode: OptionalAttribute<ThermostatRunningMode, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | [{
                    autoMode: boolean;
                }];
                readonly mandatoryIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
            };
            readonly startOfWeek: FixedAttribute<StartOfWeek, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    scheduleConfiguration: boolean;
                }];
            };
            readonly numberOfWeeklyTransitions: FixedAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    scheduleConfiguration: boolean;
                }];
            };
            readonly numberOfDailyTransitions: FixedAttribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    scheduleConfiguration: boolean;
                }];
            };
            readonly occupiedSetback: WritableAttribute<number | null, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    setback: boolean;
                }];
            };
            readonly occupiedSetbackMin: FixedAttribute<number | null, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    setback: boolean;
                }];
            };
            readonly occupiedSetbackMax: FixedAttribute<number | null, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    setback: boolean;
                }];
            };
            readonly unoccupiedSetback: WritableAttribute<number | null, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    setback: boolean;
                    occupancy: boolean;
                }];
            };
            readonly unoccupiedSetbackMin: FixedAttribute<number | null, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    setback: boolean;
                    occupancy: boolean;
                }];
            };
            readonly unoccupiedSetbackMax: FixedAttribute<number | null, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    setback: boolean;
                    occupancy: boolean;
                }];
            };
            /**
             * Indicates the current Calculated Local Temperature, when available.
             *
             *   • If the LTNE feature is not supported:
             *
             *     ◦ If the LocalTemperatureCalibration is invalid or currently unavailable, the attribute shall report
             *       null.
             *
             *     ◦ If the LocalTemperatureCalibration is valid, the attribute shall report that value.
             *
             *   • Otherwise, if the LTNE feature is supported, there is no feedback externally available for the
             *     LocalTemperatureCalibration. In that case, the LocalTemperature attribute shall always report null.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.3
             */
            readonly localTemperature: Attribute<number | null, any>;
            /**
             * Indicates the outdoor temperature, as measured locally or remotely (over the network).
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.4
             */
            readonly outdoorTemperature: OptionalAttribute<number | null, any>;
            /**
             * Indicates the HVAC system type controlled by the thermostat. If the thermostat uses physical DIP
             * switches to set these parameters, this information shall be available read-only from the DIP switches.
             * If these parameters are set via software, there shall be read/write access in order to provide remote
             * programming capability.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.12
             * @deprecated
             */
            readonly hvacSystemTypeConfiguration: OptionalWritableAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Stage of cooling the HVAC system is using.
                 *
                 * These bits shall indicate what stage of cooling the HVAC system is using.
                 *
                 *   • 00 = Cool Stage 1
                 *
                 *   • 01 = Cool Stage 2
                 *
                 *   • 10 = Cool Stage 3
                 *
                 *   • 11 = Reserved
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.1
                 */
                coolingStage: BitField;
                /**
                 * Stage of heating the HVAC system is using.
                 *
                 * These bits shall indicate what stage of heating the HVAC system is using.
                 *
                 *   • 00 = Heat Stage 1
                 *
                 *   • 01 = Heat Stage 2
                 *
                 *   • 10 = Heat Stage 3
                 *
                 *   • 11 = Reserved
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.2
                 */
                heatingStage: BitField;
                /**
                 * Is the heating type Heat Pump.
                 *
                 * This bit shall indicate whether the HVAC system is conventional or a heat pump.
                 *
                 *   • 0 = Conventional
                 *
                 *   • 1 = Heat Pump
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.3
                 */
                heatingIsHeatPump: BitFlag;
                /**
                 * Does the HVAC system use fuel.
                 *
                 * This bit shall indicate whether the HVAC system uses fuel.
                 *
                 *   • 0 = Does not use fuel
                 *
                 *   • 1 = Uses fuel
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.6.4
                 */
                heatingUsesFuel: BitFlag;
            }>, any>;
            /**
             * Indicates when the local temperature, outdoor temperature and occupancy are being sensed by remote
             * networked sensors, rather than internal sensors.
             *
             * If the LTNE feature is present in the server, the LocalTemperature RemoteSensing bit value shall always
             * report a value of 0.
             *
             * If the LocalTemperature RemoteSensing bit is written with a value of 1 when the LTNE feature is present,
             * the write shall fail and the server shall report a CONSTRAINT_ERROR.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.23
             */
            readonly remoteSensing: OptionalWritableAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Calculated Local Temperature is derived from a remote node
                 */
                localTemperature: BitFlag;
                /**
                 * OutdoorTemperature is derived from a remote node
                 *
                 * This bit shall be supported if the OutdoorTemperature attribute is supported.
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.9.1
                 */
                outdoorTemperature: BitFlag;
                /**
                 * Occupancy is derived from a remote node
                 */
                occupancy: BitFlag;
            }>, any>;
            /**
             * Indicates the overall operating environment of the thermostat, and thus the possible system modes that
             * the thermostat can operate in.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.24
             */
            readonly controlSequenceOfOperation: WritableAttribute<ControlSequenceOfOperation, any>;
            /**
             * Indicates the current operating mode of the thermostat. Its value shall be limited by the
             * ControlSequenceOfOperation attribute.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.25
             */
            readonly systemMode: WritableAttribute<SystemMode, any>;
            /**
             * Indicates the temperature hold status on the thermostat. If hold status is on, the thermostat SHOULD
             * maintain the temperature setpoint for the current mode until a system mode change. If hold status is
             * off, the thermostat SHOULD follow the setpoint transitions specified by its internal scheduling program.
             * If the thermostat supports setpoint hold for a specific duration, it SHOULD also implement the
             * TemperatureSetpointHoldDuration attribute.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.31
             */
            readonly temperatureSetpointHold: OptionalWritableAttribute<TemperatureSetpointHold, any>;
            /**
             * Indicates the period in minutes for which a setpoint hold is active. Thermostats that support hold for a
             * specified duration SHOULD implement this attribute. The null value indicates the field is unused. All
             * other values are reserved.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.32
             */
            readonly temperatureSetpointHoldDuration: OptionalWritableAttribute<number | null, any>;
            /**
             * Indicates the operational state of the thermostat’s programming. The thermostat shall modify its
             * programming operation when this attribute is modified by a client and update this attribute when its
             * programming operation is modified locally by a user. The thermostat may support more than one active
             * ProgrammingOperationModeBitmap. For example, the thermostat may operate simultaneously in Schedule
             * Programming Mode and Recovery Mode.
             *
             * Thermostats which contain a schedule may use this attribute to control how that schedule is used, even
             * if they do not support the ScheduleConfiguration feature.
             *
             * When ScheduleActive is not set, the setpoint is altered only by manual up/down changes at the thermostat
             * or remotely, not by internal schedule programming.
             *
             * NOTE
             *
             * Modifying the ScheduleActive bit does not clear or delete previous weekly schedule programming
             * configurations.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.33
             */
            readonly thermostatProgrammingOperationMode: OptionalWritableAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Schedule programming mode. This enables any programmed weekly schedule configurations.
                 */
                scheduleActive: BitFlag;
                /**
                 * Auto/recovery mode
                 */
                autoRecovery: BitFlag;
                /**
                 * Economy/EnergyStar mode
                 */
                economy: BitFlag;
            }>, any>;
            /**
             * Indicates the current relay state of the heat, cool, and fan relays. Unimplemented outputs shall be
             * treated as if they were Off.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.34
             */
            readonly thermostatRunningState: OptionalAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Heat State On
                 */
                heat: BitFlag;
                /**
                 * Cool State On
                 */
                cool: BitFlag;
                /**
                 * Fan State On
                 */
                fan: BitFlag;
                /**
                 * Heat 2nd State On
                 */
                heatStage2: BitFlag;
                /**
                 * Cool 2nd State On
                 */
                coolStage2: BitFlag;
                /**
                 * Fan 2nd State On
                 */
                fanStage2: BitFlag;
                /**
                 * Fan 3rd Stage On
                 */
                fanStage3: BitFlag;
            }>, any>;
            /**
             * Indicates the source of the current active OccupiedCoolingSetpoint or OccupiedHeatingSetpoint (i.e., who
             * or what determined the current setpoint).
             *
             * This attribute enables service providers to determine whether changes to setpoints were initiated due to
             * occupant comfort, scheduled programming or some other source (e.g., electric utility or other service
             * provider). Because automation services may initiate frequent setpoint changes, this attribute clearly
             * differentiates the source of setpoint changes made at the thermostat.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.35
             */
            readonly setpointChangeSource: OptionalAttribute<SetpointChangeSource, any>;
            /**
             * Indicates the delta between the current active OccupiedCoolingSetpoint or OccupiedHeatingSetpoint and
             * the previous active setpoint. This attribute is meant to accompany the SetpointChangeSource attribute;
             * devices implementing SetpointChangeAmount SHOULD also implement SetpointChangeSource.
             *
             * The null value indicates that the previous setpoint was unknown.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.36
             */
            readonly setpointChangeAmount: OptionalAttribute<number | null, any>;
            /**
             * Indicates the time in UTC at which the SetpointChangeAmount attribute change was recorded.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.37
             */
            readonly setpointChangeSourceTimestamp: OptionalAttribute<number, any>;
            /**
             * Indicates the delta between the Calculated Local Temperature and the OccupiedHeatingSetpoint or
             * UnoccupiedHeatingSetpoint attributes at which the Thermostat server will operate in emergency heat mode.
             *
             * If the difference between the Calculated Local Temperature and OccupiedCoolingSetpoint or
             * UnoccupiedCoolingSetpoint is greater than or equal to the EmergencyHeatDelta and the Thermostat server’s
             * SystemMode attribute is in a heating-related mode, then the Thermostat server shall immediately switch
             * to the SystemMode attribute value that provides the highest stage of heating (e.g., emergency heat) and
             * continue operating in that running state until the OccupiedHeatingSetpoint value is reached. For example:
             *
             *   • Calculated Local Temperature = 10.0°C
             *
             *   • OccupiedHeatingSetpoint = 16.0°C
             *
             *   • EmergencyHeatDelta = 2.0°C
             *
             * ⇒ OccupiedHeatingSetpoint - Calculated Local Temperature ≥? EmergencyHeatDelta
             *
             * ⇒ 16°C - 10°C ≥? 2°C
             *
             * ⇒ TRUE >>> Thermostat server changes its SystemMode to operate in 2nd stage or emergency heat mode
             *
             * The purpose of this attribute is to provide Thermostat clients the ability to configure rapid heating
             * when a setpoint is of a specified amount greater than the measured temperature. This allows the heated
             * space to be quickly heated to the desired level set by the user.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.44
             */
            readonly emergencyHeatDelta: OptionalWritableAttribute<number, any>;
            /**
             * Indicates the type of Mini Split ACTypeEnum of Mini Split AC is defined depending on how Cooling and
             * Heating condition is achieved by Mini Split AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.45
             */
            readonly acType: OptionalWritableAttribute<AcType, any>;
            /**
             * Indicates capacity of Mini Split AC in terms of the format defined by the ACCapacityFormat attribute
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.46
             */
            readonly acCapacity: OptionalWritableAttribute<number, any>;
            /**
             * Indicates type of refrigerant used within the Mini Split AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.47
             */
            readonly acRefrigerantType: OptionalWritableAttribute<AcRefrigerantType, any>;
            /**
             * Indicates the type of compressor used within the Mini Split AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.48
             */
            readonly acCompressorType: OptionalWritableAttribute<AcCompressorType, any>;
            /**
             * Indicates the type of errors encountered within the Mini Split AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.49
             */
            readonly acErrorCode: OptionalWritableAttribute<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                /**
                 * Compressor Failure or Refrigerant Leakage
                 */
                compressorFail: BitFlag;
                /**
                 * Room Temperature Sensor Failure
                 */
                roomSensorFail: BitFlag;
                /**
                 * Outdoor Temperature Sensor Failure
                 */
                outdoorSensorFail: BitFlag;
                /**
                 * Indoor Coil Temperature Sensor Failure
                 */
                coilSensorFail: BitFlag;
                /**
                 * Fan Failure
                 */
                fanFail: BitFlag;
            }>, any>;
            /**
             * Indicates the position of Louver on the AC.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.50
             */
            readonly acLouverPosition: OptionalWritableAttribute<AcLouverPosition, any>;
            /**
             * Indicates the temperature of the AC coil, as measured locally or remotely (over the network).
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.51
             */
            readonly acCoilTemperature: OptionalAttribute<number | null, any>;
            /**
             * Indicates the format for the ACCapacity attribute.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.9.52
             */
            readonly acCapacityFormat: OptionalWritableAttribute<AcCapacityFormat, any>;
        };
        readonly commands: {
            readonly setWeeklySchedule: Command<import("../tlv/TlvObject.js").TypeFromFields<{
                /**
                 * This field shall indicate how many individual transitions to expect for this sequence of commands. If a
                 * device supports more than 10 transitions in its schedule they can send this by sending more than 1 “Set
                 * Weekly Schedule” command, each containing the separate information that the device needs to set.
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.1
                 */
                numberOfTransitionsForSequence: import("../tlv/TlvObject.js").FieldType<number>;
                /**
                 * This field shall represent the day of the week at which all the transitions within the payload of the
                 * command SHOULD be associated to. This field is a bitmap and therefore the associated setpoint could overlap
                 * onto multiple days (you could set one transition time for all “week days” or whatever combination of days
                 * the implementation requests).
                 *
                 * Each setpoint transition will begin with the day of week for this transition. There can be up to 10
                 * transitions for each command.
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.2
                 */
                dayOfWeekForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                    /**
                     * Sunday
                     */
                    sunday: BitFlag;
                    /**
                     * Monday
                     */
                    monday: BitFlag;
                    /**
                     * Tuesday
                     */
                    tuesday: BitFlag;
                    /**
                     * Wednesday
                     */
                    wednesday: BitFlag;
                    /**
                     * Thursday
                     */
                    thursday: BitFlag;
                    /**
                     * Friday
                     */
                    friday: BitFlag;
                    /**
                     * Saturday
                     */
                    saturday: BitFlag;
                    /**
                     * Away or Vacation
                     */
                    away: BitFlag;
                }>>;
                /**
                 * This field shall indicate how the application decodes the setpoint fields of each transition in the
                 * Transitions list.
                 *
                 * If the HeatSetpointPresent bit is On, the HeatSetpoint field shall NOT be null in every entry of the
                 * Transitions list.
                 *
                 * If the HeatSetpointPresent bit is Off, the HeatSetpoint field shall be null in every entry of the
                 * Transitions list.
                 *
                 * If the CoolSetpointPresent bit is On, the CoolSetpoint field shall NOT be null in every entry of the
                 * Transitions list.
                 *
                 * If the CoolSetpointPresent bit is Off, the CoolSetpoint field shall be null in every entry of the
                 * Transitions list.
                 *
                 * At least one of the bits in the Mode For Sequence byte shall be on.
                 *
                 * Both bits must be respected, even if the HEAT or COOL feature is not supported, to ensure the command is
                 * decoded and handled correctly.
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.3
                 */
                modeForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                    /**
                     * Adjust Heat Setpoint
                     */
                    heatSetpointPresent: BitFlag;
                    /**
                     * Adjust Cool Setpoint
                     */
                    coolSetpointPresent: BitFlag;
                }>>;
                /**
                 * This field shall contain the list of setpoint transitions used to update the specified daily schedules
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.4.4
                 */
                transitions: import("../tlv/TlvObject.js").FieldType<import("../tlv/TlvObject.js").TypeFromFields<{
                    /**
                     * This field shall represent the start time of the schedule transition during the associated day. The time
                     * will be represented by a 16 bits unsigned integer to designate the minutes since midnight. For example, 6am
                     * will be represented by 360 minutes since midnight and 11:30pm will be represented by 1410 minutes since
                     * midnight.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.1
                     */
                    transitionTime: import("../tlv/TlvObject.js").FieldType<number>;
                    /**
                     * This field shall represent the heat setpoint to be applied at this associated transition start time.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.2
                     */
                    heatSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                    /**
                     * This field shall represent the cool setpoint to be applied at this associated transition start time.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.3
                     */
                    coolSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                }>[]>;
            }>, void, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    scheduleConfiguration: boolean;
                }];
            };
            readonly getWeeklySchedule: Command<import("../tlv/TlvObject.js").TypeFromFields<{
                /**
                 * This field shall indicate the number of days the client would like to return the setpoint values for and
                 * could be any combination of single days or the entire week.
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5.1
                 */
                daysToReturn: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                    /**
                     * Sunday
                     */
                    sunday: BitFlag;
                    /**
                     * Monday
                     */
                    monday: BitFlag;
                    /**
                     * Tuesday
                     */
                    tuesday: BitFlag;
                    /**
                     * Wednesday
                     */
                    wednesday: BitFlag;
                    /**
                     * Thursday
                     */
                    thursday: BitFlag;
                    /**
                     * Friday
                     */
                    friday: BitFlag;
                    /**
                     * Saturday
                     */
                    saturday: BitFlag;
                    /**
                     * Away or Vacation
                     */
                    away: BitFlag;
                }>>;
                /**
                 * This field shall indicate the mode the client would like to return the set point values for and could be any
                 * combination of heat only, cool only or heat & cool.
                 *
                 * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.5.2
                 */
                modeToReturn: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                    /**
                     * Adjust Heat Setpoint
                     */
                    heatSetpointPresent: BitFlag;
                    /**
                     * Adjust Cool Setpoint
                     */
                    coolSetpointPresent: BitFlag;
                }>>;
            }>, import("../tlv/TlvObject.js").TypeFromFields<{
                numberOfTransitionsForSequence: import("../tlv/TlvObject.js").FieldType<number>;
                dayOfWeekForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                    /**
                     * Sunday
                     */
                    sunday: BitFlag;
                    /**
                     * Monday
                     */
                    monday: BitFlag;
                    /**
                     * Tuesday
                     */
                    tuesday: BitFlag;
                    /**
                     * Wednesday
                     */
                    wednesday: BitFlag;
                    /**
                     * Thursday
                     */
                    thursday: BitFlag;
                    /**
                     * Friday
                     */
                    friday: BitFlag;
                    /**
                     * Saturday
                     */
                    saturday: BitFlag;
                    /**
                     * Away or Vacation
                     */
                    away: BitFlag;
                }>>;
                modeForSequence: import("../tlv/TlvObject.js").FieldType<import("../schema/BitmapSchema.js").TypeFromPartialBitSchema<{
                    /**
                     * Adjust Heat Setpoint
                     */
                    heatSetpointPresent: BitFlag;
                    /**
                     * Adjust Cool Setpoint
                     */
                    coolSetpointPresent: BitFlag;
                }>>;
                transitions: import("../tlv/TlvObject.js").FieldType<import("../tlv/TlvObject.js").TypeFromFields<{
                    /**
                     * This field shall represent the start time of the schedule transition during the associated day. The time
                     * will be represented by a 16 bits unsigned integer to designate the minutes since midnight. For example, 6am
                     * will be represented by 360 minutes since midnight and 11:30pm will be represented by 1410 minutes since
                     * midnight.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.1
                     */
                    transitionTime: import("../tlv/TlvObject.js").FieldType<number>;
                    /**
                     * This field shall represent the heat setpoint to be applied at this associated transition start time.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.2
                     */
                    heatSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                    /**
                     * This field shall represent the cool setpoint to be applied at this associated transition start time.
                     *
                     * @see {@link MatterSpecification.v13.Cluster} § 4.3.8.24.3
                     */
                    coolSetpoint: import("../tlv/TlvObject.js").FieldType<number | null>;
                }>[]>;
            }>, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    scheduleConfiguration: boolean;
                }];
            };
            readonly clearWeeklySchedule: Command<void, void, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../cluster/Cluster.js").ConditionalFeatureList<import("../schema/BitmapSchema.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    scheduleConfiguration: boolean;
                }];
            };
            /**
             * Upon receipt, the attributes for the indicated setpoint(s) shall have the amount specified in the Amount
             * field added to them. If the resulting value is outside the limits imposed by MinCoolSetpointLimit,
             * MaxCoolSetpointLimit, MinHeatSetpointLimit and MaxHeatSetpointLimit, the value is clamped to those
             * limits. This is not considered an error condition.
             *
             * @see {@link MatterSpecification.v13.Cluster} § 4.3.10.1
             */
            readonly setpointRaiseLower: Command<import("../tlv/TlvObject.js").TypeFromFields<{
                mode: import("../tlv/TlvObject.js").FieldType<SetpointRaiseLowerMode>;
                amount: import("../tlv/TlvObject.js").FieldType<number>;
            }>, void, any>;
        };
    }, []>;
    /**
     * This cluster supports all Thermostat features. It may support illegal feature combinations.
     *
     * If you use this cluster you must manually specify which features are active and ensure the set of active
     * features is legal per the Matter specification.
     */
    interface Complete extends Identity<typeof CompleteInstance> {
    }
    const Complete: Complete;
}
export type ThermostatCluster = Thermostat.Cluster;
export declare const ThermostatCluster: Thermostat.Cluster;
//# sourceMappingURL=thermostat.d.ts.map