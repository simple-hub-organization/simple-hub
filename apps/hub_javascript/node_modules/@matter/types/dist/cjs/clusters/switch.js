"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var switch_exports = {};
__export(switch_exports, {
  Switch: () => Switch,
  SwitchCluster: () => SwitchCluster
});
module.exports = __toCommonJS(switch_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var Switch;
((Switch2) => {
  let Feature;
  ((Feature2) => {
    Feature2["LatchingSwitch"] = "LatchingSwitch";
    Feature2["MomentarySwitch"] = "MomentarySwitch";
    Feature2["MomentarySwitchRelease"] = "MomentarySwitchRelease";
    Feature2["MomentarySwitchLongPress"] = "MomentarySwitchLongPress";
    Feature2["MomentarySwitchMultiPress"] = "MomentarySwitchMultiPress";
  })(Feature = Switch2.Feature || (Switch2.Feature = {}));
  Switch2.TlvMultiPressOngoingEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the new value of the CurrentPosition attribute, i.e. while pressed.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 1.13.6.6.1
     */
    newPosition: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8),
    /**
     * This field shall contain:
     *
     *   • a value of 2 when the second press of a multi-press sequence has been detected,
     *
     *   • a value of 3 when the third press of a multi-press sequence has been detected,
     *
     *   • a value of N when the Nth press of a multi-press sequence has been detected.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 1.13.6.6.2
     */
    currentNumberOfPressesCounted: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt8.bound({ min: 2 }))
  });
  Switch2.TlvMultiPressCompleteEvent = (0, import_TlvObject.TlvObject)({
    previousPosition: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8),
    totalNumberOfPressesCounted: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt8.bound({ min: 1 }))
  });
  Switch2.TlvSwitchLatchedEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the new value of the CurrentPosition attribute, i.e. after the move.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 1.13.6.1.1
     */
    newPosition: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8)
  });
  Switch2.TlvInitialPressEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the new value of the CurrentPosition attribute, i.e. while pressed.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 1.13.6.2.1
     */
    newPosition: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8)
  });
  Switch2.TlvLongPressEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the new value of the CurrentPosition attribute, i.e. while pressed.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 1.13.6.3.1
     */
    newPosition: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8)
  });
  Switch2.TlvLongReleaseEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the previous value of the CurrentPosition attribute, i.e. just prior to release.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 1.13.6.5.1
     */
    previousPosition: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8)
  });
  Switch2.TlvShortReleaseEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the previous value of the CurrentPosition attribute, i.e. just prior to release.
     *
     * @see {@link MatterSpecification.v13.Cluster} § 1.13.6.4.1
     */
    previousPosition: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8)
  });
  Switch2.MomentarySwitchMultiPressComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates how many consecutive presses can be detected and reported by a momentary switch which supports
       * multi-press (e.g. it will report the value 3 if it can detect single press, double press and triple
       * press, but not quad press and beyond).
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.5.3
       */
      multiPressMax: (0, import_Cluster.FixedAttribute)(2, import_TlvNumber.TlvUInt8.bound({ min: 2 }), { default: 2 })
    },
    events: {
      /**
       * This event shall be generated to indicate how many times the momentary switch has been pressed in a
       * multi-press sequence, during that sequence. See Multi Press Details below.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.6.6
       */
      multiPressOngoing: (0, import_Cluster.Event)(5, import_Cluster.EventPriority.Info, Switch2.TlvMultiPressOngoingEvent),
      /**
       * This event shall be generated to indicate how many times the momentary switch has been pressed in a
       * multi-press sequence, after it has been detected that the sequence has ended. See Multi Press Details.
       *
       * The PreviousPosition field shall indicate the previous value of the CurrentPosition attribute, i.e. just
       * prior to release.
       *
       * The TotalNumberOfPressesCounted field shall contain:
       *
       *   • a value of 1 when there was one press in a multi-press sequence (and the sequence has ended),
       *
       *     i.e. there was no double press (or more),
       *
       *   • a value of 2 when there were exactly two presses in a multi-press sequence (and the sequence has
       *     ended),
       *
       *   • a value of 3 when there were exactly three presses in a multi-press sequence (and the sequence has
       *     ended),
       *
       *   • a value of N when there were exactly N presses in a multi-press sequence (and the sequence has
       *     ended).
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.6.7
       */
      multiPressComplete: (0, import_Cluster.Event)(6, import_Cluster.EventPriority.Info, Switch2.TlvMultiPressCompleteEvent)
    }
  });
  Switch2.LatchingSwitchComponent = import_MutableCluster.MutableCluster.Component({
    events: {
      /**
       * This event shall be generated, when the latching switch is moved to a new position. It may have been
       * delayed by debouncing within the switch.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.6.1
       */
      switchLatched: (0, import_Cluster.Event)(0, import_Cluster.EventPriority.Info, Switch2.TlvSwitchLatchedEvent)
    }
  });
  Switch2.MomentarySwitchComponent = import_MutableCluster.MutableCluster.Component({
    events: {
      /**
       * This event shall be generated, when the momentary switch starts to be pressed (after debouncing).
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.6.2
       */
      initialPress: (0, import_Cluster.Event)(1, import_Cluster.EventPriority.Info, Switch2.TlvInitialPressEvent)
    }
  });
  Switch2.MomentarySwitchLongPressComponent = import_MutableCluster.MutableCluster.Component({
    events: {
      /**
       * This event shall be generated, when the momentary switch has been pressed for a "long" time (this time
       * interval is manufacturer determined (e.g. since it depends on the switch physics)).
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.6.3
       */
      longPress: (0, import_Cluster.Event)(2, import_Cluster.EventPriority.Info, Switch2.TlvLongPressEvent),
      /**
       * This event shall be generated, when the momentary switch has been released (after debouncing) and after
       * having been pressed for a long time, i.e. this event shall be generated when the switch is released if a
       * LongPress event has been generated since the previous InitialPress event. Also see Section 1.13.7,
       * “Sequence of generated events”.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.6.5
       */
      longRelease: (0, import_Cluster.Event)(4, import_Cluster.EventPriority.Info, Switch2.TlvLongReleaseEvent)
    }
  });
  Switch2.MomentarySwitchReleaseComponent = import_MutableCluster.MutableCluster.Component({
    events: {
      /**
       * This event shall be generated, when the momentary switch has been released (after debouncing).
       *
       *   • If the server supports the Momentary Switch LongPress (MSL) feature, this event shall be generated
       *     when the switch is released if no LongPress event had been generated since the previous InitialPress
       *     event.
       *
       *   • If the server does not support the Momentary Switch LongPress (MSL) feature, this event shall be
       *     generated when the switch is released - even when the switch was pressed for a long time.
       *
       *   • Also see Section 1.13.7, “Sequence of generated events”.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.6.4
       */
      shortRelease: (0, import_Cluster.Event)(3, import_Cluster.EventPriority.Info, Switch2.TlvShortReleaseEvent)
    }
  });
  Switch2.Base = import_MutableCluster.MutableCluster.Component({
    id: 59,
    name: "Switch",
    revision: 1,
    features: {
      /**
       * LatchingSwitch
       *
       * This feature is for a switch that maintains its position after being pressed (or turned).
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.4.1
       */
      latchingSwitch: (0, import_BitmapSchema.BitFlag)(0),
      /**
       * MomentarySwitch
       *
       * This feature is for a switch that does not maintain its position after being pressed (or turned). After
       * releasing, it goes back to its idle position.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.4.2
       */
      momentarySwitch: (0, import_BitmapSchema.BitFlag)(1),
      /**
       * MomentarySwitchRelease
       *
       * This feature is for a momentary switch that can distinguish and report release events. When this feature
       * flag MSR is present, MS shall be present as well.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.4.3
       */
      momentarySwitchRelease: (0, import_BitmapSchema.BitFlag)(2),
      /**
       * MomentarySwitchLongPress
       *
       * This feature is for a momentary switch that can distinguish and report long presses from short presses.
       * When this feature flag MSL is present, MS and MSR shall be present as well.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.4.4
       */
      momentarySwitchLongPress: (0, import_BitmapSchema.BitFlag)(3),
      /**
       * MomentarySwitchMultiPress
       *
       * This feature is for a momentary switch that can distinguish and report double press and potentially
       * multiple presses with more events, such as triple press, etc. When this feature flag MSM is present, MS
       * and MSR shall be present as well.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.4.5
       */
      momentarySwitchMultiPress: (0, import_BitmapSchema.BitFlag)(4)
    },
    attributes: {
      /**
       * Indicates the maximum number of positions the switch has. Any kind of switch has a minimum of 2
       * positions. Also see Multi Position Details for the case NumberOfPositions>2.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.5.1
       */
      numberOfPositions: (0, import_Cluster.FixedAttribute)(0, import_TlvNumber.TlvUInt8.bound({ min: 2 }), { default: 2 }),
      /**
       * Indicates the position of the switch. The valid range is zero to NumberOfPositions-1. CurrentPosition
       * value 0 shall be assigned to the default position of the switch: for example the "open" state of a
       * rocker switch, or the "idle" state of a push button switch.
       *
       * @see {@link MatterSpecification.v13.Cluster} § 1.13.5.2
       */
      currentPosition: (0, import_Cluster.Attribute)(1, import_TlvNumber.TlvUInt8, { persistent: true, default: 0 })
    },
    /**
     * This metadata controls which SwitchCluster elements matter.js activates for specific feature combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { momentarySwitchMultiPress: true }, component: Switch2.MomentarySwitchMultiPressComponent },
      { flags: { latchingSwitch: true }, component: Switch2.LatchingSwitchComponent },
      { flags: { momentarySwitch: true }, component: Switch2.MomentarySwitchComponent },
      { flags: { momentarySwitchLongPress: true }, component: Switch2.MomentarySwitchLongPressComponent },
      { flags: { momentarySwitchRelease: true }, component: Switch2.MomentarySwitchReleaseComponent },
      { flags: { momentarySwitchRelease: true, momentarySwitch: false }, component: false },
      { flags: { momentarySwitchLongPress: true, momentarySwitch: false }, component: false },
      { flags: { momentarySwitchLongPress: true, momentarySwitchRelease: false }, component: false },
      { flags: { momentarySwitchMultiPress: true, momentarySwitch: false }, component: false },
      { flags: { momentarySwitchMultiPress: true, momentarySwitchRelease: false }, component: false },
      { flags: { latchingSwitch: true, momentarySwitch: true }, component: false },
      { flags: { latchingSwitch: false, momentarySwitch: false }, component: false }
    )
  });
  Switch2.ClusterInstance = import_MutableCluster.MutableCluster.ExtensibleOnly(Switch2.Base);
  Switch2.Cluster = Switch2.ClusterInstance;
  const MSM = { momentarySwitchMultiPress: true };
  const LS = { latchingSwitch: true };
  const MS = { momentarySwitch: true };
  const MSL = { momentarySwitchLongPress: true };
  const MSR = { momentarySwitchRelease: true };
  Switch2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: Switch2.Base.id,
    name: Switch2.Base.name,
    revision: Switch2.Base.revision,
    features: Switch2.Base.features,
    attributes: {
      ...Switch2.Base.attributes,
      multiPressMax: import_MutableCluster.MutableCluster.AsConditional(
        Switch2.MomentarySwitchMultiPressComponent.attributes.multiPressMax,
        { mandatoryIf: [MSM] }
      )
    },
    events: {
      switchLatched: import_MutableCluster.MutableCluster.AsConditional(
        Switch2.LatchingSwitchComponent.events.switchLatched,
        { mandatoryIf: [LS] }
      ),
      initialPress: import_MutableCluster.MutableCluster.AsConditional(
        Switch2.MomentarySwitchComponent.events.initialPress,
        { mandatoryIf: [MS] }
      ),
      longPress: import_MutableCluster.MutableCluster.AsConditional(
        Switch2.MomentarySwitchLongPressComponent.events.longPress,
        { mandatoryIf: [MSL] }
      ),
      shortRelease: import_MutableCluster.MutableCluster.AsConditional(
        Switch2.MomentarySwitchReleaseComponent.events.shortRelease,
        { mandatoryIf: [MSR] }
      ),
      longRelease: import_MutableCluster.MutableCluster.AsConditional(
        Switch2.MomentarySwitchLongPressComponent.events.longRelease,
        { mandatoryIf: [MSL] }
      ),
      multiPressOngoing: import_MutableCluster.MutableCluster.AsConditional(
        Switch2.MomentarySwitchMultiPressComponent.events.multiPressOngoing,
        { mandatoryIf: [MSM] }
      ),
      multiPressComplete: import_MutableCluster.MutableCluster.AsConditional(
        Switch2.MomentarySwitchMultiPressComponent.events.multiPressComplete,
        { mandatoryIf: [MSM] }
      )
    }
  });
  Switch2.Complete = Switch2.CompleteInstance;
})(Switch || (Switch = {}));
const SwitchCluster = Switch.Cluster;
import_ClusterRegistry.ClusterRegistry.register(Switch.Complete);
//# sourceMappingURL=switch.js.map
