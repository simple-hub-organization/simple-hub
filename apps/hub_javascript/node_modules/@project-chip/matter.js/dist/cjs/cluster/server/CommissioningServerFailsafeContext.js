"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var CommissioningServerFailsafeContext_exports = {};
__export(CommissioningServerFailsafeContext_exports, {
  CommissioningServerFailsafeContext: () => CommissioningServerFailsafeContext
});
module.exports = __toCommonJS(CommissioningServerFailsafeContext_exports);
var import_clusters = require("#clusters");
var import_general = require("#general");
var import_protocol = require("#protocol");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class CommissioningServerFailsafeContext extends import_protocol.FailsafeContext {
  #rootEndpoint;
  #storedNetworkClusterState = /* @__PURE__ */ new Map();
  constructor(rootEndpoint, options) {
    super(options);
    this.#rootEndpoint = rootEndpoint;
  }
  static async create(rootEndpoint, options) {
    return (0, import_general.asyncNew)(this, rootEndpoint, options);
  }
  async storeEndpointState() {
    await this.#storeEndpointState(this.#rootEndpoint);
  }
  async restoreFabric(fabric) {
    await super.restoreFabric(fabric);
    const operationalCredentialsCluster = this.#rootEndpoint.getClusterServer(import_clusters.OperationalCredentials.Cluster);
    operationalCredentialsCluster?.attributes.nocs.updatedLocalForFabric(fabric);
    operationalCredentialsCluster?.attributes.fabrics.updatedLocalForFabric(fabric);
  }
  async restoreNetworkState() {
    await this.#restoreEndpointState(this.#rootEndpoint);
  }
  async revokeFabric(fabric) {
    const basicInformationCluster = this.#rootEndpoint.getClusterServer(import_clusters.BasicInformation.Cluster);
    basicInformationCluster?.triggerLeaveEvent?.({ fabricIndex: fabric.fabricIndex });
    await fabric.remove();
    const operationalCredentialsCluster = this.#rootEndpoint.getClusterServer(import_clusters.OperationalCredentials.Cluster);
    operationalCredentialsCluster?.attributes.nocs.updatedLocalForFabric(fabric);
    operationalCredentialsCluster?.attributes.commissionedFabrics.updatedLocal();
    operationalCredentialsCluster?.attributes.fabrics.updatedLocalForFabric(fabric);
    operationalCredentialsCluster?.attributes.trustedRootCertificates.updatedLocal();
  }
  async restoreBreadcrumb() {
    const generalCommissioningCluster = this.#rootEndpoint.getClusterServer(import_clusters.GeneralCommissioning.Cluster);
    generalCommissioningCluster?.setBreadcrumbAttribute(0);
  }
  async #storeEndpointState(endpoint) {
    const networkCluster = endpoint.getClusterServer(import_clusters.NetworkCommissioning.Complete);
    if (networkCluster !== void 0) {
      this.#storedNetworkClusterState.set(endpoint.getNumber(), networkCluster.getNetworksAttribute());
    }
    for (const childEndpoint of endpoint.getChildEndpoints()) {
      await this.#storeEndpointState(childEndpoint);
    }
  }
  async #restoreEndpointState(endpoint) {
    const endpointId = endpoint.getNumber();
    const networkState = this.#storedNetworkClusterState.get(endpointId);
    if (networkState !== void 0) {
      const networkCluster = endpoint.getClusterServer(import_clusters.NetworkCommissioning.Complete);
      if (networkCluster !== void 0) {
        networkCluster.setNetworksAttribute(networkState);
      }
      this.#storedNetworkClusterState.delete(endpointId);
    }
    for (const childEndpoint of endpoint.getChildEndpoints()) {
      await this.#restoreEndpointState(childEndpoint);
    }
  }
}
//# sourceMappingURL=CommissioningServerFailsafeContext.js.map
