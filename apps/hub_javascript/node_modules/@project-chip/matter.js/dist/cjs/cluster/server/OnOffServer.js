"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var OnOffServer_exports = {};
__export(OnOffServer_exports, {
  OnOffClusterDefaultHandler: () => OnOffClusterDefaultHandler,
  createDefaultOnOffClusterServer: () => createDefaultOnOffClusterServer
});
module.exports = __toCommonJS(OnOffServer_exports);
var import_clusters = require("#clusters");
var import_general = require("#general");
var import_Device = require("../../device/Device.js");
var import_ClusterServer = require("./ClusterServer.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const Cluster = import_clusters.OnOff.Cluster.with("Lighting");
const OnOffClusterDefaultHandler = () => {
  let timedOnTimer;
  let delayedOffTimer;
  const getTimedOnTimer = (onTime, onOff) => {
    if (timedOnTimer === void 0) {
      timedOnTimer = import_general.Time.getPeriodicTimer("Delayed on", 100, () => {
        let time = onTime.getLocal() ?? 0 - 0.1;
        if (time <= 0) {
          time = 0;
          timedOnTimer?.stop();
          onOff.setLocal(false);
        }
        onTime.setLocal(time);
      });
    }
    return timedOnTimer;
  };
  const getDelayedOffTimer = (offWaitTime) => {
    if (delayedOffTimer === void 0) {
      delayedOffTimer = import_general.Time.getTimer("Delayed off", 100, () => {
        let time = offWaitTime.getLocal() ?? 0 - 0.1;
        if (time <= 0) {
          time = 0;
          delayedOffTimer?.stop();
        }
        offWaitTime.setLocal(time);
      });
    }
    return delayedOffTimer;
  };
  return {
    initializeClusterServer: ({ attributes: { onOff, startUpOnOff } }) => {
      const startUpOnOffValue = startUpOnOff?.getLocal() ?? null;
      if (startUpOnOffValue !== null) {
        const currentOnOffStatus = onOff.getLocal();
        const targetOnOffValue = startUpOnOffValue === import_clusters.OnOff.StartUpOnOff.Toggle ? !currentOnOffStatus : startUpOnOffValue === import_clusters.OnOff.StartUpOnOff.On;
        if (targetOnOffValue !== currentOnOffStatus) {
          onOff.setLocal(targetOnOffValue);
        }
      }
    },
    destroyClusterServer: () => {
      timedOnTimer?.stop();
      delayedOffTimer?.stop();
    },
    on: async ({ attributes: { onOff } }) => {
      onOff.setLocal(true);
    },
    off: async ({ attributes: { onOff } }) => {
      onOff.setLocal(false);
    },
    toggle: async ({ attributes: { onOff } }) => {
      if (onOff.getLocal()) {
        onOff.setLocal(false);
      } else {
        onOff.setLocal(true);
      }
    },
    offWithEffect: async () => {
      throw new import_general.NotImplementedError("Not implemented");
    },
    onWithRecallGlobalScene: async () => {
      throw new import_general.NotImplementedError("Not implemented");
    },
    onWithTimedOff: async ({
      request: { onOffControl, onTime: reqOnTime, offWaitTime: reqOffWaitTime },
      attributes: { onOff, onTime, offWaitTime }
    }) => {
      if (onTime === void 0 || offWaitTime === void 0) return;
      const timedOnTimer2 = getTimedOnTimer(onTime, onOff);
      const delayedOffTimer2 = getDelayedOffTimer(offWaitTime);
      const onOffState = onOff.getLocal();
      if (!onOffState && onOffControl.acceptOnlyWhenOn) {
        return;
      }
      if (delayedOffTimer2.isRunning && !onOffState) {
        offWaitTime.setLocal(Math.min(reqOffWaitTime ?? 0, offWaitTime.getLocal() ?? 0));
        delayedOffTimer2.start();
        timedOnTimer2.stop();
      } else {
        onTime.setLocal(Math.max(reqOnTime ?? 0, onTime.getLocal() ?? 0));
        offWaitTime.setLocal(reqOffWaitTime);
        timedOnTimer2.start();
        delayedOffTimer2.stop();
      }
    }
  };
};
const createDefaultOnOffClusterServer = (commandHandler, attributeInitialValues, isLighting = false) => {
  if (isLighting) {
    return (0, import_ClusterServer.ClusterServer)(
      import_clusters.OnOff.Cluster.with(import_clusters.OnOff.Feature.Lighting),
      {
        onOff: false,
        globalSceneControl: false,
        onTime: 0,
        offWaitTime: 0,
        startUpOnOff: null,
        ...attributeInitialValues
      },
      (0, import_Device.WrapCommandHandler)(OnOffClusterDefaultHandler(), commandHandler)
    );
  }
  return (0, import_ClusterServer.ClusterServer)(
    import_clusters.OnOff.Cluster,
    {
      onOff: false,
      ...attributeInitialValues
    },
    (0, import_Device.WrapCommandHandler)(
      OnOffClusterDefaultHandler(),
      commandHandler
    )
  );
};
//# sourceMappingURL=OnOffServer.js.map
