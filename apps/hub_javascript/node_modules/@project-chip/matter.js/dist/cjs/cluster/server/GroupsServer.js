"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var GroupsServer_exports = {};
__export(GroupsServer_exports, {
  GroupsClusterHandler: () => GroupsClusterHandler,
  GroupsManager: () => GroupsManager,
  createDefaultGroupsClusterServer: () => createDefaultGroupsClusterServer
});
module.exports = __toCommonJS(GroupsServer_exports);
var import_clusters = require("#clusters");
var import_protocol = require("#protocol");
var import_types = require("#types");
var import_ClusterServer = require("./ClusterServer.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class GroupsManager {
  static async setGroup(fabric, endpointId, groupId, groupName) {
    let endpointGroups = fabric.getScopedClusterDataValue(
      import_clusters.GroupsCluster,
      endpointId.toString()
    );
    if (endpointGroups === void 0) {
      endpointGroups = /* @__PURE__ */ new Map();
    }
    endpointGroups.set(groupId, groupName || "");
    await fabric.setScopedClusterDataValue(import_clusters.GroupsCluster, endpointId.toString(), endpointGroups);
  }
  static getGroupName(fabric, endpointId, groupId) {
    const endpointGroups = fabric.getScopedClusterDataValue(
      import_clusters.GroupsCluster,
      endpointId.toString()
    );
    return endpointGroups?.get(groupId);
  }
  static hasGroup(fabric, endpointId, groupId) {
    const endpointGroups = fabric.getScopedClusterDataValue(
      import_clusters.GroupsCluster,
      endpointId.toString()
    );
    return endpointGroups?.has(groupId) ?? false;
  }
  static getGroups(fabric, endpointId) {
    return fabric.getScopedClusterDataValue(import_clusters.GroupsCluster, endpointId.toString()) ?? /* @__PURE__ */ new Map();
  }
  static async removeGroup(fabric, endpointId, groupId) {
    const endpointGroups = fabric.getScopedClusterDataValue(
      import_clusters.GroupsCluster,
      endpointId.toString()
    );
    if (endpointGroups !== void 0) {
      if (endpointGroups.delete(groupId)) {
        await fabric.persist(false);
        return true;
      }
    }
    return false;
  }
  static async removeAllGroups(fabric, endpointId) {
    await fabric.deleteScopedClusterDataValue(import_clusters.GroupsCluster, endpointId.toString());
  }
}
const GroupsClusterHandler = () => {
  const addGroupLogic = async (groupId, groupName, fabric, endpointId) => {
    if (groupId < 1) {
      return { status: import_types.StatusCode.ConstraintError, groupId };
    }
    if (groupName.length > 16) {
      return { status: import_types.StatusCode.ConstraintError, groupId };
    }
    await GroupsManager.setGroup(fabric, endpointId, groupId, groupName);
    return { status: import_types.StatusCode.Success, groupId };
  };
  return {
    addGroup: async ({ request: { groupId, groupName }, session, endpoint }) => {
      (0, import_protocol.assertSecureSession)(session);
      return addGroupLogic(groupId, groupName, session.associatedFabric, endpoint.getNumber());
    },
    viewGroup: async ({ request: { groupId }, session, endpoint }) => {
      if (groupId < 1) {
        return { status: import_types.StatusCode.ConstraintError, groupId, groupName: "" };
      }
      (0, import_protocol.assertSecureSession)(session);
      const groupName = GroupsManager.getGroupName(session.associatedFabric, endpoint.getNumber(), groupId);
      if (groupName !== void 0) {
        return { status: import_types.StatusCode.Success, groupId, groupName };
      }
      return { status: import_types.StatusCode.NotFound, groupId, groupName: "" };
    },
    getGroupMembership: async ({ request: { groupList }, session, endpoint }) => {
      (0, import_protocol.assertSecureSession)(session);
      const endpointGroups = GroupsManager.getGroups(session.associatedFabric, endpoint.getNumber());
      const fabricGroupsList = Array.from(endpointGroups.keys());
      const capacity = fabricGroupsList.length < 255 ? 254 - fabricGroupsList.length : 0;
      if (groupList.length === 0) {
        return { capacity, groupList: fabricGroupsList };
      }
      const filteredGroupsList = groupList.filter((groupId) => endpointGroups.get(groupId));
      if (filteredGroupsList.length === 0) {
        return { capacity, groupList: [] };
      }
      return { capacity, groupList: filteredGroupsList };
    },
    removeGroup: async ({ request: { groupId }, session, endpoint }) => {
      if (groupId < 1) {
        return { status: import_types.StatusCode.ConstraintError, groupId };
      }
      (0, import_protocol.assertSecureSession)(session);
      if (await GroupsManager.removeGroup(session.associatedFabric, endpoint.getNumber(), groupId)) {
        return { status: import_types.StatusCode.Success, groupId };
      }
      return { status: import_types.StatusCode.NotFound, groupId };
    },
    removeAllGroups: async ({ session, endpoint }) => {
      (0, import_protocol.assertSecureSession)(session);
      const fabric = session.associatedFabric;
      await GroupsManager.removeAllGroups(fabric, endpoint.getNumber());
      return;
    },
    addGroupIfIdentifying: async ({ request: { groupId, groupName }, session, endpoint }) => {
      const identifyCluster = endpoint.getClusterServer(import_clusters.IdentifyCluster);
      if (identifyCluster) {
        if (identifyCluster.attributes.identifyTime.getLocal() > 0) {
          (0, import_protocol.assertSecureSession)(session);
          await addGroupLogic(groupId, groupName, session.associatedFabric, endpoint.getNumber());
        }
      }
    }
  };
};
const createDefaultGroupsClusterServer = () => (0, import_ClusterServer.ClusterServer)(
  import_clusters.GroupsCluster,
  {
    nameSupport: {
      nameSupport: true
    }
  },
  GroupsClusterHandler()
);
//# sourceMappingURL=GroupsServer.js.map
