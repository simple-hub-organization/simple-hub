"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var GeneralCommissioningServer_exports = {};
__export(GeneralCommissioningServer_exports, {
  GeneralCommissioningClusterHandler: () => GeneralCommissioningClusterHandler
});
module.exports = __toCommonJS(GeneralCommissioningServer_exports);
var import_clusters = require("#clusters");
var import_general = require("#general");
var import_MatterDevice = require("#MatterDevice.js");
var import_protocol = require("#protocol");
var import_CommissioningServerFailsafeContext = require("./CommissioningServerFailsafeContext.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const SuccessResponse = { errorCode: import_clusters.GeneralCommissioning.CommissioningError.Ok, debugText: "" };
const logger = import_general.Logger.get("GeneralCommissioningClusterHandler");
const GeneralCommissioningClusterHandler = (options) => ({
  initializeClusterServer: ({ attributes: { breadcrumb } }) => {
    breadcrumb.setLocal(BigInt(0));
  },
  armFailSafe: async ({
    request: { breadcrumb: breadcrumbStep, expiryLengthSeconds },
    attributes: { breadcrumb, basicCommissioningInfo },
    session,
    endpoint
  }) => {
    (0, import_protocol.assertSecureSession)(session, "armFailSafe can only be called on a secure session");
    const device = import_MatterDevice.MatterDevice.of(session);
    try {
      if (!device.isFailsafeArmed() && endpoint.getClusterServer(import_clusters.AdministratorCommissioning.Cluster)?.getWindowStatusAttribute() !== import_clusters.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen && !session.isPase) {
        throw new import_general.MatterFlowError("Failed to arm failsafe using CASE while commissioning window is opened.");
      }
      if (device.isFailsafeArmed()) {
        await device.failsafeContext.extend(session.fabric, expiryLengthSeconds);
      } else {
        if (expiryLengthSeconds === 0) return SuccessResponse;
        await device.beginTimed(
          new import_CommissioningServerFailsafeContext.CommissioningServerFailsafeContext(endpoint, {
            fabrics: device.fabricManager,
            sessions: device.sessionManager,
            expiryLengthSeconds,
            maxCumulativeFailsafeSeconds: basicCommissioningInfo.getLocal().maxCumulativeFailsafeSeconds,
            associatedFabric: session.fabric
          })
        );
      }
      if (device.isFailsafeArmed()) {
        breadcrumb.setLocal(breadcrumbStep);
      }
    } catch (error) {
      import_general.MatterFlowError.accept(error);
      logger.debug(`Error while arming failSafe timer`, error);
      return {
        errorCode: import_clusters.GeneralCommissioning.CommissioningError.BusyWithOtherAdmin,
        debugText: error.message
      };
    }
    return SuccessResponse;
  },
  setRegulatoryConfig: async ({
    request: { breadcrumb: breadcrumbStep, newRegulatoryConfig, countryCode },
    attributes: { breadcrumb, regulatoryConfig, locationCapability },
    endpoint
  }) => {
    const locationCapabilityValue = locationCapability.getLocal();
    const basicInformationCluster = endpoint.getClusterServer(import_clusters.BasicInformationCluster);
    if (basicInformationCluster === void 0) {
      throw new import_general.ImplementationError("BasicInformationCluster needs to be present on the root endpoint");
    }
    const currentLocationCountryCode = basicInformationCluster.getLocationAttribute();
    if (currentLocationCountryCode !== countryCode) {
      if (options?.allowCountryCodeChange === false && countryCode !== "XX") {
        return {
          errorCode: import_clusters.GeneralCommissioning.CommissioningError.ValueOutsideRange,
          debugText: `Country code change not allowed: ${countryCode}`
        };
      }
      if (options?.countryCodeWhitelist !== void 0 && !options?.countryCodeWhitelist.includes(countryCode)) {
        return {
          errorCode: import_clusters.GeneralCommissioning.CommissioningError.ValueOutsideRange,
          debugText: `Country code change not allowed: ${countryCode}`
        };
      }
      if (countryCode !== "XX") {
        basicInformationCluster.setLocationAttribute(countryCode);
      }
    }
    let validValues;
    switch (locationCapabilityValue) {
      case import_clusters.GeneralCommissioning.RegulatoryLocationType.Outdoor:
        validValues = [import_clusters.GeneralCommissioning.RegulatoryLocationType.Outdoor];
        break;
      case import_clusters.GeneralCommissioning.RegulatoryLocationType.Indoor:
        validValues = [import_clusters.GeneralCommissioning.RegulatoryLocationType.Indoor];
        break;
      case import_clusters.GeneralCommissioning.RegulatoryLocationType.IndoorOutdoor:
        validValues = [
          import_clusters.GeneralCommissioning.RegulatoryLocationType.Indoor,
          import_clusters.GeneralCommissioning.RegulatoryLocationType.Outdoor,
          import_clusters.GeneralCommissioning.RegulatoryLocationType.IndoorOutdoor
        ];
        break;
      default:
        return {
          errorCode: import_clusters.GeneralCommissioning.CommissioningError.ValueOutsideRange,
          debugText: `Invalid regulatory location: ${newRegulatoryConfig === import_clusters.GeneralCommissioning.RegulatoryLocationType.Indoor ? "Indoor" : "Outdoor"}`
        };
    }
    if (!validValues.includes(newRegulatoryConfig)) {
      return {
        errorCode: import_clusters.GeneralCommissioning.CommissioningError.ValueOutsideRange,
        debugText: `Invalid regulatory location: ${newRegulatoryConfig === import_clusters.GeneralCommissioning.RegulatoryLocationType.Indoor ? "Indoor" : "Outdoor"}`
      };
    }
    regulatoryConfig.setLocal(newRegulatoryConfig);
    breadcrumb.setLocal(breadcrumbStep);
    return SuccessResponse;
  },
  commissioningComplete: async ({ session, attributes: { breadcrumb } }) => {
    const fabric = session.associatedFabric;
    if (session.isPase) {
      return {
        errorCode: import_clusters.GeneralCommissioning.CommissioningError.InvalidAuthentication,
        debugText: "Command not executed over CASE session."
      };
    }
    const device = import_MatterDevice.MatterDevice.of(session);
    if (!device.isFailsafeArmed()) {
      return { errorCode: import_clusters.GeneralCommissioning.CommissioningError.NoFailSafe, debugText: "FailSafe not armed." };
    }
    (0, import_protocol.assertSecureSession)(session, "commissioningComplete can only be called on a secure session");
    const failsafeFabric = device.failsafeContext.associatedFabric?.fabricIndex;
    if (fabric.fabricIndex !== failsafeFabric) {
      return {
        errorCode: import_clusters.GeneralCommissioning.CommissioningError.InvalidAuthentication,
        debugText: `Associated fabric ${fabric.fabricIndex} does not match the one from the failsafe context ${failsafeFabric}.`
      };
    }
    await device.failsafeContext.completeCommission();
    breadcrumb.setLocal(BigInt(0));
    logger.info(`Commissioning completed on fabric #${fabric.fabricId} as node #${fabric.nodeId}.`);
    return SuccessResponse;
  }
});
//# sourceMappingURL=GeneralCommissioningServer.js.map
