"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var AccessControlServer_exports = {};
__export(AccessControlServer_exports, {
  AccessControlClusterHandler: () => AccessControlClusterHandler,
  createDefaultAccessControlClusterServer: () => createDefaultAccessControlClusterServer
});
module.exports = __toCommonJS(AccessControlServer_exports);
var import_clusters = require("#clusters");
var import_general = require("#general");
var import_MatterDevice = require("#MatterDevice.js");
var import_protocol = require("#protocol");
var import_types = require("#types");
var import_ClusterServer = require("./ClusterServer.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("AccessControlClusterServer");
const AccessControlClusterHandler = () => {
  let accessControlEntryChangedEvent = void 0;
  let accessControlExtensionChangedEvent = void 0;
  return {
    initializeClusterServer: ({ events: { accessControlEntryChanged, accessControlExtensionChanged } }) => {
      if (accessControlEntryChanged !== void 0) {
        accessControlEntryChangedEvent = accessControlEntryChanged;
      }
      if (accessControlExtensionChanged !== void 0) {
        accessControlExtensionChangedEvent = accessControlExtensionChanged;
      }
    },
    aclAttributeGetter: ({ session, isFabricFiltered }) => {
      return (0, import_protocol.genericFabricScopedAttributeGetter)(
        session,
        !!isFabricFiltered,
        import_clusters.AccessControlCluster,
        "acl",
        new Array(),
        import_MatterDevice.MatterDevice.of(session).getFabrics()
      );
    },
    aclAttributeValidator: (value, {
      attributes: {
        accessControlEntriesPerFabric,
        subjectsPerAccessControlEntry,
        targetsPerAccessControlEntry
      }
    }) => {
      if (value.length > accessControlEntriesPerFabric.getLocal()) {
        throw new import_types.StatusResponseError("AccessControlEntriesPerFabric exceeded", import_types.StatusCode.ResourceExhausted);
      }
      for (const entry of value) {
        const { subjects, targets, privilege, authMode } = entry;
        if (privilege < 1 || privilege > 5) {
          throw new import_types.StatusResponseError(
            "Privilege must be a valid enum value between 1 and 5",
            import_types.StatusCode.ConstraintError
          );
        }
        if (authMode < 1 || authMode > 3) {
          throw new import_types.StatusResponseError(
            "AuthMode must be a valid enum value between 1 and 3",
            import_types.StatusCode.ConstraintError
          );
        }
        if (subjects !== null && subjects.length > subjectsPerAccessControlEntry.getLocal()) {
          throw new import_types.StatusResponseError(
            "SubjectsPerAccessControlEntry exceeded",
            import_types.StatusCode.ResourceExhausted
          );
        }
        if (targets !== null && targets.length > targetsPerAccessControlEntry.getLocal()) {
          throw new import_types.StatusResponseError(
            "TargetsPerAccessControlEntry exceeded",
            import_types.StatusCode.ResourceExhausted
          );
        }
        if (authMode === import_clusters.AccessControl.AccessControlEntryAuthMode.Pase) {
          throw new import_types.StatusResponseError("AuthMode for ACL must not be PASE", import_types.StatusCode.ConstraintError);
        } else if (authMode === import_clusters.AccessControl.AccessControlEntryAuthMode.Case) {
          if (subjects !== null) {
            for (const subject of subjects) {
              if (import_types.NodeId.isCaseAuthenticatedTag(subject)) {
                const cat = import_types.NodeId.extractAsCaseAuthenticatedTag(subject);
                if (import_types.CaseAuthenticatedTag.getVersion(cat) === 0) {
                  throw new import_types.StatusResponseError(
                    "CaseAuthenticatedTag version 0 is not allowed",
                    import_types.StatusCode.ConstraintError
                  );
                }
              } else if (!import_types.NodeId.isOperationalNodeId(subject)) {
                throw new import_types.StatusResponseError(
                  "Subject must be a valid OperationalNodeId or CaseAuthenticatedTag",
                  import_types.StatusCode.ConstraintError
                );
              }
            }
          }
        } else if (authMode === import_clusters.AccessControl.AccessControlEntryAuthMode.Group) {
          if (privilege === import_clusters.AccessControl.AccessControlEntryPrivilege.Administer) {
            throw new import_types.StatusResponseError(
              "Group ACLs must not have Administer privilege",
              import_types.StatusCode.ConstraintError
            );
          }
          if (subjects !== null) {
            for (const subject of subjects) {
              if ((0, import_types.GroupId)(subject) === import_types.GroupId.UNSPECIFIED_GROUP_ID) {
                throw new import_types.StatusResponseError(
                  "Subject must be a valid GroupId for Group ACLs",
                  import_types.StatusCode.ConstraintError
                );
              }
            }
          }
        }
        if (targets !== null) {
          for (const target of targets) {
            const { deviceType, endpoint, cluster } = target;
            if (deviceType !== null && endpoint !== null) {
              throw new import_types.StatusResponseError(
                "DeviceType and Endpoint are mutually exclusive",
                import_types.StatusCode.ConstraintError
              );
            }
            if (cluster === null && endpoint === null && deviceType === null) {
              throw new import_types.StatusResponseError(
                "At least one field must be present",
                import_types.StatusCode.ConstraintError
              );
            }
            if (cluster !== null && !import_types.ClusterId.isValid(cluster)) {
              throw new import_types.StatusResponseError(
                "Cluster must be a valid ClusterId",
                import_types.StatusCode.ConstraintError
              );
            }
            if (endpoint !== null && !import_types.EndpointNumber.isValid(endpoint)) {
              throw new import_types.StatusResponseError(
                "Endpoint must be a valid OperationalNodeId",
                import_types.StatusCode.ConstraintError
              );
            }
            if (deviceType !== null && !import_types.DeviceTypeId.isValid(deviceType)) {
              throw new import_types.StatusResponseError(
                "DeviceType must be a valid DeviceType",
                import_types.StatusCode.ConstraintError
              );
            }
          }
        }
      }
    },
    aclAttributeSetter: (value, { session }) => {
      (0, import_protocol.assertSecureSession)(session);
      const fabric = import_MatterDevice.MatterDevice.of(session).getFabricByIndex(
        value[0]?.fabricIndex ?? session.associatedFabric.fabricIndex
      );
      if (fabric === void 0) {
        throw new import_general.InternalError("Fabric not found. SHould never happen");
      }
      const oldValue = (0, import_protocol.genericFabricScopedAttributeGetterFromFabric)(
        fabric,
        import_clusters.AccessControlCluster,
        "acl",
        new Array()
      ) ?? [];
      const changed = (0, import_protocol.genericFabricScopedAttributeSetterForFabric)(fabric, import_clusters.AccessControlCluster, "acl", value, []);
      if (changed && accessControlEntryChangedEvent !== void 0) {
        const adminPasscodeId = session.isPase ? 0 : null;
        const adminNodeId = adminPasscodeId === null ? session.associatedFabric.rootNodeId : null;
        let i = 0;
        for (; i < value.length; i++) {
          if (!(0, import_general.isDeepEqual)(value[i], oldValue[i])) {
            const changeType = oldValue[i] === void 0 ? import_clusters.AccessControl.ChangeType.Added : value[i] === void 0 ? import_clusters.AccessControl.ChangeType.Removed : import_clusters.AccessControl.ChangeType.Changed;
            accessControlEntryChangedEvent.triggerEvent({
              changeType,
              adminNodeId,
              adminPasscodeId,
              latestValue: (changeType === import_clusters.AccessControl.ChangeType.Removed ? oldValue[i] : value[i]) ?? null,
              fabricIndex: session.associatedFabric.fabricIndex
            });
          }
        }
        if (oldValue.length > i) {
          for (let j = oldValue.length - 1; j >= i; j--) {
            accessControlEntryChangedEvent.triggerEvent({
              changeType: import_clusters.AccessControl.ChangeType.Removed,
              adminNodeId,
              adminPasscodeId,
              latestValue: oldValue[j],
              fabricIndex: session.associatedFabric.fabricIndex
            });
          }
        }
      }
      return changed;
    },
    extensionAttributeGetter: ({ session }) => {
      return (0, import_protocol.genericFabricScopedAttributeGetter)(
        session,
        true,
        import_clusters.AccessControlCluster,
        "extension",
        new Array(),
        import_MatterDevice.MatterDevice.of(session).getFabrics()
      );
    },
    extensionAttributeValidator: (value) => {
      if (value.length === 0) {
        return;
      }
      if (value.length > 1) {
        throw new import_types.StatusResponseError("Extension list must contain a single entry", import_types.StatusCode.ConstraintError);
      }
      const { data } = value[0];
      if (data.length < 2 || data[0] !== import_types.TlvType.List || data[data.length - 1] !== import_types.TlvType.EndOfContainer) {
        throw new import_types.StatusResponseError("Extension must be a valid TLV", import_types.StatusCode.ConstraintError);
      }
      try {
        const decoded = (0, import_types.TlvTaggedList)({}, true).decode(data);
        logger.info(`Extension TLV decoded:`, decoded);
      } catch (error) {
        logger.debug(`Extension TLV decoding failed:`, error);
        throw new import_types.StatusResponseError("Extension must be a valid TLV", import_types.StatusCode.ConstraintError);
      }
    },
    extensionAttributeSetter: (value, { session }) => {
      (0, import_protocol.assertSecureSession)(session);
      const fabric = import_MatterDevice.MatterDevice.of(session).getFabricByIndex(
        value[0]?.fabricIndex ?? session.associatedFabric.fabricIndex
      );
      if (fabric === void 0) {
        throw new import_general.InternalError("Fabric not found. Should never happen");
      }
      const oldValue = (0, import_protocol.genericFabricScopedAttributeGetterFromFabric)(
        fabric,
        import_clusters.AccessControlCluster,
        "extension",
        new Array()
      ) ?? [];
      const changed = (0, import_protocol.genericFabricScopedAttributeSetterForFabric)(
        fabric,
        import_clusters.AccessControlCluster,
        "extension",
        value,
        []
      );
      if (changed && accessControlExtensionChangedEvent !== void 0) {
        const changeType = value.length > oldValue.length ? import_clusters.AccessControl.ChangeType.Added : value.length < oldValue.length ? import_clusters.AccessControl.ChangeType.Removed : import_clusters.AccessControl.ChangeType.Changed;
        const adminPasscodeId = session.isPase ? 0 : null;
        const adminNodeId = adminPasscodeId === null ? session.associatedFabric.rootNodeId : null;
        accessControlExtensionChangedEvent.triggerEvent({
          changeType,
          adminNodeId,
          adminPasscodeId,
          latestValue: (changeType === import_clusters.AccessControl.ChangeType.Removed ? oldValue[0] : value[0]) ?? null,
          fabricIndex: session.associatedFabric.fabricIndex
        });
      }
      return changed;
    }
  };
};
const createDefaultAccessControlClusterServer = () => (0, import_ClusterServer.ClusterServer)(
  import_clusters.AccessControlCluster,
  {
    acl: [],
    extension: [],
    subjectsPerAccessControlEntry: 4,
    targetsPerAccessControlEntry: 4,
    accessControlEntriesPerFabric: 4
  },
  AccessControlClusterHandler(),
  {
    accessControlEntryChanged: true,
    accessControlExtensionChanged: true
  }
);
//# sourceMappingURL=AccessControlServer.js.map
