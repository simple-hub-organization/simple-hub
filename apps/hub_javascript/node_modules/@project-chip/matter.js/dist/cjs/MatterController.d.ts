/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { NodeCommissioningOptions } from "#CommissioningController.js";
import { CachedClientNodeStore } from "#device/CachedClientNodeStore.js";
import { DeviceInformationData } from "#device/DeviceInformation.js";
import { Construction, NetInterfaceSet, ServerAddressIp } from "#general";
import { CertificateAuthority, DecodedAttributeReportValue, DiscoveryData, DiscoveryOptions, Fabric, InstanceBroadcaster, OperationalPeer, PeerAddress, PeerAddressStore, PeerSet, ResumptionRecord, ScannerSet, SessionManager } from "#protocol";
import { CaseAuthenticatedTag, ClusterId, DiscoveryCapabilitiesBitmap, EndpointNumber, FabricId, FabricIndex, NodeId, TypeFromPartialBitSchema, VendorId } from "#types";
import { ControllerStoreInterface } from "@matter/node";
export type CommissionedNodeDetails = {
    operationalServerAddress?: ServerAddressIp;
    discoveryData?: DiscoveryData;
    deviceData?: DeviceInformationData;
};
type CommissionedPeer = OperationalPeer & {
    deviceData?: DeviceInformationData;
};
export declare class MatterController {
    #private;
    static create(options: {
        controllerStore: ControllerStoreInterface;
        scanners: ScannerSet;
        netInterfaces: NetInterfaceSet;
        sessionClosedCallback?: (peerNodeId: NodeId) => void;
        adminVendorId?: VendorId;
        adminFabricId?: FabricId;
        adminFabricIndex?: FabricIndex;
        caseAuthenticatedTags?: CaseAuthenticatedTag[];
    }): Promise<MatterController>;
    static createAsPaseCommissioner(options: {
        certificateAuthorityConfig: CertificateAuthority.Configuration;
        fabricConfig: Fabric.Config;
        scanners: ScannerSet;
        netInterfaces: NetInterfaceSet;
        sessionClosedCallback?: (peerNodeId: NodeId) => void;
    }): Promise<MatterController>;
    readonly sessionManager: SessionManager;
    private readonly netInterfaces;
    private readonly channelManager;
    private readonly exchangeManager;
    private readonly peers;
    private readonly commissioner;
    readonly nodesStore: CommissionedNodeStore;
    private readonly scanners;
    private readonly ca;
    private readonly fabric;
    private readonly sessionClosedCallback?;
    get construction(): Construction<MatterController>;
    constructor(options: {
        controllerStore: ControllerStoreInterface;
        scanners: ScannerSet;
        netInterfaces: NetInterfaceSet;
        certificateManager: CertificateAuthority;
        fabric: Fabric;
        sessionClosedCallback?: (peerNodeId: NodeId) => void;
    });
    get nodeId(): NodeId;
    get caConfig(): CertificateAuthority.Configuration;
    get fabricConfig(): Fabric.Config;
    getFabrics(): Fabric[];
    hasBroadcaster(broadcaster: InstanceBroadcaster): boolean;
    addBroadcaster(broadcaster: InstanceBroadcaster): void;
    deleteBroadcaster(broadcaster: InstanceBroadcaster): Promise<void>;
    collectScanners(discoveryCapabilities?: TypeFromPartialBitSchema<typeof DiscoveryCapabilitiesBitmap>): import("#protocol").Scanner[];
    /**
     * Commission a device by its identifier and the Passcode. If a known address is provided this is tried first
     * before discovering devices in the network. If multiple addresses or devices are found, they are tried all after
     * each other. It returns the NodeId of the commissioned device.
     * If it throws an PairRetransmissionLimitReachedError that means that no found device responded to the pairing
     * request or the passode did not match to any discovered device/address.
     *
     * Use the connectNodeAfterCommissioning callback to implement an own logic to do the operative device discovery and
     * to complete the commissioning process.
     * Return true when the commissioning process is completed successfully, false on error.
     */
    commission(options: NodeCommissioningOptions, completeCommissioningCallback?: (peerNodeId: NodeId, discoveryData?: DiscoveryData) => Promise<boolean>): Promise<NodeId>;
    disconnect(nodeId: NodeId): Promise<void>;
    removeNode(nodeId: NodeId): Promise<void>;
    /**
     * Method to complete the commissioning process to a node which was initialized with a PASE secure channel.
     */
    completeCommissioning(peerNodeId: NodeId, discoveryData?: DiscoveryData): Promise<void>;
    isCommissioned(): boolean;
    getCommissionedNodes(): NodeId[];
    getCommissionedNodesDetails(): {
        nodeId: NodeId;
        operationalAddress: string | undefined;
        advertisedName: string | undefined;
        discoveryData: DiscoveryData | undefined;
        deviceData: DeviceInformationData | undefined;
    }[];
    getCommissionedNodeDetails(nodeId: NodeId): {
        nodeId: NodeId;
        operationalAddress: string | undefined;
        advertisedName: string | undefined;
        discoveryData: DiscoveryData | undefined;
        deviceData: DeviceInformationData | undefined;
    };
    enhanceCommissionedNodeDetails(nodeId: NodeId, deviceData: DeviceInformationData): Promise<void>;
    /**
     * Connect to the device by opening a channel and creating a new CASE session if necessary.
     * Returns a InteractionClient on success.
     */
    connect(peerNodeId: NodeId, discoveryOptions: DiscoveryOptions, allowUnknownPeer?: boolean): Promise<import("#protocol").InteractionClient>;
    createInteractionClient(peerNodeId: NodeId, discoveryOptions: DiscoveryOptions): Promise<import("#protocol").InteractionClient>;
    getNextAvailableSessionId(): Promise<number>;
    getResumptionRecord(resumptionId: Uint8Array): ResumptionRecord | undefined;
    findResumptionRecordByNodeId(nodeId: NodeId): ResumptionRecord | undefined;
    saveResumptionRecord(resumptionRecord: ResumptionRecord): Promise<void>;
    announce(): Promise<void>;
    close(): Promise<void>;
    getActiveSessionInformation(): {
        name: string;
        nodeId: NodeId;
        peerNodeId: NodeId;
        fabric: import("#protocol").ExposedFabricInformation | undefined;
        isPeerActive: boolean;
        secure: boolean;
        lastInteractionTimestamp: number | undefined;
        lastActiveTimestamp: number | undefined;
        numberOfActiveSubscriptions: number;
    }[];
    getStoredClusterDataVersions(nodeId: NodeId, filterEndpointId?: EndpointNumber, filterClusterId?: ClusterId): Promise<{
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        dataVersion: number;
    }[]>;
    retrieveStoredAttributes(nodeId: NodeId, endpointId: EndpointNumber, clusterId: ClusterId): Promise<DecodedAttributeReportValue<any>[]>;
}
declare class CommissionedNodeStore extends PeerAddressStore {
    #private;
    private fabric;
    peers: PeerSet;
    constructor(controllerStore: ControllerStoreInterface, fabric: Fabric);
    createNodeStore(address: PeerAddress, load?: boolean): Promise<CachedClientNodeStore>;
    loadPeers(): Promise<CommissionedPeer[]>;
    updatePeer(): Promise<void>;
    deletePeer(address: PeerAddress): Promise<void>;
    save(): Promise<void>;
}
export {};
//# sourceMappingURL=MatterController.d.ts.map