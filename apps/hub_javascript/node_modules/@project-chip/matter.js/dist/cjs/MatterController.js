"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var MatterController_exports = {};
__export(MatterController_exports, {
  MatterController: () => MatterController
});
module.exports = __toCommonJS(MatterController_exports);
var import_clusters = require("#clusters");
var import_CachedClientNodeStore = require("#device/CachedClientNodeStore.js");
var import_general = require("#general");
var import_LegacyControllerStore = require("#LegacyControllerStore.js");
var import_protocol = require("#protocol");
var import_types = require("#types");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const DEFAULT_FABRIC_INDEX = (0, import_types.FabricIndex)(1);
const CONTROLLER_CONNECTIONS_PER_FABRIC_AND_NODE = 3;
const CONTROLLER_MAX_PATHS_PER_INVOKE = 10;
const logger = import_general.Logger.get("MatterController");
class MatterController {
  static async create(options) {
    const {
      controllerStore,
      scanners,
      netInterfaces,
      sessionClosedCallback,
      adminVendorId,
      adminFabricId = (0, import_types.FabricId)(import_protocol.DEFAULT_FABRIC_ID),
      adminFabricIndex = (0, import_types.FabricIndex)(DEFAULT_FABRIC_INDEX),
      caseAuthenticatedTags
    } = options;
    const ca = await import_protocol.CertificateAuthority.create(controllerStore.caStorage);
    const fabricStorage = controllerStore.fabricStorage;
    let controller = void 0;
    if (await fabricStorage.has("fabric")) {
      const fabric = new import_protocol.Fabric(await fabricStorage.get("fabric"));
      if (import_general.Bytes.areEqual(fabric.rootCert, ca.rootCert)) {
        logger.info("Loaded existing fabric from storage");
        controller = new MatterController({
          controllerStore,
          scanners,
          netInterfaces,
          certificateManager: ca,
          fabric,
          sessionClosedCallback
        });
      } else {
        logger.info("Fabric CA certificate changed ...");
        if (await controllerStore.nodesStorage.has("commissionedNodes")) {
          throw new Error(
            "Fabric certificate changed, but commissioned nodes are still present. Please clear the storage."
          );
        }
      }
    }
    if (controller === void 0) {
      logger.info("Creating new fabric");
      const rootNodeId = import_types.NodeId.randomOperationalNodeId();
      const ipkValue = import_general.Crypto.getRandomData(import_general.CRYPTO_SYMMETRIC_KEY_LENGTH);
      const fabricBuilder = new import_protocol.FabricBuilder().setRootCert(ca.rootCert).setRootNodeId(rootNodeId).setIdentityProtectionKey(ipkValue).setRootVendorId(adminVendorId ?? import_protocol.DEFAULT_ADMIN_VENDOR_ID);
      fabricBuilder.setOperationalCert(
        ca.generateNoc(fabricBuilder.publicKey, adminFabricId, rootNodeId, caseAuthenticatedTags)
      );
      const fabric = await fabricBuilder.build(adminFabricIndex);
      controller = new MatterController({
        controllerStore,
        scanners,
        netInterfaces,
        certificateManager: ca,
        fabric,
        sessionClosedCallback
      });
    }
    await controller.construction;
    return controller;
  }
  static async createAsPaseCommissioner(options) {
    const { certificateAuthorityConfig, fabricConfig, scanners, netInterfaces, sessionClosedCallback } = options;
    if (!netInterfaces.hasInterfaceFor(import_general.ChannelType.BLE)) {
      if (!scanners.hasScannerFor(import_general.ChannelType.UDP) || !netInterfaces.hasInterfaceFor(import_general.ChannelType.UDP, "::")) {
        throw new import_general.ImplementationError(
          "Ble must be initialized to create a Sub Commissioner without an IP network!"
        );
      }
      logger.info("BLE is not enabled. Using only IP network for commissioning.");
    }
    const certificateManager = await import_protocol.CertificateAuthority.create(certificateAuthorityConfig);
    const storageManager = new import_general.StorageManager(new import_general.StorageBackendMemory());
    await storageManager.initialize();
    const fabric = new import_protocol.Fabric(fabricConfig);
    const controller = new MatterController({
      controllerStore: new import_LegacyControllerStore.LegacyControllerStore(storageManager.createContext("Commissioner")),
      scanners,
      netInterfaces,
      certificateManager,
      fabric,
      sessionClosedCallback
    });
    await controller.construction;
    return controller;
  }
  sessionManager;
  netInterfaces = new import_general.NetInterfaceSet();
  channelManager = new import_protocol.ChannelManager(CONTROLLER_CONNECTIONS_PER_FABRIC_AND_NODE);
  exchangeManager;
  peers;
  commissioner;
  #construction;
  #store;
  nodesStore;
  scanners;
  ca;
  fabric;
  sessionClosedCallback;
  #advertiser;
  get construction() {
    return this.#construction;
  }
  constructor(options) {
    const { controllerStore, scanners, netInterfaces, certificateManager, fabric, sessionClosedCallback } = options;
    this.#store = controllerStore;
    this.scanners = scanners;
    this.netInterfaces = netInterfaces;
    this.ca = certificateManager;
    this.fabric = fabric;
    this.sessionClosedCallback = sessionClosedCallback;
    const fabricManager = new import_protocol.FabricManager();
    fabricManager.addFabric(fabric);
    this.sessionManager = new import_protocol.SessionManager({
      fabrics: fabricManager,
      storage: controllerStore.sessionStorage,
      parameters: {
        maxPathsPerInvoke: CONTROLLER_MAX_PATHS_PER_INVOKE
      }
    });
    this.sessionManager.sessions.deleted.on(async (session) => {
      this.sessionClosedCallback?.(session.peerNodeId);
    });
    this.exchangeManager = new import_protocol.ExchangeManager({
      sessionManager: this.sessionManager,
      channelManager: this.channelManager,
      transportInterfaces: this.netInterfaces
    });
    this.exchangeManager.addProtocolHandler(new import_protocol.SecureChannelProtocol(this.sessionManager, fabricManager));
    this.exchangeManager.addProtocolHandler(new import_protocol.SubscriptionClient());
    this.nodesStore = new CommissionedNodeStore(controllerStore, fabric);
    this.nodesStore.peers = this.peers = new import_protocol.PeerSet({
      sessions: this.sessionManager,
      channels: this.channelManager,
      exchanges: this.exchangeManager,
      scanners: this.scanners,
      netInterfaces: this.netInterfaces,
      store: this.nodesStore
    });
    this.commissioner = new import_protocol.ControllerCommissioner({
      peers: this.peers,
      scanners: this.scanners,
      netInterfaces: this.netInterfaces,
      exchanges: this.exchangeManager,
      sessions: this.sessionManager,
      ca: this.ca
    });
    this.#advertiser = new import_protocol.DeviceAdvertiser({
      fabrics: fabricManager,
      sessions: this.sessionManager
    });
    this.#construction = (0, import_general.Construction)(this, async () => {
      await this.peers.construction.ready;
      await this.sessionManager.construction.ready;
    });
  }
  get nodeId() {
    return this.fabric.rootNodeId;
  }
  get caConfig() {
    return this.ca.config;
  }
  get fabricConfig() {
    return this.fabric.config;
  }
  getFabrics() {
    return [this.fabric];
  }
  hasBroadcaster(broadcaster) {
    return this.#advertiser.hasBroadcaster(broadcaster);
  }
  addBroadcaster(broadcaster) {
    this.#advertiser.addBroadcaster(broadcaster);
  }
  async deleteBroadcaster(broadcaster) {
    await this.#advertiser.deleteBroadcaster(broadcaster);
  }
  collectScanners(discoveryCapabilities = { onIpNetwork: true }) {
    return this.scanners.filter(
      (scanner) => scanner.type === import_general.ChannelType.UDP || discoveryCapabilities.ble && scanner.type === import_general.ChannelType.BLE
    );
  }
  /**
   * Commission a device by its identifier and the Passcode. If a known address is provided this is tried first
   * before discovering devices in the network. If multiple addresses or devices are found, they are tried all after
   * each other. It returns the NodeId of the commissioned device.
   * If it throws an PairRetransmissionLimitReachedError that means that no found device responded to the pairing
   * request or the passode did not match to any discovered device/address.
   *
   * Use the connectNodeAfterCommissioning callback to implement an own logic to do the operative device discovery and
   * to complete the commissioning process.
   * Return true when the commissioning process is completed successfully, false on error.
   */
  async commission(options, completeCommissioningCallback) {
    const commissioningOptions = {
      ...options.commissioning,
      fabric: this.fabric,
      discovery: options.discovery,
      passcode: options.passcode
    };
    if (completeCommissioningCallback) {
      commissioningOptions.finalizeCommissioning = async (peerAddress, discoveryData) => {
        const result = await completeCommissioningCallback(peerAddress.nodeId, discoveryData);
        if (!result) {
          throw new import_protocol.RetransmissionLimitReachedError("Device could not be discovered");
        }
      };
    }
    const address = await this.commissioner.commissionWithDiscovery(commissioningOptions);
    await this.#store.fabricStorage.set("fabric", this.fabric.config);
    return address.nodeId;
  }
  async disconnect(nodeId) {
    return this.peers.disconnect(this.fabric.addressOf(nodeId));
  }
  async removeNode(nodeId) {
    return this.peers.delete(this.fabric.addressOf(nodeId));
  }
  /**
   * Method to complete the commissioning process to a node which was initialized with a PASE secure channel.
   */
  async completeCommissioning(peerNodeId, discoveryData) {
    const interactionClient = await this.connect(
      peerNodeId,
      {
        discoveryType: import_protocol.NodeDiscoveryType.TimedDiscovery,
        timeoutSeconds: 120,
        discoveryData
      },
      true
    );
    const generalCommissioningClusterClient = (0, import_protocol.ClusterClient)(
      import_clusters.GeneralCommissioning.Cluster,
      (0, import_types.EndpointNumber)(0),
      interactionClient
    );
    const { errorCode, debugText } = await generalCommissioningClusterClient.commissioningComplete(void 0, {
      useExtendedFailSafeMessageResponseTimeout: true
    });
    if (errorCode !== import_clusters.GeneralCommissioning.CommissioningError.Ok) {
      await this.peers.delete(this.fabric.addressOf(peerNodeId));
      throw new import_protocol.CommissioningError(`Commission error on commissioningComplete: ${errorCode}, ${debugText}`);
    }
    await this.#store.fabricStorage.set("fabric", this.fabric.config);
  }
  isCommissioned() {
    return this.peers.size > 0;
  }
  getCommissionedNodes() {
    return this.peers.map((peer) => peer.address.nodeId);
  }
  getCommissionedNodesDetails() {
    return this.peers.map((peer) => {
      const { address, operationalAddress, discoveryData, deviceData } = peer;
      return {
        nodeId: address.nodeId,
        operationalAddress: operationalAddress ? (0, import_general.serverAddressToString)(operationalAddress) : void 0,
        advertisedName: discoveryData?.DN,
        discoveryData,
        deviceData
      };
    });
  }
  getCommissionedNodeDetails(nodeId) {
    const nodeDetails = this.peers.get(this.fabric.addressOf(nodeId));
    if (nodeDetails === void 0) {
      throw new Error(`Node ${nodeId} is not commissioned.`);
    }
    const { address, operationalAddress, discoveryData, deviceData } = nodeDetails;
    return {
      nodeId: address.nodeId,
      operationalAddress: operationalAddress ? (0, import_general.serverAddressToString)(operationalAddress) : void 0,
      advertisedName: discoveryData?.DN,
      discoveryData,
      deviceData
    };
  }
  async enhanceCommissionedNodeDetails(nodeId, deviceData) {
    const nodeDetails = this.peers.get(this.fabric.addressOf(nodeId));
    if (nodeDetails === void 0) {
      throw new Error(`Node ${nodeId} is not commissioned.`);
    }
    nodeDetails.deviceData = deviceData;
    await this.nodesStore.save();
  }
  /**
   * Connect to the device by opening a channel and creating a new CASE session if necessary.
   * Returns a InteractionClient on success.
   */
  async connect(peerNodeId, discoveryOptions, allowUnknownPeer) {
    return this.peers.connect(this.fabric.addressOf(peerNodeId), discoveryOptions, allowUnknownPeer);
  }
  createInteractionClient(peerNodeId, discoveryOptions) {
    return this.peers.initializeInteractionClient(this.fabric.addressOf(peerNodeId), discoveryOptions);
  }
  async getNextAvailableSessionId() {
    return this.sessionManager.getNextAvailableSessionId();
  }
  getResumptionRecord(resumptionId) {
    return this.sessionManager.findResumptionRecordById(resumptionId);
  }
  findResumptionRecordByNodeId(nodeId) {
    return this.sessionManager.findResumptionRecordByAddress(this.fabric.addressOf(nodeId));
  }
  async saveResumptionRecord(resumptionRecord) {
    return this.sessionManager.saveResumptionRecord(resumptionRecord);
  }
  announce() {
    return this.#advertiser.advertise();
  }
  async close() {
    await this.peers.close();
    await this.exchangeManager.close();
    await this.sessionManager.close();
    await this.channelManager.close();
    await this.netInterfaces.close();
    await this.#advertiser.close();
  }
  getActiveSessionInformation() {
    return this.sessionManager.getActiveSessionInformation();
  }
  async getStoredClusterDataVersions(nodeId, filterEndpointId, filterClusterId) {
    const peer = this.peers.get(this.fabric.addressOf(nodeId));
    if (peer === void 0) {
      throw new import_protocol.UnknownNodeError(`Node ${nodeId} is not commissioned.`);
    }
    if (peer.dataStore === void 0) {
      return [];
    }
    await peer.dataStore.construction;
    return peer.dataStore.getClusterDataVersions(filterEndpointId, filterClusterId);
  }
  async retrieveStoredAttributes(nodeId, endpointId, clusterId) {
    const peer = this.peers.get(this.fabric.addressOf(nodeId));
    if (peer === void 0) {
      throw new import_protocol.UnknownNodeError(`Node ${nodeId} is not commissioned.`);
    }
    if (peer.dataStore === void 0) {
      return [];
    }
    await peer.dataStore.construction;
    return peer.dataStore.retrieveAttributes(endpointId, clusterId);
  }
}
class CommissionedNodeStore extends import_protocol.PeerAddressStore {
  constructor(controllerStore, fabric) {
    super();
    this.fabric = fabric;
    this.#controllerStore = controllerStore;
  }
  #controllerStore;
  async createNodeStore(address, load = true) {
    return new import_CachedClientNodeStore.CachedClientNodeStore(await this.#controllerStore.clientNodeStore(address.nodeId.toString()), load);
  }
  async loadPeers() {
    if (!await this.#controllerStore.nodesStorage.has("commissionedNodes")) {
      return [];
    }
    const commissionedNodes = await this.#controllerStore.nodesStorage.get("commissionedNodes");
    const nodes = new Array();
    for (const [nodeId, { operationalServerAddress, discoveryData, deviceData }] of commissionedNodes) {
      const address = this.fabric.addressOf(nodeId);
      nodes.push({
        address,
        operationalAddress: operationalServerAddress,
        discoveryData,
        deviceData,
        dataStore: await this.createNodeStore(address)
      });
    }
    return nodes;
  }
  async updatePeer() {
    return this.save();
  }
  async deletePeer(address) {
    await (await this.#controllerStore.clientNodeStore(address.nodeId.toString())).clearAll();
    return this.save();
  }
  async save() {
    await this.#controllerStore.nodesStorage.set(
      "commissionedNodes",
      this.peers.map((peer) => {
        const {
          address,
          operationalAddress: operationalServerAddress,
          discoveryData,
          deviceData
        } = peer;
        return [
          address.nodeId,
          { operationalServerAddress, discoveryData, deviceData }
        ];
      })
    );
  }
}
//# sourceMappingURL=MatterController.js.map
