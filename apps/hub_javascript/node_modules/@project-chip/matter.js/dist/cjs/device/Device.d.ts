/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AtLeastOne, HandlerFunction, NamedHandler } from "#general";
import { ClusterClientObj } from "#protocol";
import { Cluster, ClusterType, EndpointNumber } from "#types";
import { ClusterServerHandlers, ClusterServerObj } from "../cluster/server/ClusterServerTypes.js";
import { DeviceTypeDefinition } from "./DeviceTypes.js";
import { Endpoint, EndpointOptions } from "./Endpoint.js";
/**
 * Utility function to wrap externally registered command handlers into the internal command handler and make sure
 * the custom ones are used if defined
 *
 * @param commandHandler Command handler instance with the registered handlers
 * @param handler Internal handlers instance to wrap the external handler into
 */
export declare const WrapCommandHandler: <C extends Cluster<any, any, any, any, any>>(handler: ClusterServerHandlers<C>, commandHandler?: NamedHandler<any>) => ClusterServerHandlers<C>;
/**
 * Temporary used device class for paired devices until we added a layer to choose the right specialized device class
 * based on the device classes and features of the paired device
 */
export declare class PairedDevice extends Endpoint {
    private readonly declineAddingMoreClusters;
    /**
     * Create a new PairedDevice instance. All data are automatically parsed from the paired device!
     *
     * @param definition DeviceTypeDefinitions of the paired device as reported by the device
     * @param clusters Clusters of the paired device as reported by the device
     * @param endpointId Endpoint ID of the paired device as reported by the device
     */
    constructor(definition: AtLeastOne<DeviceTypeDefinition>, clusters: (ClusterServerObj | ClusterClientObj)[] | undefined, endpointId: EndpointNumber);
    /**
     * Add cluster servers (used internally only!)
     * @deprecated PairedDevice does not support adding additional clusters
     */
    addClusterServer<const T extends ClusterType>(cluster: ClusterServerObj<T>): void;
    /**
     * Add cluster clients (used internally only!)
     * @deprecated PairedDevice does not support adding additional clusters
     */
    addClusterClient<const T extends ClusterType>(cluster: ClusterClientObj<T>): void;
}
/**
 * Root endpoint of a device. This is used internally and not needed to be instanced by the user.
 */
export declare class RootEndpoint extends Endpoint {
    /**
     * Create a new RootEndpoint instance. This is automatically instanced by the CommissioningServer class.
     */
    constructor();
    /**
     * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param cluster ClusterServer to get or undefined if not existing
     */
    getRootClusterServer<const T extends ClusterType>(cluster: T): ClusterServerObj<T> | undefined;
    /**
     * Add a cluster client to the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param cluster ClusterClient object to add
     */
    addRootClusterClient(cluster: ClusterClientObj): void;
    /**
     * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param cluster ClusterClient to get or undefined if not existing
     */
    getRootClusterClient<const T extends ClusterType>(cluster: T): ClusterClientObj<T> | undefined;
}
/**
 * Base class for all devices. This class should be extended by all devices.
 */
export declare class Device extends Endpoint {
    protected commandHandler: NamedHandler<any>;
    /**
     * Create a new Device instance.
     *
     * @param definition DeviceTypeDefinitions of the device
     * @param options Optional endpoint options
     */
    constructor(definition: DeviceTypeDefinition, options?: EndpointOptions);
    /**
     * Method to add command handlers to the device.
     * The base class do not expose any commands!
     *
     * @param command Command name to add a handler for
     * @param handler Handler function to be executed when the command is received
     */
    addCommandHandler(command: never, handler: HandlerFunction): void;
    /**
     * Method to remove command handlers from the device.
     * The base class do not expose any commands!
     *
     * @param command Command name to remove the handler from
     * @param handler Handler function to be removed
     */
    removeCommandHandler(command: never, handler: HandlerFunction): void;
    /**
     * Execute a command handler. Should only be used internally, but cannot be declared as protected officially
     * because needed public for derived classes.
     *
     * @protected
     * @param command Command name to execute the handler for
     * @param args Arguments to be passed to the handler
     */
    protected _executeHandler(command: never, ...args: any[]): Promise<any>;
    protected createOptionalClusterServer<const T extends ClusterType>(_cluster: T): ClusterServerObj<T>;
    protected createOptionalClusterClient<const T extends ClusterType>(_cluster: T): ClusterClientObj<T>;
    getClusterServer<const T extends ClusterType>(cluster: T): ClusterServerObj<T> | undefined;
    getClusterClient<const T extends ClusterType>(cluster: T): ClusterClientObj<T> | undefined;
    /**
     * Set the reachability of the device exposed via the bridge. If this is a device inside  a composed device the
     * reachability needs to be set there.
     *
     * @param reachable true if reachable, false otherwise
     */
    setBridgedDeviceReachability(reachable: boolean): void;
}
//# sourceMappingURL=Device.d.ts.map