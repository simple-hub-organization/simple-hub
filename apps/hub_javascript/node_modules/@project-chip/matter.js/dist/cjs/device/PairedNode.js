"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var PairedNode_exports = {};
__export(PairedNode_exports, {
  NodeNotConnectedError: () => NodeNotConnectedError,
  NodeStateInformation: () => NodeStateInformation,
  NodeStates: () => NodeStates,
  PairedNode: () => PairedNode
});
module.exports = __toCommonJS(PairedNode_exports);
var import_clusters = require("#clusters");
var import_general = require("#general");
var import_protocol = require("#protocol");
var import_types = require("#types");
var import_model = require("@matter/model");
var import_ClusterServer = require("../cluster/server/ClusterServer.js");
var import_ClusterServerTypes = require("../cluster/server/ClusterServerTypes.js");
var import_Aggregator = require("./Aggregator.js");
var import_ComposedDevice = require("./ComposedDevice.js");
var import_Device = require("./Device.js");
var import_DeviceInformation = require("./DeviceInformation.js");
var import_DeviceTypes = require("./DeviceTypes.js");
var import_TypeHelpers = require("./TypeHelpers.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("PairedNode");
const STRUCTURE_UPDATE_TIMEOUT_MS = 5e3;
const RECONNECT_DELAY_MS = 15e3;
const RECONNECT_DELAY_AFTER_SHUTDOWN_MS = 3e4;
const RECONNECT_MAX_DELAY_MS = 6e5;
var NodeStates = /* @__PURE__ */ ((NodeStates2) => {
  NodeStates2[NodeStates2["Connected"] = 0] = "Connected";
  NodeStates2[NodeStates2["Disconnected"] = 1] = "Disconnected";
  NodeStates2[NodeStates2["Reconnecting"] = 2] = "Reconnecting";
  NodeStates2[NodeStates2["WaitingForDeviceDiscovery"] = 3] = "WaitingForDeviceDiscovery";
  return NodeStates2;
})(NodeStates || {});
var NodeStateInformation = /* @__PURE__ */ ((NodeStateInformation2) => {
  NodeStateInformation2[NodeStateInformation2["Connected"] = 0] = "Connected";
  NodeStateInformation2[NodeStateInformation2["Disconnected"] = 1] = "Disconnected";
  NodeStateInformation2[NodeStateInformation2["Reconnecting"] = 2] = "Reconnecting";
  NodeStateInformation2[NodeStateInformation2["WaitingForDeviceDiscovery"] = 3] = "WaitingForDeviceDiscovery";
  NodeStateInformation2[NodeStateInformation2["StructureChanged"] = 4] = "StructureChanged";
  NodeStateInformation2[NodeStateInformation2["Decommissioned"] = 5] = "Decommissioned";
  return NodeStateInformation2;
})(NodeStateInformation || {});
class NodeNotConnectedError extends import_general.MatterError {
}
class PairedNode {
  constructor(nodeId, commissioningController, options = {}, knownNodeDetails, interactionClient, reconnectFunc, assignDisconnectedHandler, storedAttributeData) {
    this.nodeId = nodeId;
    this.commissioningController = commissioningController;
    this.options = options;
    this.reconnectFunc = reconnectFunc;
    assignDisconnectedHandler(async () => {
      logger.info(
        `Node ${this.nodeId}: Session disconnected${this.#connectionState !== 1 /* Disconnected */ ? ", trying to reconnect ..." : ""}`
      );
      if (this.#connectionState === 0 /* Connected */) {
        this.#scheduleReconnect();
      }
    });
    this.#interactionClient = interactionClient;
    this.#interactionClient.channelUpdated.on(() => {
      if (this.#reconnectDelayTimer?.isRunning && !this.#clientReconnectInProgress && !this.#reconnectionInProgress && this.#connectionState === 2 /* Reconnecting */) {
        logger.info(`Node ${this.nodeId}: Got a reconnect, so reconnection not needed anymore ...`);
        this.#reconnectDelayTimer?.stop();
        this.#reconnectDelayTimer = void 0;
        this.#setConnectionState(0 /* Connected */);
      }
    });
    this.#nodeDetails = new import_DeviceInformation.DeviceInformation(nodeId, knownNodeDetails);
    logger.info(`Node ${this.nodeId}: Created paired node with device data`, this.#nodeDetails.meta);
    this.#construction = (0, import_general.Construction)(this, async () => {
      if (storedAttributeData !== void 0) {
        await this.#initializeFromStoredData(storedAttributeData);
      }
      this.#initialize().catch((error) => {
        logger.info(`Node ${nodeId}: Error during remote initialization`, error);
        if (this.state !== 1 /* Disconnected */) {
          this.#setConnectionState(3 /* WaitingForDeviceDiscovery */);
          this.#scheduleReconnect();
        }
      });
    });
  }
  #endpoints = /* @__PURE__ */ new Map();
  #interactionClient;
  #reconnectDelayTimer;
  #reconnectErrorCount = 0;
  #updateEndpointStructureTimer = import_general.Time.getTimer(
    "Endpoint structure update",
    STRUCTURE_UPDATE_TIMEOUT_MS,
    async () => await this.#updateEndpointStructure()
  );
  #connectionState = 1 /* Disconnected */;
  #reconnectionInProgress = false;
  #localInitializationDone = false;
  #remoteInitializationInProgress = false;
  #remoteInitializationDone = false;
  #nodeDetails;
  #construction;
  #clientReconnectInProgress = false;
  #currentSubscriptionHandler;
  events = {
    /**
     * Emitted when the node is initialized from local data. These data usually are stale, but you can still already
     * use the node to interact with the device. If no local data are available this event will be emitted together
     * with the initializedFromRemote event.
     */
    initialized: (0, import_general.AsyncObservable)(),
    /**
     * Emitted when the node is fully initialized from remote and all attributes and events are subscribed.
     * This event can also be awaited if code needs to be blocked until the node is fully initialized.
     */
    initializedFromRemote: (0, import_general.AsyncObservable)(),
    /** Emitted when the state of the node changes. */
    stateChanged: (0, import_general.Observable)(),
    /**
     * Emitted when an attribute value changes. If the oldValue is undefined then no former value was known.
     */
    attributeChanged: (0, import_general.Observable)(),
    /** Emitted when an event is triggered. */
    eventTriggered: (0, import_general.Observable)(),
    /** Emitted when the structure of the node changes (Endpoints got added or also removed). */
    structureChanged: (0, import_general.Observable)(),
    /** Emitted when the node is decommissioned. */
    decommissioned: (0, import_general.Observable)()
  };
  static async create(nodeId, commissioningController, options = {}, knownNodeDetails, interactionClient, reconnectFunc, assignDisconnectedHandler, storedAttributeData) {
    const node = new PairedNode(
      nodeId,
      commissioningController,
      options,
      knownNodeDetails,
      interactionClient,
      reconnectFunc,
      assignDisconnectedHandler,
      storedAttributeData
    );
    await node.construction;
    return node;
  }
  get construction() {
    return this.#construction;
  }
  get isConnected() {
    return this.#connectionState === 0 /* Connected */;
  }
  get state() {
    return this.#connectionState;
  }
  get basicInformation() {
    return this.#nodeDetails.basicInformation;
  }
  get deviceInformation() {
    return this.#nodeDetails.meta;
  }
  get localInitializationDone() {
    return this.#localInitializationDone;
  }
  get remoteInitializationDone() {
    return this.#remoteInitializationDone;
  }
  get initialized() {
    return this.#remoteInitializationDone || this.#localInitializationDone;
  }
  #setConnectionState(state) {
    if (this.#connectionState === state || this.#connectionState === 3 /* WaitingForDeviceDiscovery */ && state === 2 /* Reconnecting */)
      return;
    this.#connectionState = state;
    this.options.stateInformationCallback?.(this.nodeId, state);
    this.events.stateChanged.emit(state);
    if (state === 1 /* Disconnected */) {
      this.#reconnectDelayTimer?.stop();
      this.#reconnectDelayTimer = void 0;
    }
  }
  /** Make sure to not request a new Interaction client multiple times in parallel. */
  async #handleReconnect(discoveryType) {
    if (this.#clientReconnectInProgress) {
      throw new NodeNotConnectedError("Reconnection already in progress. Node not reachable currently.");
    }
    this.#clientReconnectInProgress = true;
    try {
      await this.reconnectFunc(discoveryType);
    } finally {
      this.#clientReconnectInProgress = false;
    }
  }
  /**
   * Trigger a reconnection to the device. This method is non-blocking and will return immediately.
   * The reconnection happens in the background. Please monitor the state of the node to see if the
   * reconnection was successful.
   */
  triggerReconnect() {
    if (this.#reconnectionInProgress || this.#remoteInitializationInProgress) {
      logger.info(
        `Ignoring reconnect request because ${this.#remoteInitializationInProgress ? "init" : "reconnect"} already underway.`
      );
      return;
    }
    this.#scheduleReconnect(0);
  }
  /**
   * Force a reconnection to the device.
   * This method is mainly used internally to reconnect after the active session
   * was closed or the device went offline and was detected as being online again.
   * Please note that this method does not return until the device is reconnected.
   * Please use triggerReconnect method for a non-blocking reconnection triggering.
   */
  async reconnect(connectOptions) {
    if (connectOptions !== void 0) {
      this.options = connectOptions;
    }
    if (this.#reconnectionInProgress || this.#remoteInitializationInProgress) {
      logger.debug(
        `Ignoring reconnect request because ${this.#remoteInitializationInProgress ? "init" : "reconnect"} already underway.`
      );
      return;
    }
    if (this.#reconnectDelayTimer?.isRunning) {
      this.#reconnectDelayTimer.stop();
    }
    this.#reconnectionInProgress = true;
    if (this.#connectionState !== 3 /* WaitingForDeviceDiscovery */) {
      this.#setConnectionState(2 /* Reconnecting */);
      try {
        await this.#handleReconnect(import_protocol.NodeDiscoveryType.None);
        this.#reconnectionInProgress = false;
        await this.#initialize();
        return;
      } catch (error) {
        if (error instanceof import_general.MatterError) {
          logger.info(
            `Node ${this.nodeId}: Simple re-establishing session did not worked. Reconnect ... `,
            error
          );
        } else {
          this.#reconnectionInProgress = false;
          throw error;
        }
      }
    }
    this.#setConnectionState(3 /* WaitingForDeviceDiscovery */);
    try {
      await this.#initialize();
    } catch (error) {
      import_general.MatterError.accept(error);
      if (error instanceof import_protocol.UnknownNodeError) {
        logger.info(`Node ${this.nodeId}: Node is unknown by controller, we can not connect.`);
        this.#setConnectionState(1 /* Disconnected */);
      } else if (this.#connectionState === 1 /* Disconnected */) {
        logger.info("No reconnection desired because requested status is Disconnected.");
      } else {
        if (error instanceof import_protocol.ChannelStatusResponseError) {
          logger.info(`Node ${this.nodeId}: Error while establishing new Channel, retrying ...`, error);
        } else if (error instanceof import_types.StatusResponseError) {
          logger.info(`Node ${this.nodeId}: Error while communicating with the device, retrying ...`, error);
        } else {
          logger.info(`Node ${this.nodeId}: Error waiting for device rediscovery, retrying`, error);
        }
        this.#reconnectErrorCount++;
        this.#scheduleReconnect();
      }
    } finally {
      this.#reconnectionInProgress = false;
    }
  }
  /** Ensure that the node is connected by creating a new InteractionClient if needed. */
  async #ensureConnection(forceConnect = false) {
    if (this.#connectionState === 1 /* Disconnected */) {
      this.#setConnectionState(2 /* Reconnecting */);
      return this.#interactionClient;
    }
    if (this.#connectionState === 0 /* Connected */ && !forceConnect) {
      return this.#interactionClient;
    }
    if (forceConnect) {
      this.#setConnectionState(3 /* WaitingForDeviceDiscovery */);
    }
    await this.#handleReconnect(import_protocol.NodeDiscoveryType.FullDiscovery);
    if (!forceConnect) {
      this.#setConnectionState(0 /* Connected */);
    }
    return this.#interactionClient;
  }
  async #initializeFromStoredData(storedAttributeData) {
    const { autoSubscribe } = this.options;
    if (this.#remoteInitializationDone || this.#localInitializationDone || autoSubscribe === false) return;
    let rootEndpointIncluded = false;
    let otherEndpointIncluded = false;
    if (!storedAttributeData.some(({ path: { endpointId } }) => {
      if (endpointId === 0) {
        rootEndpointIncluded = true;
      } else {
        otherEndpointIncluded = true;
      }
      return rootEndpointIncluded && otherEndpointIncluded;
    })) {
      return;
    }
    await this.#initializeEndpointStructure(storedAttributeData);
    await this.events.initialized.emit(this.#nodeDetails.toStorageData());
    this.#localInitializationDone = true;
  }
  /**
   * Initialize the node after the InteractionClient was created and to subscribe attributes and events if requested.
   */
  async #initialize() {
    if (this.#remoteInitializationInProgress) {
      logger.info(`Node ${this.nodeId}: Remote initialization already in progress ...`);
      return;
    }
    this.#remoteInitializationInProgress = true;
    try {
      await this.#ensureConnection(true);
      const { autoSubscribe, attributeChangedCallback, eventTriggeredCallback } = this.options;
      let deviceDetailsUpdated = false;
      if (!this.#nodeDetails.valid || autoSubscribe === false && !this.#remoteInitializationDone) {
        await this.#nodeDetails.enhanceDeviceDetailsFromRemote(this.#interactionClient);
        deviceDetailsUpdated = true;
      }
      const anyInitializationDone = this.#localInitializationDone || this.#remoteInitializationDone;
      if (autoSubscribe !== false) {
        const initialSubscriptionData = await this.subscribeAllAttributesAndEvents({
          ignoreInitialTriggers: !anyInitializationDone,
          // Trigger on updates only after initialization
          attributeChangedCallback: (data, oldValue) => {
            attributeChangedCallback?.(this.nodeId, data);
            this.events.attributeChanged.emit(data, oldValue);
          },
          eventTriggeredCallback: (data) => {
            eventTriggeredCallback?.(this.nodeId, data);
            this.events.eventTriggered.emit(data);
          }
        });
        if (initialSubscriptionData.attributeReports === void 0) {
          throw new import_general.InternalError("No attribute reports received when subscribing to all values!");
        }
        await this.#initializeEndpointStructure(
          initialSubscriptionData.attributeReports,
          anyInitializationDone
        );
        if (!deviceDetailsUpdated) {
          const rootEndpoint = this.getRootEndpoint();
          if (rootEndpoint !== void 0) {
            await this.#nodeDetails.enhanceDeviceDetailsFromCache(rootEndpoint);
          }
        }
      } else {
        const allClusterAttributes = await this.readAllAttributes();
        await this.#initializeEndpointStructure(allClusterAttributes, anyInitializationDone);
      }
      this.#reconnectErrorCount = 0;
      this.#setConnectionState(0 /* Connected */);
      await this.events.initializedFromRemote.emit(this.#nodeDetails.toStorageData());
      if (!this.#localInitializationDone) {
        await this.events.initialized.emit(this.#nodeDetails.toStorageData());
        this.#localInitializationDone = true;
      }
      this.#remoteInitializationDone = true;
    } finally {
      this.#remoteInitializationInProgress = false;
    }
  }
  /**
   * Request the current InteractionClient for custom special case interactions with the device. Usually the
   * ClusterClients of the Devices of the node should be used instead.
   */
  getInteractionClient() {
    return this.#ensureConnection();
  }
  /** Method to log the structure of this node with all endpoint and clusters. */
  logStructure(options) {
    const rootEndpoint = this.#endpoints.get((0, import_types.EndpointNumber)(0));
    if (rootEndpoint === void 0) {
      logger.info(`Node ${this.nodeId} has not yet been initialized!`);
      return;
    }
    (0, import_protocol.logEndpoint)(rootEndpoint, options);
  }
  /**
   * Subscribe to all attributes and events of the device. Unless setting the Controller property autoSubscribe to
   * false this is executed automatically. Alternatively you can manually subscribe by calling this method.
   */
  async subscribeAllAttributesAndEvents(options) {
    options = options ?? {};
    const { attributeChangedCallback, eventTriggeredCallback } = options;
    let { ignoreInitialTriggers = false } = options;
    const { minIntervalFloorSeconds, maxIntervalCeilingSeconds } = this.#nodeDetails.determineSubscriptionParameters(this.options);
    const { threadConnected } = this.#nodeDetails.meta ?? {};
    if (this.#currentSubscriptionHandler !== void 0) {
      this.#currentSubscriptionHandler.attributeListener = () => {
      };
      this.#currentSubscriptionHandler.eventListener = () => {
      };
      this.#currentSubscriptionHandler.updateTimeoutHandler = () => {
      };
      this.#currentSubscriptionHandler.subscriptionAlive = () => {
      };
    }
    const subscriptionHandler = {
      attributeListener: (data, changed, oldValue) => {
        if (ignoreInitialTriggers || changed === false) {
          return;
        }
        const {
          path: { endpointId, clusterId, attributeId },
          value
        } = data;
        const device = this.#endpoints.get(endpointId);
        if (device === void 0) {
          logger.info(
            `Node ${this.nodeId} Ignoring received attribute update for unknown endpoint ${endpointId}!`
          );
          return;
        }
        const cluster = device.getClusterClientById(clusterId);
        if (cluster === void 0) {
          logger.info(
            `Node ${this.nodeId} Ignoring received attribute update for unknown cluster ${import_general.Diagnostic.hex(
              clusterId
            )} on endpoint ${endpointId}!`
          );
          return;
        }
        logger.debug(
          `Node ${this.nodeId} Trigger attribute update for ${endpointId}.${cluster.name}.${attributeId} to ${import_general.Logger.toJSON(
            value
          )} (changed: ${changed})`
        );
        (0, import_TypeHelpers.asClusterClientInternal)(cluster)._triggerAttributeUpdate(attributeId, value);
        attributeChangedCallback?.(data, oldValue);
        this.#checkAttributesForNeededStructureUpdate(endpointId, clusterId, attributeId);
      },
      eventListener: (data) => {
        if (ignoreInitialTriggers) return;
        const {
          path: { endpointId, clusterId, eventId },
          events
        } = data;
        const device = this.#endpoints.get(endpointId);
        if (device === void 0) {
          logger.info(`Node ${this.nodeId} Ignoring received event for unknown endpoint ${endpointId}!`);
          return;
        }
        const cluster = device.getClusterClientById(clusterId);
        if (cluster === void 0) {
          logger.info(
            `Node ${this.nodeId} Ignoring received event for unknown cluster ${import_general.Diagnostic.hex(
              clusterId
            )} on endpoint ${endpointId}!`
          );
          return;
        }
        logger.debug(
          `Node ${this.nodeId} Trigger event update for ${endpointId}.${cluster.name}.${eventId} for ${events.length} events`
        );
        (0, import_TypeHelpers.asClusterClientInternal)(cluster)._triggerEventUpdate(eventId, events);
        eventTriggeredCallback?.(data);
        this.#checkEventsForNeededStructureUpdate(endpointId, clusterId, eventId);
      },
      updateTimeoutHandler: async () => {
        logger.info(`Node ${this.nodeId}: Subscription timed out ... trying to re-establish ...`);
        this.#setConnectionState(2 /* Reconnecting */);
        this.#reconnectionInProgress = true;
        try {
          await this.subscribeAllAttributesAndEvents({ ...options, ignoreInitialTriggers: false });
          this.#setConnectionState(0 /* Connected */);
        } catch (error) {
          logger.info(
            `Node ${this.nodeId}: Error resubscribing to all attributes and events. Try to reconnect ...`,
            error
          );
          this.#scheduleReconnect();
        } finally {
          this.#reconnectionInProgress = false;
        }
      },
      subscriptionAlive: () => {
        if (this.#reconnectDelayTimer?.isRunning && this.#connectionState === 2 /* Reconnecting */) {
          logger.info(`Node ${this.nodeId}: Got subscription update, so reconnection not needed anymore ...`);
          this.#reconnectDelayTimer.stop();
          this.#reconnectDelayTimer = void 0;
          this.#setConnectionState(0 /* Connected */);
        }
      }
    };
    this.#currentSubscriptionHandler = subscriptionHandler;
    const maxKnownEventNumber = this.#interactionClient.maxKnownEventNumber;
    const initialSubscriptionData = await this.#interactionClient.subscribeAllAttributesAndEvents({
      isUrgent: true,
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      keepSubscriptions: false,
      dataVersionFilters: this.#interactionClient.getCachedClusterDataVersions(),
      enrichCachedAttributeData: true,
      eventFilters: maxKnownEventNumber !== void 0 ? [{ eventMin: maxKnownEventNumber + 1n }] : void 0,
      executeQueued: !!threadConnected,
      // We queue subscriptions for thread devices
      attributeListener: (data, changed, oldValue) => subscriptionHandler.attributeListener(data, changed, oldValue),
      eventListener: (data) => subscriptionHandler.eventListener(data),
      updateTimeoutHandler: () => subscriptionHandler.updateTimeoutHandler()
    });
    ignoreInitialTriggers = false;
    return initialSubscriptionData;
  }
  async readAllAttributes() {
    return this.#interactionClient.getAllAttributes({
      dataVersionFilters: this.#interactionClient.getCachedClusterDataVersions(),
      enrichCachedAttributeData: true
    });
  }
  #checkAttributesForNeededStructureUpdate(_endpointId, clusterId, attributeId) {
    let structureUpdateNeeded = false;
    if (clusterId === import_clusters.DescriptorCluster.id) {
      switch (attributeId) {
        case import_clusters.DescriptorCluster.attributes.partsList.id:
        case import_clusters.DescriptorCluster.attributes.serverList.id:
        case import_clusters.DescriptorCluster.attributes.deviceTypeList.id:
          structureUpdateNeeded = true;
          break;
      }
    }
    if (!structureUpdateNeeded) {
      switch (attributeId) {
        case import_model.FeatureMap.id:
        case import_model.AttributeList.id:
        case import_model.AcceptedCommandList.id:
        case import_model.ClusterRevision.id:
          structureUpdateNeeded = true;
          break;
      }
    }
    if (structureUpdateNeeded) {
      logger.info(`Node ${this.nodeId}: Endpoint structure needs to be updated ...`);
      this.#updateEndpointStructureTimer.stop().start();
    }
  }
  #checkEventsForNeededStructureUpdate(_endpointId, clusterId, eventId) {
    if (clusterId === import_clusters.BasicInformation.Cluster.id && eventId === import_clusters.BasicInformation.Cluster.events.shutDown.id) {
      this.#handleNodeShutdown();
    }
  }
  /** Handles a node shutDown event (if supported by the node and received). */
  #handleNodeShutdown() {
    logger.info(`Node ${this.nodeId}: Node shutdown detected, trying to reconnect ...`);
    this.#scheduleReconnect(RECONNECT_DELAY_AFTER_SHUTDOWN_MS);
  }
  #scheduleReconnect(delay) {
    if (this.state !== 3 /* WaitingForDeviceDiscovery */) {
      this.#setConnectionState(2 /* Reconnecting */);
    }
    if (!this.#reconnectDelayTimer?.isRunning) {
      this.#reconnectDelayTimer?.stop();
    }
    if (delay === void 0) {
      delay = Math.min(RECONNECT_DELAY_MS * 2 ** this.#reconnectErrorCount, RECONNECT_MAX_DELAY_MS);
    }
    logger.info(`Node ${this.nodeId}: Reconnecting in ${Math.round(delay / 1e3)}s ...`);
    this.#reconnectDelayTimer = import_general.Time.getTimer("Reconnect delay", delay, async () => await this.reconnect());
    this.#reconnectDelayTimer.start();
  }
  async #updateEndpointStructure() {
    const allClusterAttributes = await this.readAllAttributes();
    await this.#initializeEndpointStructure(allClusterAttributes, true);
    this.options.stateInformationCallback?.(this.nodeId, 4 /* StructureChanged */);
    this.events.structureChanged.emit();
  }
  /** Reads all data from the device and create a device object structure out of it. */
  async #initializeEndpointStructure(allClusterAttributes, updateStructure = false) {
    const allData = (0, import_protocol.structureReadAttributeDataToClusterObject)(allClusterAttributes);
    if (updateStructure) {
      const endpointsToRemove = new Set(this.#endpoints.keys());
      for (const [endpointId] of Object.entries(allData)) {
        const endpointIdNumber = (0, import_types.EndpointNumber)(parseInt(endpointId));
        if (this.#endpoints.has(endpointIdNumber)) {
          logger.debug("Retaining device", endpointId);
          endpointsToRemove.delete(endpointIdNumber);
        }
      }
      for (const endpointId of endpointsToRemove.values()) {
        logger.debug("Removing device", endpointId);
        this.#endpoints.get(endpointId)?.removeFromStructure();
        this.#endpoints.delete(endpointId);
      }
    } else {
      this.#endpoints.clear();
    }
    const partLists = /* @__PURE__ */ new Map();
    for (const [endpointId, clusters] of Object.entries(allData)) {
      const endpointIdNumber = (0, import_types.EndpointNumber)(parseInt(endpointId));
      const descriptorData = clusters[import_clusters.DescriptorCluster.id];
      partLists.set(endpointIdNumber, descriptorData.partsList);
      if (this.#endpoints.has(endpointIdNumber)) {
        continue;
      }
      logger.debug("Creating device", endpointId, import_general.Logger.toJSON(clusters));
      this.#endpoints.set(
        endpointIdNumber,
        this.#createDevice(endpointIdNumber, clusters, this.#interactionClient)
      );
    }
    this.#structureEndpoints(partLists);
  }
  /** Bring the endpoints in a structure based on their partsList attribute. */
  #structureEndpoints(partLists) {
    logger.debug(`Node ${this.nodeId}: Endpoints from PartsLists`, import_general.Logger.toJSON(Array.from(partLists.entries())));
    const endpointUsages = {};
    Array.from(partLists.entries()).forEach(
      ([parent, partsList]) => partsList.forEach((endPoint) => {
        if (endPoint === parent) {
          logger.warn(`Node ${this.nodeId}: Endpoint ${endPoint} is referencing itself!`);
          return;
        }
        endpointUsages[endPoint] = endpointUsages[endPoint] || [];
        endpointUsages[endPoint].push(parent);
      })
    );
    logger.debug(`Node ${this.nodeId}: Endpoint usages`, import_general.Logger.toJSON(endpointUsages));
    while (true) {
      const singleUsageEndpoints = Object.entries(endpointUsages).filter(([_, usages]) => usages.length === 1);
      if (singleUsageEndpoints.length === 0) {
        if (Object.entries(endpointUsages).length)
          throw new import_general.InternalError(`Endpoint structure for Node ${this.nodeId} could not be parsed!`);
        break;
      }
      logger.debug(`Node ${this.nodeId}: Processing Endpoint ${import_general.Logger.toJSON(singleUsageEndpoints)}`);
      const idsToCleanup = {};
      singleUsageEndpoints.forEach(([childId, usages]) => {
        const childEndpointId = (0, import_types.EndpointNumber)(parseInt(childId));
        const childEndpoint = this.#endpoints.get(childEndpointId);
        const parentEndpoint = this.#endpoints.get(usages[0]);
        if (childEndpoint === void 0 || parentEndpoint === void 0) {
          throw new import_general.InternalError(`Node ${this.nodeId}: Endpoint not found!`);
        }
        if (parentEndpoint.getChildEndpoint(childEndpointId) === void 0) {
          logger.debug(
            `Node ${this.nodeId}: Endpoint structure: Child: ${childEndpointId} -> Parent: ${parentEndpoint.number}`
          );
          parentEndpoint.addChildEndpoint(childEndpoint);
        }
        delete endpointUsages[(0, import_types.EndpointNumber)(parseInt(childId))];
        idsToCleanup[usages[0]] = true;
      });
      logger.debug(`Node ${this.nodeId}: Endpoint data Cleanup`, import_general.Logger.toJSON(idsToCleanup));
      Object.keys(idsToCleanup).forEach((idToCleanup) => {
        Object.keys(endpointUsages).forEach((id) => {
          const usageId = (0, import_types.EndpointNumber)(parseInt(id));
          endpointUsages[usageId] = endpointUsages[usageId].filter(
            (endpointId) => endpointId !== parseInt(idToCleanup)
          );
          if (!endpointUsages[usageId].length) {
            delete endpointUsages[usageId];
          }
        });
      });
    }
  }
  /**
   * Create a device object from the data read from the device.
   *
   * @param endpointId Endpoint ID
   * @param data Data of all clusters read from the device
   * @param interactionClient InteractionClient to use for the device
   * @private
   */
  #createDevice(endpointId, data, interactionClient) {
    const descriptorData = data[import_clusters.DescriptorCluster.id];
    const deviceTypes = descriptorData.deviceTypeList.flatMap(({ deviceType, revision }) => {
      const deviceTypeDefinition = (0, import_DeviceTypes.getDeviceTypeDefinitionByCode)(deviceType);
      if (deviceTypeDefinition === void 0) {
        logger.info(
          `NodeId ${this.nodeId}: Device type with code ${deviceType} not known, use generic replacement.`
        );
        return (0, import_DeviceTypes.UnknownDeviceType)(deviceType, revision);
      }
      if (deviceTypeDefinition.revision < revision) {
        logger.debug(
          `NodeId ${this.nodeId}: Device type with code ${deviceType} and revision ${revision} not supported, some data might be unknown.`
        );
      }
      return deviceTypeDefinition;
    });
    if (deviceTypes.length === 0) {
      logger.info(`NodeId ${this.nodeId}: No device type found for endpoint ${endpointId}, ignore`);
      throw new import_general.MatterError(`NodeId ${this.nodeId}: No device type found for endpoint`);
    }
    const endpointClusters = Array();
    for (const clusterId of descriptorData.serverList) {
      const cluster = (0, import_types.getClusterById)(clusterId);
      const clusterClient = (0, import_protocol.ClusterClient)(cluster, endpointId, interactionClient, data[clusterId]);
      endpointClusters.push(clusterClient);
    }
    for (const clusterId of descriptorData.clientList) {
      const cluster = (0, import_types.getClusterById)(clusterId);
      const clusterData = data[clusterId] ?? {};
      endpointClusters.push(
        (0, import_ClusterServer.ClusterServer)(
          cluster,
          /*clusterData.featureMap,*/
          clusterData,
          {},
          void 0,
          true
        )
      );
    }
    if (endpointId === 0) {
      const rootEndpoint = new import_Device.RootEndpoint();
      rootEndpoint.setDeviceTypes(deviceTypes);
      endpointClusters.forEach((cluster) => {
        if ((0, import_ClusterServerTypes.isClusterServer)(cluster)) {
          rootEndpoint.addClusterServer(cluster);
        } else if ((0, import_TypeHelpers.isClusterClient)(cluster)) {
          rootEndpoint.addClusterClient(cluster);
        }
      });
      return rootEndpoint;
    } else if (deviceTypes.find((deviceType) => deviceType.code === import_DeviceTypes.DeviceTypes.AGGREGATOR.code) !== void 0) {
      const aggregator = new import_Aggregator.Aggregator([], { endpointId });
      aggregator.setDeviceTypes(deviceTypes);
      endpointClusters.forEach((cluster) => {
        if ((0, import_ClusterServerTypes.isClusterServer)(cluster)) {
          aggregator.addClusterServer(cluster);
        } else if ((0, import_TypeHelpers.isClusterClient)(cluster)) {
          aggregator.addClusterClient(cluster);
        }
      });
      return aggregator;
    } else {
      if (descriptorData.partsList.length > 0) {
        const composedDevice = new import_ComposedDevice.ComposedDevice(deviceTypes[0], [], { endpointId });
        composedDevice.setDeviceTypes(deviceTypes);
        endpointClusters.forEach((cluster) => {
          if ((0, import_ClusterServerTypes.isClusterServer)(cluster)) {
            composedDevice.addClusterServer(cluster);
          } else if ((0, import_TypeHelpers.isClusterClient)(cluster)) {
            composedDevice.addClusterClient(cluster);
          }
        });
        return composedDevice;
      } else {
        return new import_Device.PairedDevice(deviceTypes, endpointClusters, endpointId);
      }
    }
  }
  /** Returns the functional devices/endpoints (those below the Root Endpoint) known for this node. */
  getDevices() {
    return this.#endpoints.get((0, import_types.EndpointNumber)(0))?.getChildEndpoints() ?? [];
  }
  /** Returns the device/endpoint with the given endpoint ID. */
  getDeviceById(endpointId) {
    return this.#endpoints.get((0, import_types.EndpointNumber)(endpointId));
  }
  getRootEndpoint() {
    return this.getDeviceById(0);
  }
  /** De-Commission (unpair) the device from this controller by removing the fabric from the device. */
  async decommission() {
    if (!this.commissioningController.isNodeCommissioned(this.nodeId)) {
      throw new import_general.ImplementationError(`This Node ${this.nodeId} is not commissioned.`);
    }
    if (this.#connectionState === 2 /* Reconnecting */ || this.#connectionState === 3 /* WaitingForDeviceDiscovery */) {
      throw new import_general.ImplementationError(
        `This Node ${this.nodeId} is currently in a reconnect state, decommissioning is not possible.`
      );
    }
    const operationalCredentialsCluster = this.getRootClusterClient(import_clusters.OperationalCredentials.Cluster);
    if (operationalCredentialsCluster === void 0) {
      throw new import_general.ImplementationError(`OperationalCredentialsCluster for node ${this.nodeId} not found.`);
    }
    const fabricIndex = await operationalCredentialsCluster.getCurrentFabricIndexAttribute(true);
    logger.debug(`Removing node ${this.nodeId} by removing fabric ${fabricIndex} on the node.`);
    const result = await operationalCredentialsCluster.commands.removeFabric({ fabricIndex });
    if (result.statusCode !== import_clusters.OperationalCredentials.NodeOperationalCertStatus.Ok) {
      throw new import_general.MatterError(
        `Removing node ${this.nodeId} failed with status ${result.statusCode} "${result.debugText}".`
      );
    }
    this.#setConnectionState(1 /* Disconnected */);
    await this.commissioningController.removeNode(this.nodeId, false);
  }
  /** Opens a Basic Commissioning Window (uses the original Passcode printed on the device) with the device. */
  async openBasicCommissioningWindow(commissioningTimeout = 900) {
    const adminCommissioningCluster = this.getRootClusterClient(import_clusters.AdministratorCommissioning.Cluster.with("Basic"));
    if (adminCommissioningCluster === void 0) {
      throw new import_general.ImplementationError(`AdministratorCommissioningCluster for node ${this.nodeId} not found.`);
    }
    if (adminCommissioningCluster.supportedFeatures.basic === false) {
      throw new import_general.ImplementationError(
        `AdministratorCommissioningCluster for node ${this.nodeId} does not support basic commissioning.`
      );
    }
    try {
      await adminCommissioningCluster.commands.revokeCommissioning();
    } catch (error) {
      if (!import_types.StatusResponseError.is(error, import_types.StatusCode.Failure) || error.clusterCode !== import_clusters.AdministratorCommissioning.StatusCode.WindowNotOpen) {
        throw error;
      }
    }
    await adminCommissioningCluster.commands.openBasicCommissioningWindow({ commissioningTimeout });
  }
  /** Opens an Enhanced Commissioning Window (uses a generated random Passcode) with the device. */
  async openEnhancedCommissioningWindow(commissioningTimeout = 900) {
    const adminCommissioningCluster = this.getRootClusterClient(import_clusters.AdministratorCommissioning.Cluster);
    if (adminCommissioningCluster === void 0) {
      throw new import_general.ImplementationError(`AdministratorCommissioningCluster for node ${this.nodeId} not found.`);
    }
    try {
      await adminCommissioningCluster.commands.revokeCommissioning();
    } catch (error) {
      if (!import_types.StatusResponseError.is(error, import_types.StatusCode.Failure) || error.clusterCode !== import_clusters.AdministratorCommissioning.StatusCode.WindowNotOpen) {
        throw error;
      }
    }
    const basicInformationCluster = this.getRootClusterClient(import_clusters.BasicInformation.Cluster);
    if (basicInformationCluster == void 0) {
      throw new import_general.ImplementationError(`BasicInformationCluster for node ${this.nodeId} not found.`);
    }
    const vendorId = await basicInformationCluster.getVendorIdAttribute();
    const productId = await basicInformationCluster.getProductIdAttribute();
    const discriminator = import_protocol.PaseClient.generateRandomDiscriminator();
    const passcode = import_protocol.PaseClient.generateRandomPasscode();
    const salt = import_general.Crypto.get().getRandomData(32);
    const iterations = 1e3;
    const pakePasscodeVerifier = await import_protocol.PaseClient.generatePakePasscodeVerifier(passcode, {
      iterations,
      salt
    });
    await adminCommissioningCluster.commands.openCommissioningWindow({
      commissioningTimeout,
      pakePasscodeVerifier,
      salt,
      iterations,
      discriminator
    });
    const qrPairingCode = import_types.QrPairingCodeCodec.encode([
      {
        version: 0,
        vendorId,
        productId,
        flowType: import_types.CommissioningFlowType.Standard,
        discriminator,
        passcode,
        discoveryCapabilities: import_types.DiscoveryCapabilitiesSchema.encode({
          onIpNetwork: true
        })
      }
    ]);
    return {
      manualPairingCode: import_types.ManualPairingCodeCodec.encode({
        discriminator,
        passcode
      }),
      qrPairingCode
    };
  }
  async disconnect() {
    this.close();
    await this.commissioningController.disconnectNode(this.nodeId);
  }
  close(sendDecommissionedStatus = false) {
    this.#reconnectDelayTimer?.stop();
    this.#reconnectDelayTimer = void 0;
    this.#updateEndpointStructureTimer.stop();
    if (sendDecommissionedStatus) {
      this.options.stateInformationCallback?.(this.nodeId, 5 /* Decommissioned */);
      this.events.decommissioned.emit();
    }
    this.#setConnectionState(1 /* Disconnected */);
  }
  /**
   * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterServer to get or undefined if not existing
   */
  getRootClusterServer(cluster) {
    return this.#endpoints.get((0, import_types.EndpointNumber)(0))?.getClusterServer(cluster);
  }
  /**
   * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterClient to get or undefined if not existing
   */
  getRootClusterClient(cluster) {
    return this.#endpoints.get((0, import_types.EndpointNumber)(0))?.getClusterClient(cluster);
  }
  /**
   * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param endpointId EndpointNumber to get the cluster from
   * @param cluster ClusterServer to get or undefined if not existing
   */
  getClusterServerForDevice(endpointId, cluster) {
    return this.getDeviceById(endpointId)?.getClusterServer(cluster);
  }
  /**
   * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param endpointId EndpointNumber to get the cluster from
   * @param cluster ClusterClient to get or undefined if not existing
   */
  getClusterClientForDevice(endpointId, cluster) {
    return this.getDeviceById(endpointId)?.getClusterClient(cluster);
  }
}
//# sourceMappingURL=PairedNode.js.map
