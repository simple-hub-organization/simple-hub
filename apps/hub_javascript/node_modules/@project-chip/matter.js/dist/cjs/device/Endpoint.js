"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Endpoint_exports = {};
__export(Endpoint_exports, {
  Endpoint: () => Endpoint
});
module.exports = __toCommonJS(Endpoint_exports);
var import_clusters = require("#clusters");
var import_general = require("#general");
var import_types = require("#types");
var import_ClusterServer = require("../cluster/server/ClusterServer.js");
var import_ClusterServerTypes = require("../cluster/server/ClusterServerTypes.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class Endpoint {
  /**
   * Create a new Endpoint instance.
   *
   * @param deviceTypes One or multiple DeviceTypeDefinitions of the endpoint
   * @param options Options for the endpoint
   */
  constructor(deviceTypes, options = {}) {
    this.deviceTypes = deviceTypes;
    this.descriptorCluster = (0, import_ClusterServer.ClusterServer)(
      import_clusters.DescriptorCluster,
      {
        deviceTypeList: deviceTypes.map((deviceType) => ({
          deviceType: deviceType.code,
          revision: deviceType.revision
        })),
        serverList: [],
        clientList: [],
        partsList: []
      },
      {}
    );
    this.addClusterServer(this.descriptorCluster);
    this.setDeviceTypes(deviceTypes);
    if (options.endpointId !== void 0) {
      this.number = options.endpointId;
    }
    if (options.uniqueStorageKey !== void 0) {
      this.uniqueStorageKey = options.uniqueStorageKey;
    }
  }
  clusterServers = /* @__PURE__ */ new Map();
  clusterClients = /* @__PURE__ */ new Map();
  childEndpoints = [];
  number;
  uniqueStorageKey;
  name = "";
  structureChangedCallback = () => {
  };
  descriptorCluster;
  get deviceType() {
    return this.deviceTypes[0].code;
  }
  setStructureChangedCallback(callback) {
    this.structureChangedCallback = callback;
    this.childEndpoints.forEach((endpoint) => endpoint.setStructureChangedCallback(callback));
  }
  removeFromStructure() {
    this.close();
    this.structureChangedCallback = () => {
    };
    this.childEndpoints.forEach((endpoint) => endpoint.removeFromStructure());
  }
  close() {
    for (const clusterServer of this.clusterServers.values()) {
      (0, import_ClusterServerTypes.asClusterServerInternal)(clusterServer)._close();
    }
  }
  getNumber() {
    if (this.number === void 0) {
      throw new import_general.InternalError("Endpoint has not been assigned yet");
    }
    return this.number;
  }
  addFixedLabel(label, value) {
    if (!this.hasClusterServer(import_clusters.FixedLabelCluster)) {
      this.addClusterServer(
        (0, import_ClusterServer.ClusterServer)(
          import_clusters.FixedLabelCluster,
          {
            labelList: []
          },
          {}
        )
      );
    }
    const fixedLabelCluster = this.getClusterServer(import_clusters.FixedLabelCluster);
    const labelList = (fixedLabelCluster?.getLabelListAttribute() ?? []).filter(
      ({ label: entryLabel }) => entryLabel !== label
      // Prevent adding duplicate labels
    );
    labelList.push({ label, value });
    fixedLabelCluster?.setLabelListAttribute(labelList);
  }
  addUserLabel(label, value) {
    if (!this.hasClusterServer(import_clusters.UserLabelCluster)) {
      this.addClusterServer(
        (0, import_ClusterServer.ClusterServer)(
          import_clusters.UserLabelCluster,
          {
            labelList: []
          },
          {}
        )
      );
    }
    const userLabelCluster = this.getClusterServer(import_clusters.UserLabelCluster);
    const labelList = (userLabelCluster?.getLabelListAttribute() ?? []).filter(
      ({ label: entryLabel }) => entryLabel !== label
      // Prevent adding duplicate labels
    );
    labelList.push({ label, value });
    userLabelCluster?.setLabelListAttribute(labelList);
  }
  addClusterServer(cluster) {
    const currentCluster = this.clusterServers.get(cluster.id);
    if (currentCluster !== void 0) {
      (0, import_ClusterServerTypes.asClusterServerInternal)(currentCluster)._close();
    }
    (0, import_ClusterServerTypes.asClusterServerInternal)(cluster)._assignToEndpoint(this);
    if (cluster.id === import_clusters.DescriptorCluster.id) {
      this.descriptorCluster = cluster;
    }
    this.clusterServers.set(cluster.id, cluster);
    this.descriptorCluster.attributes.serverList.init(Array.from(this.clusterServers.keys()).sort((a, b) => a - b));
    this.structureChangedCallback();
  }
  addClusterClient(cluster) {
    this.clusterClients.set(cluster.id, cluster);
    this.descriptorCluster.attributes.clientList.init(Array.from(this.clusterClients.keys()).sort((a, b) => a - b));
    this.structureChangedCallback();
  }
  // TODO cleanup with id number vs ClusterId
  // TODO add instance if optional and not existing, maybe get rid of undefined by throwing?
  getClusterServer(cluster) {
    const clusterServer = this.clusterServers.get(cluster.id);
    if (clusterServer !== void 0) {
      return clusterServer;
    }
  }
  getClusterClient(cluster) {
    return this.clusterClients.get(cluster.id);
  }
  getClusterServerById(clusterId) {
    return this.clusterServers.get(clusterId);
  }
  getClusterClientById(clusterId) {
    return this.clusterClients.get(clusterId);
  }
  hasClusterServer(cluster) {
    return this.clusterServers.has(cluster.id);
  }
  hasClusterClient(cluster) {
    return this.clusterClients.has(cluster.id);
  }
  getDeviceTypes() {
    return this.deviceTypes;
  }
  setDeviceTypes(deviceTypes) {
    const deviceTypeList = /* @__PURE__ */ new Map();
    deviceTypes.forEach((deviceType) => deviceTypeList.set(deviceType.code, deviceType));
    this.deviceTypes = Array.from(deviceTypeList.values());
    this.name = deviceTypes[0].name;
    this.descriptorCluster.attributes.deviceTypeList.init(
      this.deviceTypes.map((deviceType) => ({
        deviceType: deviceType.code,
        revision: deviceType.revision
      }))
    );
  }
  addChildEndpoint(endpoint) {
    if (!(endpoint instanceof Endpoint)) {
      throw new Error("Only supported EndpointInterface implementation is Endpoint");
    }
    if (endpoint.number !== void 0 && this.getChildEndpoint(endpoint.number) !== void 0) {
      throw new import_general.ImplementationError(
        `Endpoint with id ${endpoint.number} already exists as child from ${this.number}.`
      );
    }
    this.childEndpoints.push(endpoint);
    endpoint.setStructureChangedCallback(this.structureChangedCallback);
    this.structureChangedCallback();
  }
  getChildEndpoint(id) {
    return this.childEndpoints.find((endpoint) => endpoint.number === id);
  }
  getChildEndpoints() {
    return this.childEndpoints;
  }
  removeChildEndpoint(endpoint) {
    const index = this.childEndpoints.indexOf(endpoint);
    if (index === -1) {
      throw new import_general.ImplementationError(`Provided endpoint for deletion does not exist as child endpoint.`);
    }
    this.childEndpoints.splice(index, 1);
    endpoint.removeFromStructure();
    this.structureChangedCallback();
  }
  determineUniqueID() {
    if (this.uniqueStorageKey !== void 0) {
      return `custom_${this.uniqueStorageKey}`;
    }
    const basicInformationCluster = this.getClusterServer(import_clusters.BasicInformationCluster) ?? this.getClusterServer(import_clusters.BridgedDeviceBasicInformationCluster);
    if (basicInformationCluster !== void 0) {
      const uniqueId = basicInformationCluster.getUniqueIdAttribute?.();
      if (uniqueId !== void 0) {
        return `unique_${uniqueId}`;
      }
      const serialNumber = basicInformationCluster.getSerialNumberAttribute?.();
      if (serialNumber !== void 0) {
        return `serial_${serialNumber}`;
      }
    }
  }
  verifyRequiredClusters() {
    this.deviceTypes.forEach((deviceType) => {
      deviceType.requiredServerClusters?.forEach((clusterId) => {
        if (!this.clusterServers.has(clusterId)) {
          const clusterName = (0, import_types.getClusterNameById)(clusterId);
          throw new import_general.ImplementationError(
            `Device type ${deviceType.name} (0x${deviceType.code.toString(
              16
            )}) requires cluster server ${clusterName}(0x${clusterId.toString(
              16
            )}) but it is not present on endpoint ${this.number}`
          );
        }
      });
      if (this.clusterClients.size > 0) {
        throw new import_general.NotImplementedError(`Devices with client clusters are not supported yet`);
      }
      deviceType.requiredClientClusters?.forEach((clusterId) => {
        const clusterName = (0, import_types.getClusterNameById)(clusterId);
        if (!this.clusterClients.has(clusterId)) {
          throw new import_general.ImplementationError(
            `Device type ${deviceType.name} (0x${deviceType.code.toString(
              16
            )}) requires cluster client ${clusterName}(0x${clusterId.toString(
              16
            )}) but it is not present on endpoint ${this.number}`
          );
        }
      });
    });
  }
  getAllClusterServers() {
    return Array.from(this.clusterServers.values());
  }
  getAllClusterClients() {
    return Array.from(this.clusterClients.values());
  }
  updatePartsList() {
    const newPartsList = new Array();
    for (const child of this.childEndpoints) {
      const childPartsList = child.updatePartsList();
      if (child.number === void 0) {
        throw new import_general.InternalError(`Child endpoint has no id, cannot add to parts list`);
      }
      newPartsList.push((0, import_types.EndpointNumber)(child.number));
      newPartsList.push(...childPartsList);
    }
    this.descriptorCluster.attributes.partsList.setLocal(newPartsList);
    return newPartsList;
  }
}
//# sourceMappingURL=Endpoint.js.map
