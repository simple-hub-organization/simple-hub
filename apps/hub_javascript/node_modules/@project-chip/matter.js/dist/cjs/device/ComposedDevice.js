"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ComposedDevice_exports = {};
__export(ComposedDevice_exports, {
  ComposedDevice: () => ComposedDevice
});
module.exports = __toCommonJS(ComposedDevice_exports);
var import_clusters = require("#clusters");
var import_general = require("#general");
var import_Endpoint = require("./Endpoint.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class ComposedDevice extends import_Endpoint.Endpoint {
  /**
   * Creates a new ComposedDevice.
   *
   * @param definition DeviceTypeDefinitions of the composed device
   * @param devices Array with devices that should be combined into one device that are directly added.
   * @param options Optional Endpoint options
   */
  constructor(definition, devices = [], options = {}) {
    super([definition], options);
    devices.forEach((device) => this.addDevice(device));
  }
  /**
   * Add a sub-device to the composed device.
   * @param device Device instance to add
   */
  addDevice(device) {
    this.addChildEndpoint(device);
  }
  /**
   * Get all sub-devices of the composed device.
   *
   * @returns Array with all sub-devices
   */
  getDevices() {
    return this.getChildEndpoints();
  }
  /**
   * Verify that the required clusters exists on the device.
   */
  verifyRequiredClusters() {
    return;
  }
  /**
   * Set the reachability of the Composed device exposed via the bridge.
   *
   * @param reachable true if reachable, false otherwise
   */
  setBridgedDeviceReachability(reachable) {
    const bridgedBasicInformationCluster = this.getClusterServer(import_clusters.BridgedDeviceBasicInformationCluster);
    if (bridgedBasicInformationCluster === void 0) {
      throw new import_general.ImplementationError(
        "The reachability flag can only be set for bridged devices this way. To set the reachability flag for a non-bridged device or for the bridget itself please set it on the CommissioningServer!"
      );
    }
    bridgedBasicInformationCluster.setReachableAttribute(reachable);
  }
}
//# sourceMappingURL=ComposedDevice.js.map
