"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Device_exports = {};
__export(Device_exports, {
  Device: () => Device,
  PairedDevice: () => PairedDevice,
  RootEndpoint: () => RootEndpoint,
  WrapCommandHandler: () => WrapCommandHandler
});
module.exports = __toCommonJS(Device_exports);
var import_clusters = require("#clusters");
var import_general = require("#general");
var import_types = require("#types");
var import_ClusterServer = require("../cluster/server/ClusterServer.js");
var import_ClusterServerTypes = require("../cluster/server/ClusterServerTypes.js");
var import_DeviceTypes = require("./DeviceTypes.js");
var import_Endpoint = require("./Endpoint.js");
var import_TypeHelpers = require("./TypeHelpers.js");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const WrapCommandHandler = (handler, commandHandler) => {
  if (commandHandler === void 0) {
    return handler;
  }
  const mergedHandler = {};
  for (const key in handler) {
    if (key.endsWith("AttributeGetter") || key.endsWith("AttributeSetter") || key.endsWith("AttributeValidator") || key === "initializeClusterServer" || key === "destroyClusterServer") {
      mergedHandler[key] = handler[key];
      continue;
    }
    mergedHandler[key] = async (...args) => {
      if (commandHandler.hasHandler(key)) {
        return await commandHandler.executeHandler(key, ...args);
      }
      return await handler[key](...args);
    };
  }
  return mergedHandler;
};
class PairedDevice extends import_Endpoint.Endpoint {
  declineAddingMoreClusters;
  /**
   * Create a new PairedDevice instance. All data are automatically parsed from the paired device!
   *
   * @param definition DeviceTypeDefinitions of the paired device as reported by the device
   * @param clusters Clusters of the paired device as reported by the device
   * @param endpointId Endpoint ID of the paired device as reported by the device
   */
  constructor(definition, clusters = [], endpointId) {
    super(definition, { endpointId });
    clusters.forEach((cluster) => {
      if ((0, import_ClusterServerTypes.isClusterServer)(cluster)) {
        this.addClusterServer(cluster);
      } else if ((0, import_TypeHelpers.isClusterClient)(cluster)) {
        this.addClusterClient(cluster);
      }
    });
    this.declineAddingMoreClusters = true;
  }
  /**
   * Add cluster servers (used internally only!)
   * @deprecated PairedDevice does not support adding additional clusters
   */
  addClusterServer(cluster) {
    if (this.declineAddingMoreClusters) {
      throw new import_general.ImplementationError("PairedDevice does not support adding additional clusters");
    }
    return super.addClusterServer(cluster);
  }
  /**
   * Add cluster clients (used internally only!)
   * @deprecated PairedDevice does not support adding additional clusters
   */
  addClusterClient(cluster) {
    if (this.declineAddingMoreClusters) {
      throw new import_general.ImplementationError("PairedDevice does not support adding additional clusters");
    }
    return super.addClusterClient(cluster);
  }
}
class RootEndpoint extends import_Endpoint.Endpoint {
  /**
   * Create a new RootEndpoint instance. This is automatically instanced by the CommissioningServer class.
   */
  constructor() {
    super([import_DeviceTypes.DeviceTypes.ROOT], { endpointId: (0, import_types.EndpointNumber)(0) });
  }
  /**
   * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterServer to get or undefined if not existing
   */
  getRootClusterServer(cluster) {
    return this.getClusterServer(cluster);
  }
  /**
   * Add a cluster client to the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterClient object to add
   */
  addRootClusterClient(cluster) {
    this.addClusterClient(cluster);
  }
  /**
   * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterClient to get or undefined if not existing
   */
  getRootClusterClient(cluster) {
    return this.getClusterClient(cluster);
  }
}
class Device extends import_Endpoint.Endpoint {
  commandHandler = new import_general.NamedHandler();
  /**
   * Create a new Device instance.
   *
   * @param definition DeviceTypeDefinitions of the device
   * @param options Optional endpoint options
   */
  constructor(definition, options = {}) {
    if (definition.deviceClass === import_DeviceTypes.DeviceClasses.Node) {
      throw new import_general.NotImplementedError("MatterNode devices are not supported");
    }
    super([definition], options);
    if (definition.deviceClass === import_DeviceTypes.DeviceClasses.Simple || definition.deviceClass === import_DeviceTypes.DeviceClasses.Client) {
      this.addClusterServer(
        (0, import_ClusterServer.ClusterServer)(
          import_clusters.Binding.Cluster,
          {
            binding: []
          },
          {}
        )
      );
    }
  }
  /**
   * Method to add command handlers to the device.
   * The base class do not expose any commands!
   *
   * @param command Command name to add a handler for
   * @param handler Handler function to be executed when the command is received
   */
  addCommandHandler(command, handler) {
    this.commandHandler.addHandler(command, handler);
  }
  /**
   * Method to remove command handlers from the device.
   * The base class do not expose any commands!
   *
   * @param command Command name to remove the handler from
   * @param handler Handler function to be removed
   */
  removeCommandHandler(command, handler) {
    this.commandHandler.removeHandler(command, handler);
  }
  /**
   * Execute a command handler. Should only be used internally, but cannot be declared as protected officially
   * because needed public for derived classes.
   *
   * @protected
   * @param command Command name to execute the handler for
   * @param args Arguments to be passed to the handler
   */
  async _executeHandler(command, ...args) {
    return await this.commandHandler.executeHandler(command, ...args);
  }
  createOptionalClusterServer(_cluster) {
    throw new import_general.ImplementationError("createOptionalClusterServer needs to be implemented by derived classes");
  }
  createOptionalClusterClient(_cluster) {
    throw new import_general.ImplementationError("createOptionalClusterClient needs to be implemented by derived classes");
  }
  getClusterServer(cluster) {
    const clusterServer = super.getClusterServer(cluster);
    if (clusterServer !== void 0) {
      return clusterServer;
    }
    for (const deviceType of this.deviceTypes) {
      if (deviceType.optionalServerClusters.includes(cluster.id)) {
        const clusterServer2 = this.createOptionalClusterServer(cluster);
        this.addClusterServer(clusterServer2);
        return clusterServer2;
      }
    }
  }
  getClusterClient(cluster) {
    const clusterClient = super.getClusterClient(cluster);
    if (clusterClient !== void 0) {
      return clusterClient;
    }
    for (const deviceType of this.deviceTypes) {
      if (deviceType.optionalClientClusters.includes(cluster.id)) {
        const clusterClient2 = this.createOptionalClusterClient(cluster);
        this.addClusterClient(clusterClient2);
      }
    }
  }
  /**
   * Set the reachability of the device exposed via the bridge. If this is a device inside  a composed device the
   * reachability needs to be set there.
   *
   * @param reachable true if reachable, false otherwise
   */
  setBridgedDeviceReachability(reachable) {
    const bridgedBasicInformationCluster = this.getClusterServer(import_clusters.BridgedDeviceBasicInformationCluster);
    if (bridgedBasicInformationCluster === void 0) {
      throw new import_general.ImplementationError(
        "The reachability flag can only be set for bridged devices this way. To set the reachability flag for a non-bridged device or for the bridget itself please set it on the CommissioningServer!"
      );
    }
    bridgedBasicInformationCluster.setReachableAttribute(reachable);
  }
}
//# sourceMappingURL=Device.js.map
