"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var DeviceInformation_exports = {};
__export(DeviceInformation_exports, {
  DEVICE_DATA_REVISION: () => DEVICE_DATA_REVISION,
  DeviceInformation: () => DeviceInformation
});
module.exports = __toCommonJS(DeviceInformation_exports);
var import_clusters = require("#clusters");
var import_general = require("@matter/general");
var import_protocol = require("@matter/protocol");
var import_types = require("@matter/types");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("DeviceInformation");
const DEVICE_DATA_REVISION = 1;
const DEFAULT_SUBSCRIPTION_FLOOR_DEFAULT_S = 1;
const DEFAULT_SUBSCRIPTION_FLOOR_ICD_S = 0;
const DEFAULT_SUBSCRIPTION_CEILING_WIFI_S = 60;
const DEFAULT_SUBSCRIPTION_CEILING_THREAD_S = 60;
const DEFAULT_SUBSCRIPTION_CEILING_THREAD_SLEEPY_S = 180;
const DEFAULT_SUBSCRIPTION_CEILING_BATTERY_POWERED_S = 600;
const GlobalAttributeKeys = Object.keys((0, import_types.GlobalAttributes)({}));
class DeviceInformation {
  constructor(nodeId, data) {
    this.nodeId = nodeId;
    this.#basicInformation = data.basicInformation;
    this.#deviceMeta = data.deviceMeta;
  }
  #basicInformation;
  #deviceMeta;
  get meta() {
    return this.#deviceMeta;
  }
  get basicInformation() {
    return this.#basicInformation;
  }
  get valid() {
    return this.#basicInformation !== void 0 && this.#deviceMeta !== void 0 && this.#deviceMeta?.dataRevision === DEVICE_DATA_REVISION;
  }
  async enhanceDeviceDetailsFromCache(rootEndpoint) {
    const basicInformationData = {};
    const deviceData = {
      ethernetConnected: false,
      wifiConnected: false,
      threadConnected: false,
      rootEndpointServerList: [],
      isBatteryPowered: false,
      isIntermittentlyConnected: false,
      isThreadSleepyEndDevice: false,
      dataRevision: DEVICE_DATA_REVISION
    };
    const basicInformationClient = rootEndpoint.getClusterClient(import_clusters.BasicInformation.Cluster);
    if (basicInformationClient !== void 0) {
      for (const attributeName of Object.keys(basicInformationClient.attributes)) {
        if (GlobalAttributeKeys.includes(attributeName)) {
          continue;
        }
        const attribute = basicInformationClient.attributes[attributeName];
        if (attribute instanceof import_protocol.SupportedAttributeClient) {
          try {
            basicInformationData[attributeName] = await attribute.get();
          } catch (error) {
            logger.info(`Error while getting attribute ${attributeName} for node ${this.nodeId}: ${error}`);
          }
        }
      }
    } else {
      logger.info(`No basic information cluster found for node ${this.nodeId}`);
    }
    const descriptorClient = rootEndpoint.getClusterClient(import_clusters.Descriptor.Cluster);
    if (descriptorClient !== void 0) {
      const serverList = await descriptorClient.getServerListAttribute();
      deviceData.rootEndpointServerList = serverList;
      if (serverList.includes(import_clusters.IcdManagement.Cluster.id)) {
        deviceData.isIntermittentlyConnected = true;
      }
    } else {
      logger.info(`No descriptor cluster found for node ${this.nodeId}`);
    }
    const threadNetworkDiagnosticClient = rootEndpoint.getClusterClient(import_clusters.ThreadNetworkDiagnostics.Cluster);
    if (threadNetworkDiagnosticClient !== void 0) {
      const routingRole = await threadNetworkDiagnosticClient.getRoutingRoleAttribute();
      if (routingRole === import_clusters.ThreadNetworkDiagnostics.RoutingRole.SleepyEndDevice) {
        deviceData.isThreadSleepyEndDevice = true;
      }
    }
    await this.#collectEndpointStates(rootEndpoint, deviceData);
    this.#basicInformation = basicInformationData;
    this.#deviceMeta = deviceData;
  }
  async #collectEndpointStates(endpoint, deviceData) {
    const networkCluster = endpoint.getClusterClient(import_clusters.NetworkCommissioning.Complete);
    if (networkCluster !== void 0) {
      if (await networkCluster.getInterfaceEnabledAttribute()) {
        const networks = await networkCluster.getNetworksAttribute();
        if (networks) {
          if (networks.some((network) => network.connected)) {
            const features = await networkCluster.getFeatureMapAttribute();
            if (features) {
              if (features.ethernetNetworkInterface) {
                deviceData.ethernetConnected = true;
              } else if (features.wiFiNetworkInterface) {
                deviceData.wifiConnected = true;
              } else if (features.threadNetworkInterface) {
                deviceData.threadConnected = true;
              }
            }
          }
        }
      }
    }
    const powerSourceCluster = endpoint.getClusterClient(import_clusters.PowerSource.Cluster);
    if (powerSourceCluster !== void 0) {
      if (await powerSourceCluster.getStatusAttribute() === import_clusters.PowerSource.PowerSourceStatus.Active) {
        const features = await powerSourceCluster.getFeatureMapAttribute();
        if (features?.battery) {
          deviceData.isBatteryPowered = true;
        }
      }
    }
    for (const childEndpoint of endpoint.getChildEndpoints()) {
      await this.#collectEndpointStates(childEndpoint, deviceData);
    }
  }
  async enhanceDeviceDetailsFromRemote(interactionClient) {
    const readData = await interactionClient.getMultipleAttributes({
      attributes: [
        { endpointId: (0, import_types.EndpointNumber)(0), clusterId: import_clusters.BasicInformation.Cluster.id },
        {
          endpointId: (0, import_types.EndpointNumber)(0),
          clusterId: import_clusters.Descriptor.Cluster.id,
          attributeId: import_clusters.Descriptor.Cluster.attributes.serverList.id
        },
        {
          clusterId: import_clusters.NetworkCommissioning.Cluster.id,
          attributeId: import_clusters.NetworkCommissioning.Complete.attributes.featureMap.id
        },
        {
          clusterId: import_clusters.NetworkCommissioning.Cluster.id,
          attributeId: import_clusters.NetworkCommissioning.Complete.attributes.networks.id
        },
        {
          clusterId: import_clusters.NetworkCommissioning.Cluster.id,
          attributeId: import_clusters.NetworkCommissioning.Complete.attributes.interfaceEnabled.id
        },
        {
          clusterId: import_clusters.PowerSource.Cluster.id,
          attributeId: import_clusters.PowerSource.Cluster.attributes.featureMap.id
        },
        {
          clusterId: import_clusters.PowerSource.Cluster.id,
          attributeId: import_clusters.PowerSource.Cluster.attributes.status.id
        },
        {
          endpointId: (0, import_types.EndpointNumber)(0),
          clusterId: import_clusters.ThreadNetworkDiagnostics.Cluster.id,
          attributeId: import_clusters.ThreadNetworkDiagnostics.Cluster.attributes.routingRole.id
        }
      ]
    });
    const basicInformationData = {};
    const deviceData = {
      ethernetConnected: false,
      wifiConnected: false,
      threadConnected: false,
      rootEndpointServerList: [],
      isBatteryPowered: false,
      isIntermittentlyConnected: false,
      isThreadSleepyEndDevice: false,
      dataRevision: DEVICE_DATA_REVISION
    };
    const networkData = /* @__PURE__ */ new Map();
    const powerSourceData = /* @__PURE__ */ new Map();
    for (const {
      path: { endpointId, clusterId, attributeId, attributeName },
      value
    } of readData) {
      switch (clusterId) {
        case import_clusters.BasicInformation.Cluster.id:
          if (!GlobalAttributeKeys.includes(attributeName)) {
            basicInformationData[attributeName] = value;
          }
          break;
        case import_clusters.Descriptor.Cluster.id:
          if (attributeId === import_clusters.Descriptor.Cluster.attributes.serverList.id) {
            deviceData.rootEndpointServerList = value;
            if (value.includes(import_clusters.IcdManagement.Cluster.id)) {
              deviceData.isIntermittentlyConnected = true;
            }
          }
          break;
        case import_clusters.NetworkCommissioning.Cluster.id:
          const networkEntry = networkData.get(endpointId) ?? {};
          if (attributeId === import_clusters.NetworkCommissioning.Complete.attributes.featureMap.id) {
            networkEntry.type = value;
          } else if (attributeId === import_clusters.NetworkCommissioning.Complete.attributes.interfaceEnabled.id) {
            networkEntry.enabled = value;
          } else if (attributeId === import_clusters.NetworkCommissioning.Complete.attributes.networks.id) {
            networkEntry.connected = value.some((network) => network.connected);
          }
          networkData.set(endpointId, networkEntry);
          break;
        case import_clusters.PowerSource.Cluster.id:
          const powerSourceEntry = powerSourceData.get(endpointId) ?? {};
          if (attributeId === import_clusters.PowerSource.Cluster.attributes.featureMap.id) {
            powerSourceEntry.features = value;
          } else if (attributeId === import_clusters.PowerSource.Cluster.attributes.status.id) {
            powerSourceEntry.status = value;
          }
          powerSourceData.set(endpointId, powerSourceEntry);
          break;
        case import_clusters.ThreadNetworkDiagnostics.Cluster.id:
          if (attributeId === import_clusters.ThreadNetworkDiagnostics.Cluster.attributes.routingRole.id) {
            if (value === import_clusters.ThreadNetworkDiagnostics.RoutingRole.SleepyEndDevice) {
              deviceData.isThreadSleepyEndDevice = true;
            }
          }
          break;
      }
    }
    if (networkData.size === 0) {
      deviceData.ethernetConnected = true;
    } else {
      for (const { type, enabled, connected } of networkData.values()) {
        if (!type || !enabled || !connected) continue;
        if (type.ethernetNetworkInterface) {
          deviceData.ethernetConnected = true;
        } else if (type.wiFiNetworkInterface) {
          deviceData.wifiConnected = true;
        } else if (type.threadNetworkInterface) {
          deviceData.threadConnected = true;
        }
      }
    }
    for (const { features, status } of powerSourceData.values()) {
      if (features?.battery && status === import_clusters.PowerSource.PowerSourceStatus.Active) {
        deviceData.isBatteryPowered = true;
      }
    }
    this.#basicInformation = basicInformationData;
    this.#deviceMeta = deviceData;
  }
  determineSubscriptionParameters(options) {
    let {
      subscribeMinIntervalFloorSeconds: minIntervalFloorSeconds,
      subscribeMaxIntervalCeilingSeconds: maxIntervalCeilingSeconds
    } = options;
    const { isBatteryPowered, isIntermittentlyConnected, threadConnected, isThreadSleepyEndDevice } = this.#deviceMeta ?? {};
    if (isIntermittentlyConnected) {
      if (minIntervalFloorSeconds !== void 0 && minIntervalFloorSeconds !== DEFAULT_SUBSCRIPTION_FLOOR_ICD_S) {
        logger.info(
          `Node ${this.nodeId}: Overwriting minIntervalFloorSeconds for intermittently connected device to 0`
        );
        minIntervalFloorSeconds = DEFAULT_SUBSCRIPTION_FLOOR_ICD_S;
      }
    }
    const defaultCeiling = isBatteryPowered ? DEFAULT_SUBSCRIPTION_CEILING_BATTERY_POWERED_S : isThreadSleepyEndDevice ? DEFAULT_SUBSCRIPTION_CEILING_THREAD_SLEEPY_S : threadConnected ? DEFAULT_SUBSCRIPTION_CEILING_THREAD_S : DEFAULT_SUBSCRIPTION_CEILING_WIFI_S;
    if (maxIntervalCeilingSeconds === void 0) {
      maxIntervalCeilingSeconds = defaultCeiling;
    }
    if (maxIntervalCeilingSeconds < defaultCeiling) {
      logger.debug(
        `Node ${this.nodeId}: maxIntervalCeilingSeconds should idealy be set to ${defaultCeiling}s instead of ${maxIntervalCeilingSeconds}s because of device type`
      );
    }
    return {
      minIntervalFloorSeconds: minIntervalFloorSeconds ?? DEFAULT_SUBSCRIPTION_FLOOR_DEFAULT_S,
      maxIntervalCeilingSeconds
    };
  }
  toStorageData() {
    return {
      basicInformation: this.#basicInformation,
      deviceMeta: this.#deviceMeta
    };
  }
}
//# sourceMappingURL=DeviceInformation.js.map
