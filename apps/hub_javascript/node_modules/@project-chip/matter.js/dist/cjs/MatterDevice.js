"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var MatterDevice_exports = {};
__export(MatterDevice_exports, {
  MatterDevice: () => MatterDevice
});
module.exports = __toCommonJS(MatterDevice_exports);
var import_general = require("#general");
var import_protocol = require("#protocol");
/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class MatterDevice {
  constructor(sessionStorage, fabricStorage, getCommissioningConfig, minimumCaseSessionsPerFabricAndNode, commissioningChangedCallback, sessionChangedCallback, sessionParameters = {}) {
    this.sessionStorage = sessionStorage;
    this.fabricStorage = fabricStorage;
    this.commissioningChangedCallback = commissioningChangedCallback;
    this.sessionChangedCallback = sessionChangedCallback;
    this.#channelManager = new import_protocol.ChannelManager(minimumCaseSessionsPerFabricAndNode);
    this.#fabricManager = new import_protocol.FabricManager(fabricStorage);
    this.#observers.on(
      this.#fabricManager.events.deleted,
      async ({ fabricIndex }) => this.commissioningChangedCallback(fabricIndex, import_protocol.FabricAction.Removed)
    );
    this.#observers.on(
      this.#fabricManager.events.updated,
      ({ fabricIndex }) => this.commissioningChangedCallback(fabricIndex, import_protocol.FabricAction.Updated)
    );
    this.#sessionManager = new import_protocol.SessionManager({
      fabrics: this.#fabricManager,
      storage: sessionStorage,
      parameters: sessionParameters,
      owner: this
    });
    this.#transportInterfaces = new import_general.TransportInterfaceSet();
    this.#exchangeManager = new import_protocol.ExchangeManager({
      transportInterfaces: this.#transportInterfaces,
      sessionManager: this.#sessionManager,
      channelManager: this.#channelManager
    });
    const secureChannelProtocol = new import_protocol.SecureChannelProtocol(this.#sessionManager, this.#fabricManager);
    this.#exchangeManager.addProtocolHandler(secureChannelProtocol);
    this.#observers.on(this.#sessionManager.sessions.added, (session) => {
      if (session.fabric) {
        this.sessionChangedCallback(session.fabric.fabricIndex);
      }
    });
    this.#observers.on(this.#sessionManager.sessions.deleted, async (session) => {
      const currentFabricIndex = session.fabric?.fabricIndex;
      if (currentFabricIndex !== void 0) {
        this.sessionChangedCallback(currentFabricIndex);
      }
    });
    this.#observers.on(this.#sessionManager.subscriptionsChanged, (session, _subscription) => {
      const currentFabric = session.fabric;
      if (currentFabric !== void 0) {
        this.sessionChangedCallback(currentFabric.fabricIndex);
      }
    });
    this.#advertiser = new import_protocol.DeviceAdvertiser({
      fabrics: this.fabricManager,
      sessions: this.sessionManager
    });
    this.#commissioner = new import_protocol.DeviceCommissioner({
      fabrics: this.fabricManager,
      sessions: this.sessionManager,
      advertiser: this.#advertiser,
      secureChannelProtocol,
      commissioningConfig: new class extends import_protocol.CommissioningConfigProvider {
        get values() {
          return getCommissioningConfig();
        }
      }()
    });
    this.#construction = (0, import_general.Construction)(this, async () => {
      await this.#fabricManager.construction.ready;
      this.#observers.on(
        this.#fabricManager.events.added,
        ({ fabricIndex }) => this.commissioningChangedCallback(fabricIndex, import_protocol.FabricAction.Added)
      );
      await this.#sessionManager.construction.ready;
    });
  }
  #exchangeManager;
  #fabricManager;
  #sessionManager;
  #commissioner;
  #advertiser;
  #transportInterfaces;
  #channelManager;
  #observers = new import_general.ObserverGroup();
  #isClosing = false;
  #construction;
  get construction() {
    return this.#construction;
  }
  static async create(sessionStorage, fabricStorage, getCommissioningConfig, minimumCaseSessionsPerFabricAndNode = 3, commissioningChangedCallback, sessionChangedCallback, sessionParameters) {
    return (0, import_general.asyncNew)(
      MatterDevice,
      sessionStorage,
      fabricStorage,
      getCommissioningConfig,
      minimumCaseSessionsPerFabricAndNode,
      commissioningChangedCallback,
      sessionChangedCallback,
      sessionParameters
    );
  }
  get fabricManager() {
    return this.#fabricManager;
  }
  get sessionManager() {
    return this.#sessionManager;
  }
  get exchangeManager() {
    return this.#exchangeManager;
  }
  get advertiser() {
    return this.#advertiser;
  }
  get commissioner() {
    return this.#commissioner;
  }
  get failsafeContext() {
    return this.#commissioner.failsafeContext;
  }
  get isClosing() {
    return this.#isClosing;
  }
  async beginTimed(failsafeContext) {
    return this.#commissioner.beginTimed(failsafeContext);
  }
  assertFailSafeArmed(message) {
    return this.#commissioner.assertFailsafeArmed(message);
  }
  isFailsafeArmed() {
    return this.#commissioner.isFailsafeArmed;
  }
  hasBroadcaster(broadcaster) {
    return this.#advertiser.hasBroadcaster(broadcaster);
  }
  addBroadcaster(broadcaster) {
    this.#advertiser.addBroadcaster(broadcaster);
    return this;
  }
  async deleteBroadcaster(broadcaster) {
    return this.#advertiser.deleteBroadcaster(broadcaster);
  }
  addTransportInterface(transport) {
    this.#transportInterfaces.add(transport);
    return this;
  }
  async deleteTransportInterface(transport) {
    this.#transportInterfaces.delete(transport);
  }
  hasProtocolHandler(protocolId) {
    return this.exchangeManager.hasProtocolHandler(protocolId);
  }
  addProtocolHandler(protocol) {
    this.exchangeManager.addProtocolHandler(protocol);
    return this;
  }
  async start() {
    await this.startAnnouncement();
  }
  async startAnnouncement() {
    return this.#advertiser.startAdvertising();
  }
  async announce(announceOnce = false) {
    return this.#advertiser.advertise(announceOnce);
  }
  reAnnounceAsCommissionable() {
    this.#commissioner.reactivateAdvertiser();
  }
  findFabricFromDestinationId(destinationId, peerRandom) {
    return this.#fabricManager.findFabricFromDestinationId(destinationId, peerRandom);
  }
  async sendFabricAnnouncements(fabrics, expireCommissioningAnnouncement = false) {
    return this.#advertiser.advertiseFabrics(fabrics, expireCommissioningAnnouncement);
  }
  getFabricByIndex(fabricIndex) {
    return this.#fabricManager.findByIndex(fabricIndex);
  }
  initiateExchange(address, protocolId) {
    return this.#exchangeManager.initiateExchange(address, protocolId);
  }
  getFabrics() {
    return this.#fabricManager.fabrics;
  }
  isCommissioned() {
    return !!this.#fabricManager.length;
  }
  async allowEnhancedCommissioning(discriminator, paseServer, commissioningEndCallback) {
    return this.#commissioner.allowEnhancedCommissioning(discriminator, paseServer, commissioningEndCallback);
  }
  async allowBasicCommissioning(commissioningEndCallback) {
    return this.#commissioner.allowBasicCommissioning(commissioningEndCallback);
  }
  async endCommissioning() {
    return this.#commissioner.endCommissioning();
  }
  existsOpenPaseSession() {
    return !!this.#sessionManager.getPaseSession();
  }
  async close() {
    this.#isClosing = true;
    this.#observers.close();
    await this.#commissioner.close();
    await this.#advertiser.close();
    await this.exchangeManager.close();
    await this.#sessionManager.close();
    await this.#channelManager.close();
    await this.#transportInterfaces.close();
  }
  getActiveSessionInformation() {
    return this.#sessionManager.getActiveSessionInformation();
  }
  static of(session) {
    if (session === void 0) {
      throw new import_general.InternalError("Device operation without session");
    }
    const device = session.owner;
    if (!(device instanceof MatterDevice)) {
      throw new import_general.InternalError("Device operation on non-device session");
    }
    return device;
  }
}
//# sourceMappingURL=MatterDevice.js.map
