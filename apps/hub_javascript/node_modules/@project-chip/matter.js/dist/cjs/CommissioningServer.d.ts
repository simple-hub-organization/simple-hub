/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { BasicInformationCluster, GeneralCommissioningCluster, GeneralDiagnosticsCluster } from "#clusters";
import { StorageContext, SyncStorage } from "#general";
import { ClusterClientObj, DeviceCertification, MdnsBroadcaster, MdnsScanner } from "#protocol";
import { ClusterType, CommissioningFlowType, DiscoveryCapabilitiesBitmap, EndpointNumber, FabricIndex, TypeFromBitSchema, TypeFromPartialBitSchema } from "#types";
import { AttributeInitialValues, ClusterServerHandlers, ClusterServerObj } from "./cluster/server/ClusterServerTypes.js";
import { Aggregator } from "./device/Aggregator.js";
import { Device, RootEndpoint } from "./device/Device.js";
import { Endpoint } from "./device/Endpoint.js";
import { MatterNode } from "./MatterNode.js";
export declare const FORBIDDEN_PASSCODES: number[];
/**
 * Represents device pairing information.
 */
export interface DevicePairingInformation {
    manualPairingCode: string;
    qrPairingCode: string;
}
/**
 * Constructor options for a CommissioningServer device
 * Beside the general options it also contains the data for the BasicInformation cluster which is added automatically
 * and allows to override the certificates used for the OperationalCredentials cluster
 */
export interface CommissioningServerOptions {
    /** Port of the server, normally automatically managed. */
    port?: number;
    /** IPv4 listener address, defaults to all interfaces.*/
    listeningAddressIpv4?: string;
    /** IPv6 listener address, defaults to all interfaces.*/
    listeningAddressIpv6?: string;
    /** The device name to be used for the BasicInformation cluster. */
    deviceName: string;
    /** The device type to be used for the BasicInformation cluster. */
    deviceType: number;
    /** The next endpoint ID to be assigned to a new endpoint. */
    nextEndpointId?: number;
    /** The passcode/pin of the device to use for initial commissioning. */
    passcode?: number;
    /** The Discriminator to use for initial commissioning. */
    discriminator?: number;
    /** The Flow type of the Commissioning flow used in announcements. */
    flowType?: CommissioningFlowType;
    /** Optional Vendor specific additional BLE Advertisement data. */
    additionalBleAdvertisementData?: Uint8Array;
    /** Should the device directly be announced automatically by the MatterServer of manually via announce(). */
    delayedAnnouncement?: boolean;
    /**
     * Optional maximum subscription interval to use for sending subscription reports. It will be used if not too low
     * and inside the range requested by the connected controller.
     */
    subscriptionMaxIntervalSeconds?: number;
    /**
     * Optional minimum subscription interval to use for sending subscription reports. It will be used when other
     * calculated values are smaller than it. Use this to make sure your device hardware can handle the load and to set
     * limits.
     */
    subscriptionMinIntervalSeconds?: number;
    /**
     * Optional subscription randomization window to use for sending subscription reports. This specifies a window in
     * seconds from which a random part is added to the calculated maximum interval to make sure that devices that get
     * powered on in parallel not all send at the same timepoint.
     */
    subscriptionRandomizationWindowSeconds?: number;
    /**
     * Device details to be used for the BasicInformation cluster. Some of the values are initialized with defaults if
     * not set here.
     */
    basicInformation: {
        vendorId: number;
        vendorName: string;
        productId: number;
        productName: string;
    } | AttributeInitialValues<typeof BasicInformationCluster.attributes>;
    /**
     * Vendor specific certificates to be used for the OperationalCredentials cluster. If not set Test certificates
     * (official Chip tool test Root certificate is used) are generated automatically.
     */
    certificates?: DeviceCertification.Definition;
    /**
     * Optional configuration for the GeneralCommissioning cluster. If not set the default values are used.
     * Use these options to limit the allowed countries for regulatory configuration.
     */
    generalCommissioning?: Partial<AttributeInitialValues<typeof GeneralCommissioningCluster.attributes>> & {
        allowCountryCodeChange?: boolean;
        countryCodeWhitelist?: string[];
    };
    /**
     * This callback is called when the device is commissioned or decommissioned to a fabric/controller. The provided
     * fabricIndex can be used together with getCommissionedFabricInformation() to get more details about the fabric
     * (or if this fabricIndex is missing it was deleted).
     */
    commissioningChangedCallback?: (fabricIndex: FabricIndex) => void;
    /**
     * This callback is called when sessions to the device are established, closed or subscriptions get added or
     * removed. The provided fabricIndex can be used together with getActiveSessionInformation() to get more details
     * about the open sessions and their status.
     */
    activeSessionsChangedCallback?: (fabricIndex: FabricIndex) => void;
}
/**
 * Commands exposed by the CommissioningServer
 */
export type CommissioningServerCommands = {
    /** Provide a means for certification tests to trigger some test-plan-specific events. */
    testEventTrigger: ClusterServerHandlers<typeof GeneralDiagnosticsCluster>["testEventTrigger"];
};
/**
 * A CommissioningServer node represent a matter node that can be paired with a controller and runs on a defined port on the
 * host
 */
export declare class CommissioningServer extends MatterNode {
    private readonly options;
    private ipv4Disabled?;
    private port?;
    private readonly passcode;
    private readonly discriminator;
    private readonly flowType;
    private readonly productDescription;
    private storage?;
    private endpointStructureStorage?;
    private mdnsScanner?;
    private mdnsBroadcaster?;
    private mdnsInstanceBroadcaster?;
    private deviceInstance?;
    private eventHandler?;
    private endpointStructure;
    private interactionServer?;
    protected readonly rootEndpoint: RootEndpoint;
    private nextEndpointId;
    readonly delayedAnnouncement?: boolean;
    private readonly commandHandler;
    /**
     * Creates a new CommissioningServer node and add all needed Root clusters
     *
     * @param options The options for the CommissioningServer node
     */
    constructor(options: CommissioningServerOptions);
    /**
     * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param cluster ClusterServer to get or undefined if not existing
     */
    getRootClusterServer<const T extends ClusterType>(cluster: T): ClusterServerObj<T> | undefined;
    /**
     * Add a cluster client to the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param cluster ClusterClient object to add
     */
    addRootClusterClient<const T extends ClusterType>(cluster: ClusterClientObj<T>): void;
    /**
     * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param cluster ClusterClient to get or undefined if not existing
     */
    getRootClusterClient<const T extends ClusterType>(cluster: T): ClusterClientObj<T> | undefined;
    /**
     * Get the root endpoint of the node.
     */
    getRootEndpoint(): RootEndpoint;
    /**
     * Add a child endpoint to the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param endpoint Endpoint to add
     * @protected
     */
    protected addEndpoint(endpoint: Endpoint): void;
    /**
     * Get a child endpoint from the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param endpointId Endpoint ID of the child endpoint to get
     * @protected
     */
    protected getChildEndpoint(endpointId: EndpointNumber): Endpoint | undefined;
    /**
     * Add a new cluster server to the root endpoint
     * BasicInformationCluster and OperationalCredentialsCluster cannot be added via this method because they are
     * added in the constructor
     *
     * @param cluster
     */
    addRootClusterServer<const T extends ClusterType>(cluster: ClusterServerObj<T>): void;
    /**
     * Advertise the node via all available interfaces (Ethernet/MDNS, BLE, ...) and start the commissioning process
     *
     * @param limitTo Limit the advertisement to the given discovery capabilities. Default is to advertise on ethernet
     *                and BLE if configured
     */
    advertise(limitTo?: TypeFromPartialBitSchema<typeof DiscoveryCapabilitiesBitmap>): Promise<void>;
    updateStructure(): void;
    getNextEndpointId(increase?: boolean): EndpointNumber;
    assignEndpointIds(): void;
    private initializeEndpointIdsFromStorage;
    private fillAndStoreEndpointIds;
    /**
     * Return info if the device is paired with at least one controller
     */
    isCommissioned(): boolean;
    /**
     * Return the pairing information for the device
     */
    getPairingCode(discoveryCapabilities?: TypeFromBitSchema<typeof DiscoveryCapabilitiesBitmap>): DevicePairingInformation;
    /**
     * Set the MDNS Scanner instance. Should be only used internally
     *
     * @param mdnsScanner MdnsScanner instance
     */
    setMdnsScanner(mdnsScanner: MdnsScanner): void;
    /**
     * Set the MDNS Broadcaster instance. Should be only used internally
     *
     * @param mdnsBroadcaster MdnsBroadcaster instance
     */
    setMdnsBroadcaster(mdnsBroadcaster: MdnsBroadcaster): void;
    /**
     * Set the StorageManager instance. Should be only used internally
     * @param storage
     */
    setStorage(storage: StorageContext<SyncStorage>): Promise<void>;
    /**
     * Add a new device to the node
     *
     * @param device Device or Aggregator instance to add
     */
    addDevice(device: Device | Aggregator): void;
    /**
     * Return the port the device is listening on
     */
    getPort(): number | undefined;
    /** Set the port the device is listening on. Can only be called before the device is initialized. */
    setPort(port: number): void;
    /**
     * Close network connections of the device and stop responding to requests
     */
    close(): Promise<void>;
    factoryReset(): Promise<void>;
    /**
     * Add a new command handler for the given command
     *
     * @param command Command to add the handler for
     * @param handler Handler function to add
     */
    addCommandHandler<K extends keyof CommissioningServerCommands>(command: K, handler: CommissioningServerCommands[K]): void;
    /**
     * Remove a command handler for the given command
     *
     * @param command Command to remove the handler for
     * @param handler Handler function to remove
     */
    removeCommandHandler<K extends keyof CommissioningServerCommands>(command: K, handler: CommissioningServerCommands[K]): void;
    /**
     * Set the reachability of the commissioning server aka "the main matter device". This call only has effect when
     * the reachability flag was set in the BasicInformationCluster or in the BasicInformation data in the constructor!
     *
     * @param reachable true if reachable, false otherwise
     */
    setReachability(reachable: boolean): void;
    /** used internally by MatterServer to initialize the state of the device. */
    initialize(ipv4Disabled: boolean): void;
    /** Starts the Matter device and advertises it. */
    start(): Promise<void>;
    /**
     * Get some basic details of all Fabrics the server is commissioned to.
     *
     * @param fabricIndex Optional fabric index to filter for. If not set all fabrics are returned.
     */
    getCommissionedFabricInformation(fabricIndex?: FabricIndex): import("#protocol").ExposedFabricInformation[];
    /**
     * Get some basic details of all currently active sessions.
     *
     * @param fabricIndex Optional fabric index to filter for. If not set all sessions are returned.
     */
    getActiveSessionInformation(fabricIndex?: FabricIndex): {
        name: string;
        nodeId: import("#types").NodeId;
        peerNodeId: import("#types").NodeId;
        fabric: import("#protocol").ExposedFabricInformation | undefined;
        isPeerActive: boolean;
        secure: boolean;
        lastInteractionTimestamp: number | undefined;
        lastActiveTimestamp: number | undefined;
        numberOfActiveSubscriptions: number;
    }[];
}
//# sourceMappingURL=CommissioningServer.d.ts.map