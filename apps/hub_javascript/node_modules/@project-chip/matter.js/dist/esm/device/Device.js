/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Binding, BridgedDeviceBasicInformationCluster } from "#clusters";
import { ImplementationError, NamedHandler, NotImplementedError } from "#general";
import { EndpointNumber } from "#types";
import { ClusterServer } from "../cluster/server/ClusterServer.js";
import { isClusterServer } from "../cluster/server/ClusterServerTypes.js";
import { DeviceClasses, DeviceTypes } from "./DeviceTypes.js";
import { Endpoint } from "./Endpoint.js";
import { isClusterClient } from "./TypeHelpers.js";
const WrapCommandHandler = (handler, commandHandler) => {
  if (commandHandler === void 0) {
    return handler;
  }
  const mergedHandler = {};
  for (const key in handler) {
    if (key.endsWith("AttributeGetter") || key.endsWith("AttributeSetter") || key.endsWith("AttributeValidator") || key === "initializeClusterServer" || key === "destroyClusterServer") {
      mergedHandler[key] = handler[key];
      continue;
    }
    mergedHandler[key] = async (...args) => {
      if (commandHandler.hasHandler(key)) {
        return await commandHandler.executeHandler(key, ...args);
      }
      return await handler[key](...args);
    };
  }
  return mergedHandler;
};
class PairedDevice extends Endpoint {
  declineAddingMoreClusters;
  /**
   * Create a new PairedDevice instance. All data are automatically parsed from the paired device!
   *
   * @param definition DeviceTypeDefinitions of the paired device as reported by the device
   * @param clusters Clusters of the paired device as reported by the device
   * @param endpointId Endpoint ID of the paired device as reported by the device
   */
  constructor(definition, clusters = [], endpointId) {
    super(definition, { endpointId });
    clusters.forEach((cluster) => {
      if (isClusterServer(cluster)) {
        this.addClusterServer(cluster);
      } else if (isClusterClient(cluster)) {
        this.addClusterClient(cluster);
      }
    });
    this.declineAddingMoreClusters = true;
  }
  /**
   * Add cluster servers (used internally only!)
   * @deprecated PairedDevice does not support adding additional clusters
   */
  addClusterServer(cluster) {
    if (this.declineAddingMoreClusters) {
      throw new ImplementationError("PairedDevice does not support adding additional clusters");
    }
    return super.addClusterServer(cluster);
  }
  /**
   * Add cluster clients (used internally only!)
   * @deprecated PairedDevice does not support adding additional clusters
   */
  addClusterClient(cluster) {
    if (this.declineAddingMoreClusters) {
      throw new ImplementationError("PairedDevice does not support adding additional clusters");
    }
    return super.addClusterClient(cluster);
  }
}
class RootEndpoint extends Endpoint {
  /**
   * Create a new RootEndpoint instance. This is automatically instanced by the CommissioningServer class.
   */
  constructor() {
    super([DeviceTypes.ROOT], { endpointId: EndpointNumber(0) });
  }
  /**
   * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterServer to get or undefined if not existing
   */
  getRootClusterServer(cluster) {
    return this.getClusterServer(cluster);
  }
  /**
   * Add a cluster client to the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterClient object to add
   */
  addRootClusterClient(cluster) {
    this.addClusterClient(cluster);
  }
  /**
   * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterClient to get or undefined if not existing
   */
  getRootClusterClient(cluster) {
    return this.getClusterClient(cluster);
  }
}
class Device extends Endpoint {
  commandHandler = new NamedHandler();
  /**
   * Create a new Device instance.
   *
   * @param definition DeviceTypeDefinitions of the device
   * @param options Optional endpoint options
   */
  constructor(definition, options = {}) {
    if (definition.deviceClass === DeviceClasses.Node) {
      throw new NotImplementedError("MatterNode devices are not supported");
    }
    super([definition], options);
    if (definition.deviceClass === DeviceClasses.Simple || definition.deviceClass === DeviceClasses.Client) {
      this.addClusterServer(
        ClusterServer(
          Binding.Cluster,
          {
            binding: []
          },
          {}
        )
      );
    }
  }
  /**
   * Method to add command handlers to the device.
   * The base class do not expose any commands!
   *
   * @param command Command name to add a handler for
   * @param handler Handler function to be executed when the command is received
   */
  addCommandHandler(command, handler) {
    this.commandHandler.addHandler(command, handler);
  }
  /**
   * Method to remove command handlers from the device.
   * The base class do not expose any commands!
   *
   * @param command Command name to remove the handler from
   * @param handler Handler function to be removed
   */
  removeCommandHandler(command, handler) {
    this.commandHandler.removeHandler(command, handler);
  }
  /**
   * Execute a command handler. Should only be used internally, but cannot be declared as protected officially
   * because needed public for derived classes.
   *
   * @protected
   * @param command Command name to execute the handler for
   * @param args Arguments to be passed to the handler
   */
  async _executeHandler(command, ...args) {
    return await this.commandHandler.executeHandler(command, ...args);
  }
  createOptionalClusterServer(_cluster) {
    throw new ImplementationError("createOptionalClusterServer needs to be implemented by derived classes");
  }
  createOptionalClusterClient(_cluster) {
    throw new ImplementationError("createOptionalClusterClient needs to be implemented by derived classes");
  }
  getClusterServer(cluster) {
    const clusterServer = super.getClusterServer(cluster);
    if (clusterServer !== void 0) {
      return clusterServer;
    }
    for (const deviceType of this.deviceTypes) {
      if (deviceType.optionalServerClusters.includes(cluster.id)) {
        const clusterServer2 = this.createOptionalClusterServer(cluster);
        this.addClusterServer(clusterServer2);
        return clusterServer2;
      }
    }
  }
  getClusterClient(cluster) {
    const clusterClient = super.getClusterClient(cluster);
    if (clusterClient !== void 0) {
      return clusterClient;
    }
    for (const deviceType of this.deviceTypes) {
      if (deviceType.optionalClientClusters.includes(cluster.id)) {
        const clusterClient2 = this.createOptionalClusterClient(cluster);
        this.addClusterClient(clusterClient2);
      }
    }
  }
  /**
   * Set the reachability of the device exposed via the bridge. If this is a device inside  a composed device the
   * reachability needs to be set there.
   *
   * @param reachable true if reachable, false otherwise
   */
  setBridgedDeviceReachability(reachable) {
    const bridgedBasicInformationCluster = this.getClusterServer(BridgedDeviceBasicInformationCluster);
    if (bridgedBasicInformationCluster === void 0) {
      throw new ImplementationError(
        "The reachability flag can only be set for bridged devices this way. To set the reachability flag for a non-bridged device or for the bridget itself please set it on the CommissioningServer!"
      );
    }
    bridgedBasicInformationCluster.setReachableAttribute(reachable);
  }
}
export {
  Device,
  PairedDevice,
  RootEndpoint,
  WrapCommandHandler
};
//# sourceMappingURL=Device.js.map
