/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AsyncObservable, Construction, MatterError, Observable } from "#general";
import { ClusterClientObj, DecodedAttributeReportValue, DecodedEventReportValue, EndpointInterface, EndpointLoggingOptions, InteractionClient, NodeDiscoveryType } from "#protocol";
import { ClusterType, EndpointNumber, NodeId } from "#types";
import { ClusterServerObj } from "../cluster/server/ClusterServerTypes.js";
import { CommissioningController } from "../CommissioningController.js";
import { DeviceInformationData } from "./DeviceInformation.js";
import { Endpoint } from "./Endpoint.js";
export declare enum NodeStates {
    /**
     * Node seems active nd last communications were successful and subscription updates were received and all data is
     * up-to-date.
     */
    Connected = 0,
    /**
     * Node is disconnected. This means that the node was not connected so far or the developer disconnected it by API
     * call or the node is removed. A real disconnection can not be detected because the main Matter protocol uses UDP.
     * Data are stale and interactions will most likely return an error.
     */
    Disconnected = 1,
    /**
     * Node is reconnecting. This means that former communications failed, and we are trying to reach the device on
     * known addresses. Data are stale. It is yet unknown if the reconnection is successful. */
    Reconnecting = 2,
    /**
     * The node seems offline because communication was not possible or is just initialized. The controller is now
     * waiting for a MDNS announcement and tries every 10 minutes to reconnect.
     */
    WaitingForDeviceDiscovery = 3
}
/** @deprecated */
export declare enum NodeStateInformation {
    /**
     * Node seems active nd last communications were successful and subscription updates were received and all data is
     * up-to-date.
     */
    Connected = 0,
    /**
     * Node is disconnected. This means that the node was not connected so far or the developer disconnected it by API
     * call or the node is removed. A real disconnection can not be detected because the main Matter protocol uses UDP.
     * Data are stale and interactions will most likely return an error.
     */
    Disconnected = 1,
    /**
     * Node is reconnecting. This means that former communications failed, and we are trying to reach the device on
     * known addresses. Data are stale. It is yet unknown if the reconnection is successful. */
    Reconnecting = 2,
    /**
     * The node seems offline because communication was not possible or is just initialized. The controller is now
     * waiting for a MDNS announcement and tries every 10 minutes to reconnect.
     */
    WaitingForDeviceDiscovery = 3,
    /**
     * Node structure has changed (Endpoints got added or also removed). Data are up-to-date.
     * This State information will only be fired when the subscribeAllAttributesAndEvents option is set to true.
     */
    StructureChanged = 4,
    /**
     * The node was just Decommissioned. This is a final state.
     */
    Decommissioned = 5
}
export type CommissioningControllerNodeOptions = {
    /**
     * Unless set to false all events and attributes are subscribed and value changes are reflected in the ClusterClient
     * instances. With this reading attributes values is mostly looked up in the locally cached data.
     * Additionally more features like reaction on shutdown event or endpoint structure changes (for bridges) are done
     * internally automatically.
     */
    readonly autoSubscribe?: boolean;
    /**
     * Minimum subscription interval when values are changed. Default it is set to 1s.
     * If the device is intermittently connected, the minimum interval is always set to 0s because required by Matter specs.
     */
    readonly subscribeMinIntervalFloorSeconds?: number;
    /**
     * Maximum subscription interval when values are changed. This is also used as a keepalive mechanism to validate
     * that the device is still available. matter.js tries to set meaningful values based on the device type, connection
     * type and other details. So ideally do not set this parameter unless you know it better.
     */
    readonly subscribeMaxIntervalCeilingSeconds?: number;
    /**
     * Optional additional callback method which is called for each Attribute change reported by the device. Use this
     * if subscribing to all relevant attributes is too much effort.
     * @deprecated Please use the events.attributeChanged observable instead.
     */
    readonly attributeChangedCallback?: (nodeId: NodeId, data: DecodedAttributeReportValue<any>) => void;
    /**
     * Optional additional callback method which is called for each Event reported by the device. Use this if
     * subscribing to all relevant events is too much effort.
     * @deprecated Please use the events.eventTriggered observable instead.
     */
    readonly eventTriggeredCallback?: (nodeId: NodeId, data: DecodedEventReportValue<any>) => void;
    /**
     * Optional callback method which is called when the state of the node changes. This can be used to detect when
     * the node goes offline or comes back online.
     * @deprecated Please use the events.nodeStateChanged observable and the extra events for structureCHanged and
     *  decomissioned instead.
     */
    readonly stateInformationCallback?: (nodeId: NodeId, state: NodeStateInformation) => void;
};
export declare class NodeNotConnectedError extends MatterError {
}
/**
 * Class to represents one node that is paired/commissioned with the matter.js Controller. Instances are returned by
 * the CommissioningController on commissioning or when connecting.
 */
export declare class PairedNode {
    #private;
    readonly nodeId: NodeId;
    private readonly commissioningController;
    private options;
    private readonly reconnectFunc;
    readonly events: {
        /**
         * Emitted when the node is initialized from local data. These data usually are stale, but you can still already
         * use the node to interact with the device. If no local data are available this event will be emitted together
         * with the initializedFromRemote event.
         */
        initialized: AsyncObservable<[details: DeviceInformationData], void>;
        /**
         * Emitted when the node is fully initialized from remote and all attributes and events are subscribed.
         * This event can also be awaited if code needs to be blocked until the node is fully initialized.
         */
        initializedFromRemote: AsyncObservable<[details: DeviceInformationData], void>;
        /** Emitted when the state of the node changes. */
        stateChanged: Observable<[nodeState: NodeStates], void>;
        /**
         * Emitted when an attribute value changes. If the oldValue is undefined then no former value was known.
         */
        attributeChanged: Observable<[data: DecodedAttributeReportValue<any>, oldValue: any], void>;
        /** Emitted when an event is triggered. */
        eventTriggered: Observable<[DecodedEventReportValue<any>], void>;
        /** Emitted when the structure of the node changes (Endpoints got added or also removed). */
        structureChanged: Observable<[void], void>;
        /** Emitted when the node is decommissioned. */
        decommissioned: Observable<[void], void>;
    };
    static create(nodeId: NodeId, commissioningController: CommissioningController, options: CommissioningControllerNodeOptions | undefined, knownNodeDetails: DeviceInformationData, interactionClient: InteractionClient, reconnectFunc: (discoveryType?: NodeDiscoveryType, noForcedConnection?: boolean) => Promise<void>, assignDisconnectedHandler: (handler: () => Promise<void>) => void, storedAttributeData?: DecodedAttributeReportValue<any>[]): Promise<PairedNode>;
    constructor(nodeId: NodeId, commissioningController: CommissioningController, options: CommissioningControllerNodeOptions | undefined, knownNodeDetails: DeviceInformationData, interactionClient: InteractionClient, reconnectFunc: (discoveryType?: NodeDiscoveryType, noForcedConnection?: boolean) => Promise<void>, assignDisconnectedHandler: (handler: () => Promise<void>) => void, storedAttributeData?: DecodedAttributeReportValue<any>[]);
    get construction(): Construction<PairedNode>;
    get isConnected(): boolean;
    get state(): NodeStates;
    get basicInformation(): import("./DeviceInformation.js").DeviceBasicInformation | undefined;
    get deviceInformation(): import("./DeviceInformation.js").DeviceMetaInformation | undefined;
    get localInitializationDone(): boolean;
    get remoteInitializationDone(): boolean;
    get initialized(): boolean;
    /**
     * Trigger a reconnection to the device. This method is non-blocking and will return immediately.
     * The reconnection happens in the background. Please monitor the state of the node to see if the
     * reconnection was successful.
     */
    triggerReconnect(): void;
    /**
     * Force a reconnection to the device.
     * This method is mainly used internally to reconnect after the active session
     * was closed or the device went offline and was detected as being online again.
     * Please note that this method does not return until the device is reconnected.
     * Please use triggerReconnect method for a non-blocking reconnection triggering.
     */
    reconnect(connectOptions?: CommissioningControllerNodeOptions): Promise<void>;
    /**
     * Request the current InteractionClient for custom special case interactions with the device. Usually the
     * ClusterClients of the Devices of the node should be used instead.
     */
    getInteractionClient(): Promise<InteractionClient>;
    /** Method to log the structure of this node with all endpoint and clusters. */
    logStructure(options?: EndpointLoggingOptions): void;
    /**
     * Subscribe to all attributes and events of the device. Unless setting the Controller property autoSubscribe to
     * false this is executed automatically. Alternatively you can manually subscribe by calling this method.
     */
    subscribeAllAttributesAndEvents(options?: {
        ignoreInitialTriggers?: boolean;
        attributeChangedCallback?: (data: DecodedAttributeReportValue<any>, oldValue: any) => void;
        eventTriggeredCallback?: (data: DecodedEventReportValue<any>) => void;
    }): Promise<{
        attributeReports?: DecodedAttributeReportValue<any>[];
        eventReports?: DecodedEventReportValue<any>[];
    }>;
    readAllAttributes(): Promise<DecodedAttributeReportValue<any>[]>;
    /** Returns the functional devices/endpoints (those below the Root Endpoint) known for this node. */
    getDevices(): EndpointInterface[];
    /** Returns the device/endpoint with the given endpoint ID. */
    getDeviceById(endpointId: number): Endpoint | undefined;
    getRootEndpoint(): Endpoint | undefined;
    /** De-Commission (unpair) the device from this controller by removing the fabric from the device. */
    decommission(): Promise<void>;
    /** Opens a Basic Commissioning Window (uses the original Passcode printed on the device) with the device. */
    openBasicCommissioningWindow(commissioningTimeout?: number): Promise<void>;
    /** Opens an Enhanced Commissioning Window (uses a generated random Passcode) with the device. */
    openEnhancedCommissioningWindow(commissioningTimeout?: number): Promise<{
        manualPairingCode: string;
        qrPairingCode: string;
    }>;
    disconnect(): Promise<void>;
    close(sendDecommissionedStatus?: boolean): void;
    /**
     * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param cluster ClusterServer to get or undefined if not existing
     */
    getRootClusterServer<const T extends ClusterType>(cluster: T): ClusterServerObj<T> | undefined;
    /**
     * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param cluster ClusterClient to get or undefined if not existing
     */
    getRootClusterClient<const T extends ClusterType>(cluster: T): ClusterClientObj<T> | undefined;
    /**
     * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param endpointId EndpointNumber to get the cluster from
     * @param cluster ClusterServer to get or undefined if not existing
     */
    getClusterServerForDevice<const T extends ClusterType>(endpointId: EndpointNumber, cluster: T): ClusterServerObj<T> | undefined;
    /**
     * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
     *
     * @param endpointId EndpointNumber to get the cluster from
     * @param cluster ClusterClient to get or undefined if not existing
     */
    getClusterClientForDevice<const T extends ClusterType>(endpointId: EndpointNumber, cluster: T): ClusterClientObj<T> | undefined;
}
//# sourceMappingURL=PairedNode.d.ts.map