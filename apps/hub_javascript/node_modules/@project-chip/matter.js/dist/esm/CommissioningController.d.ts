/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Environment, NetInterfaceSet, StorageContext, SyncStorage } from "#general";
import { CommissionableDevice, CommissionableDeviceIdentifiers, DecodedAttributeReportValue, DiscoveryAndCommissioningOptions, DiscoveryData, InteractionClient, MdnsBroadcaster, MdnsScanner, NodeDiscoveryType, ScannerSet } from "#protocol";
import { CaseAuthenticatedTag, DiscoveryCapabilitiesBitmap, FabricId, FabricIndex, NodeId, TypeFromPartialBitSchema, VendorId } from "#types";
import { CommissioningControllerNodeOptions, PairedNode } from "./device/PairedNode.js";
import { MatterController } from "./MatterController.js";
import { MatterNode } from "./MatterNode.js";
export type ControllerEnvironmentOptions = {
    /**
     * Environment to register the node with on start()
     */
    readonly environment: Environment;
    /**
     * Unique id to register to node.
     */
    readonly id: string;
};
/**
 * Constructor options for the CommissioningController class
 */
export type CommissioningControllerOptions = CommissioningControllerNodeOptions & {
    /**
     * Local port number to use for the UDP interface. By default, a random port number will be generated
     * (strongly recommended!).
     */
    readonly localPort?: number;
    /** Listening address for IPv4. By default, the interface will listen on all IPv4 addresses. */
    readonly listeningAddressIpv4?: string;
    /** Listening address for IPv6. By default, the interface will listen on all IPv6 addresses. */
    readonly listeningAddressIpv6?: string;
    /**
     * If set to false, the controller will not connect to any device on startup. You need to use connectNode() or
     * connect() to connect to the relevant nodes in this case. Else all nodes are connected on startup.
     * */
    readonly autoConnect?: boolean;
    /** Admin Vendor ID used for all commissioning operations. Cannot be changed afterward. Default: 0xFFF1 */
    readonly adminVendorId?: VendorId;
    /**
     * Controller own Fabric ID used to initialize the Controller the first time and to generate the Root certificate.
     * Cannot be changed afterward.
     * Default: 1
     */
    readonly adminFabricId?: FabricId;
    /**
     * Fabric Index used to initialize the Controller the first time. Cannot be changed afterward.
     * Default: 1
     */
    readonly adminFabricIndex?: FabricIndex;
    /**
     * CASE Authenticated Tags used to initialize the Controller the first time. Cannot be changed afterward.
     * Maximum 3 tags are supported.
     */
    readonly caseAuthenticatedTags?: CaseAuthenticatedTag[];
    /**
     * When used with the new API Environment set the environment here and the CommissioningServer will self-register
     * on the environment when you call start().
     */
    readonly environment?: ControllerEnvironmentOptions;
};
/** Options needed to commission a new node */
export type NodeCommissioningOptions = CommissioningControllerNodeOptions & {
    commissioning: Omit<DiscoveryAndCommissioningOptions, "fabric" | "discovery" | "passcode">;
    discovery: DiscoveryAndCommissioningOptions["discovery"];
    passcode: number;
};
/** Controller class to commission and connect multiple nodes into one fabric. */
export declare class CommissioningController extends MatterNode {
    private readonly options;
    private started;
    private ipv4Disabled?;
    private readonly listeningAddressIpv4?;
    private readonly listeningAddressIpv6?;
    private environment?;
    private storage?;
    private mdnsScanner?;
    private mdnsBroadcaster?;
    private controllerInstance?;
    private initializedNodes;
    private sessionDisconnectedHandler;
    /**
     * Creates a new CommissioningController instance
     *
     * @param options The options for the CommissioningController
     */
    constructor(options: CommissioningControllerOptions);
    get nodeId(): NodeId | undefined;
    get paseCommissionerConfig(): {
        caConfig: import("#protocol").CertificateAuthority.Configuration;
        fabricData: import("#protocol").Fabric.Config;
    };
    assertIsAddedToMatterServer(): {
        mdnsScanner: MdnsScanner;
        storage: StorageContext<any> | undefined;
        environment: Environment | undefined;
    };
    assertControllerIsStarted(errorText?: string): MatterController;
    /** Internal method to initialize a MatterController instance. */
    private initializeController;
    /**
     * Commissions/Pairs a new device into the controller fabric. The method returns the NodeId of the commissioned
     * node.
     */
    commissionNode(nodeOptions: NodeCommissioningOptions, connectNodeAfterCommissioning?: boolean): Promise<NodeId>;
    /**
     * Completes the commissioning process for a node when the initial commissioning process was done by a PASE
     * commissioner. This method should be called to discover the device operational and complete the commissioning
     * process.
     */
    completeCommissioningForNode(peerNodeId: NodeId, discoveryData?: DiscoveryData): Promise<void>;
    /** Check if a given node id is commissioned on this controller. */
    isNodeCommissioned(nodeId: NodeId): boolean;
    /**
     * Remove a Node id from the controller. This method should only be used if the decommission method on the
     * PairedNode instance returns an error. By default, it tries to decommission the node from the controller but will
     * remove it also in case of an error during decommissioning. Ideally try to decommission the node before and only
     * use this in case of an error.
     */
    removeNode(nodeId: NodeId, tryDecommissioning?: boolean): Promise<void>;
    disconnectNode(nodeId: NodeId): Promise<void>;
    /**
     * Connect to an already paired Node.
     * After connection the endpoint data of the device is analyzed and an object structure is created.
     */
    connectNode(nodeId: NodeId, connectOptions?: CommissioningControllerNodeOptions): Promise<PairedNode>;
    collectStoredAttributeData(nodeId: NodeId): Promise<DecodedAttributeReportValue<any>[]>;
    /**
     * Connects to all paired nodes.
     * After connection the endpoint data of the device is analyzed and an object structure is created.
     */
    connect(connectOptions?: CommissioningControllerNodeOptions): Promise<PairedNode[]>;
    /**
     * Set the MDNS Scanner instance. Should be only used internally
     *
     * @param mdnsScanner MdnsScanner instance
     */
    setMdnsScanner(mdnsScanner: MdnsScanner): void;
    /**
     * Set the MDNS Broadcaster instance. Should be only used internally
     *
     * @param mdnsBroadcaster MdnsBroadcaster instance
     */
    setMdnsBroadcaster(mdnsBroadcaster: MdnsBroadcaster): void;
    /**
     * Set the Storage instance. Should be only used internally
     *
     * @param storage storage context to use
     */
    setStorage(storage: StorageContext<SyncStorage>): void;
    /** Returns true if t least one node is commissioned/paired with this controller instance. */
    isCommissioned(): boolean;
    /**
     * Creates and Return a new InteractionClient to communicate with a node. This is mainly used internally and should
     * not be used directly. See the PairedNode class for the public API.
     */
    createInteractionClient(nodeId: NodeId, discoveryType?: NodeDiscoveryType, forcedConnection?: boolean): Promise<InteractionClient>;
    /** Returns the PairedNode instance for a given node id, if this node is connected. */
    getPairedNode(nodeId: NodeId): PairedNode | undefined;
    /** Returns an array with the Node Ids for all commissioned nodes. */
    getCommissionedNodes(): NodeId[];
    getCommissionedNodesDetails(): {
        nodeId: NodeId;
        operationalAddress: string | undefined;
        advertisedName: string | undefined;
        discoveryData: DiscoveryData | undefined;
        deviceData: import("./device/DeviceInformation.js").DeviceInformationData | undefined;
    }[];
    /** Disconnects all connected nodes and Closes the network connections and other resources of the controller. */
    close(): Promise<void>;
    getPort(): number | undefined;
    initialize(ipv4Disabled: boolean): void;
    initializeControllerStore(): Promise<void>;
    /** Initialize the controller and connect to all commissioned nodes if autoConnect is not set to false. */
    start(): Promise<void>;
    cancelCommissionableDeviceDiscovery(identifierData: CommissionableDeviceIdentifiers, discoveryCapabilities?: TypeFromPartialBitSchema<typeof DiscoveryCapabilitiesBitmap>): void;
    discoverCommissionableDevices(identifierData: CommissionableDeviceIdentifiers, discoveryCapabilities?: TypeFromPartialBitSchema<typeof DiscoveryCapabilitiesBitmap>, discoveredCallback?: (device: CommissionableDevice) => void, timeoutSeconds?: number): Promise<CommissionableDevice[]>;
    resetStorage(): Promise<void>;
    /** Returns active session information for all connected nodes. */
    getActiveSessionInformation(): {
        name: string;
        nodeId: NodeId;
        peerNodeId: NodeId;
        fabric: import("#protocol").ExposedFabricInformation | undefined;
        isPeerActive: boolean;
        secure: boolean;
        lastInteractionTimestamp: number | undefined;
        lastActiveTimestamp: number | undefined;
        numberOfActiveSubscriptions: number;
    }[];
}
export declare function configureNetwork(options: {
    ipv4Disabled?: boolean;
    mdnsScanner?: MdnsScanner;
    localPort?: number;
    listeningAddressIpv6?: string;
    listeningAddressIpv4?: string;
}): Promise<{
    netInterfaces: NetInterfaceSet;
    scanners: ScannerSet;
    port: number;
}>;
//# sourceMappingURL=CommissioningController.d.ts.map