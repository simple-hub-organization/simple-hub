/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Logger, Network, NetworkError } from "#general";
import { MdnsBroadcaster, MdnsScanner } from "#protocol";
const logger = Logger.get("MatterServer");
const MATTER_PORT = 5540;
class MatterServer {
  /**
   * Create a new Matter server instance
   *
   * @param storageManager Storage manager instance to use for all nodes
   * @param options Optional MatterServer options
   */
  constructor(storageManager, options) {
    this.storageManager = storageManager;
    this.options = options;
  }
  started = false;
  nodes = /* @__PURE__ */ new Map();
  mdnsScanner;
  mdnsBroadcaster;
  formerlyUsedPorts = new Array();
  get ipv4Disabled() {
    return !!this.options?.disableIpv4;
  }
  getNextMatterPort(desiredPort) {
    const portCheckMap = /* @__PURE__ */ new Map();
    for (const node of this.nodes.values()) {
      const nodePort = node.getPort();
      if (nodePort === void 0) continue;
      if (portCheckMap.has(nodePort)) {
        throw new NetworkError(`Port ${nodePort} is already in use by other node.`);
      }
      portCheckMap.set(nodePort, true);
    }
    if (desiredPort !== void 0) {
      if (portCheckMap.has(desiredPort)) {
        throw new NetworkError(`Port ${desiredPort} is already in use by other node.`);
      }
      return desiredPort;
    }
    let portToCheck = MATTER_PORT;
    while ((portCheckMap.has(portToCheck) || this.formerlyUsedPorts.includes(portToCheck)) && portToCheck < 65536) {
      portToCheck++;
    }
    if (portToCheck === 65536) {
      for (let i = 0; i < this.formerlyUsedPorts.length; i++) {
        const port = this.formerlyUsedPorts[i];
        this.formerlyUsedPorts.splice(i, 1);
        if (!portCheckMap.has(port)) {
          portToCheck = port;
          break;
        }
      }
      if (portToCheck === 65536) {
        throw new NetworkError("No free port available for Matter server.");
      }
    }
    return portToCheck;
  }
  /**
   * Add a CommissioningServer node to the server
   *
   * @param commissioningServer CommissioningServer node to add
   * @param nodeOptions Optional options for the node (e.g. unique node id)
   */
  async addCommissioningServer(commissioningServer, nodeOptions) {
    const storageKey = nodeOptions?.uniqueStorageKey ?? nodeOptions?.uniqueNodeId ?? this.nodes.size.toString();
    if (this.nodes.has(storageKey)) {
      throw new Error(`Node with storage key "${storageKey}" already exists.`);
    }
    commissioningServer.setPort(this.getNextMatterPort(commissioningServer.getPort()));
    await commissioningServer.setStorage(this.storageManager.createContext(storageKey));
    logger.debug(`Adding CommissioningServer using storage key "${storageKey}".`);
    await this.prepareNode(commissioningServer);
    this.nodes.set(storageKey, commissioningServer);
  }
  /**
   * Remove a CommissioningServer node from the server, close the CommissioningServer and optionally destroy the
   * storage context.
   *
   * @param commissioningServer CommissioningServer node to remove
   * @param destroyStorage If true the storage context will be destroyed
   */
  async removeCommissioningServer(commissioningServer, destroyStorage = false) {
    for (const [key, value] of this.nodes.entries()) {
      if (value === commissioningServer) {
        this.nodes.delete(key);
        const port = commissioningServer.getPort();
        if (port !== void 0) {
          this.formerlyUsedPorts.push(port);
        }
        await commissioningServer.close();
        if (destroyStorage) {
          await commissioningServer.factoryReset();
        }
        return;
      }
    }
    throw new Error("CommissioningServer to remove not found.");
  }
  /**
   * Add a Controller node to the server
   *
   * @param commissioningController Controller node to add
   * @param nodeOptions Optional options for the node (e.g. unique node id)
   */
  async addCommissioningController(commissioningController, nodeOptions) {
    const storageKey = nodeOptions?.uniqueStorageKey ?? nodeOptions?.uniqueNodeId ?? this.nodes.size.toString();
    if (this.nodes.has(storageKey)) {
      throw new Error(`Node with storage key "${storageKey}" already exists.`);
    }
    const localPort = commissioningController.getPort();
    if (localPort !== void 0) {
      this.getNextMatterPort(localPort);
    }
    commissioningController.setStorage(this.storageManager.createContext(storageKey));
    logger.debug(`Adding CommissioningController using storage key "${storageKey}".`);
    await this.prepareNode(commissioningController);
    this.nodes.set(storageKey, commissioningController);
  }
  /**
   * Remove a Controller node from the server, close the Controller and optionally destroy the storage context.
   *
   * @param commissioningController Controller node to remove
   * @param destroyStorage If true the storage context will be destroyed
   */
  async removeCommissioningController(commissioningController, destroyStorage = false) {
    for (const [key, value] of this.nodes.entries()) {
      if (value === commissioningController) {
        this.nodes.delete(key);
        await commissioningController.close();
        if (destroyStorage) {
          await commissioningController.resetStorage();
        }
        return;
      }
    }
    throw new Error("CommissioningController to remove not found.");
  }
  /**
   * Start the server and all nodes. If the nodes do not have specified a delayed announcement or pairing they will
   * be announced/paired immediately.
   */
  async start() {
    if (this.mdnsBroadcaster === void 0) {
      this.mdnsBroadcaster = await MdnsBroadcaster.create(Network.get(), {
        enableIpv4: !this.ipv4Disabled,
        multicastInterface: this.options?.mdnsInterface ?? this.options?.mdnsAnnounceInterface
      });
    }
    if (this.mdnsScanner === void 0) {
      this.mdnsScanner = await MdnsScanner.create(Network.get(), {
        enableIpv4: !this.ipv4Disabled,
        netInterface: this.options?.mdnsInterface
      });
    }
    this.started = true;
    for (const [key, node] of this.nodes.entries()) {
      try {
        await this.prepareNode(node);
      } catch (error) {
        logger.error(`Failed to start node with storageKey ${key}:`, error);
      }
    }
  }
  async prepareNode(node) {
    node.initialize(this.ipv4Disabled);
    if (this.mdnsBroadcaster === void 0 || this.mdnsScanner === void 0) {
      logger.debug("Mdns instances not yet created, delaying node preparation.");
      return;
    }
    node.setMdnsBroadcaster(this.mdnsBroadcaster);
    node.setMdnsScanner(this.mdnsScanner);
    if (this.started) {
      await node.start();
    }
  }
  /**
   * Close the server and all nodes
   */
  async close() {
    for (const [key, node] of this.nodes.entries()) {
      try {
        await node.close();
      } catch (error) {
        logger.error(`Failed to close node with storageKey ${key}: ${error}`);
      }
    }
    await this.mdnsBroadcaster?.close();
    this.mdnsBroadcaster = void 0;
    await this.mdnsScanner?.close();
    this.mdnsScanner = void 0;
    this.started = false;
  }
}
export {
  MatterServer
};
//# sourceMappingURL=MatterServer.js.map
