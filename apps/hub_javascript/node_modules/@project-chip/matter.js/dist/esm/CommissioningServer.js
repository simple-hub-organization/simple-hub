/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  AccessControl,
  AdministratorCommissioning,
  AdministratorCommissioningCluster,
  BasicInformationCluster,
  GeneralCommissioning,
  GeneralCommissioningCluster,
  GeneralDiagnostics,
  GeneralDiagnosticsCluster,
  GroupKeyManagementCluster,
  OperationalCredentialsCluster
} from "#clusters";
import {
  Bytes,
  Crypto,
  ImplementationError,
  InternalError,
  Logger,
  NamedHandler,
  Network,
  NoProviderError,
  UdpInterface
} from "#general";
import { MatterDevice } from "#MatterDevice.js";
import { Specification } from "#model";
import {
  AttestationCertificateManager,
  Ble,
  CertificationDeclarationManager,
  EventHandler,
  genericFabricScopedAttributeGetterFromFabric,
  genericFabricScopedAttributeSetterForFabric,
  InteractionEndpointStructure,
  PaseClient
} from "#protocol";
import {
  CommissioningFlowType,
  DiscoveryCapabilitiesSchema,
  EndpointNumber,
  FabricIndex,
  ManualPairingCodeCodec,
  QrPairingCodeCodec,
  VendorId
} from "#types";
import { createDefaultAccessControlClusterServer } from "./cluster/server/AccessControlServer.js";
import { AdministratorCommissioningHandler } from "./cluster/server/AdministratorCommissioningServer.js";
import { ClusterServer } from "./cluster/server/ClusterServer.js";
import { GeneralCommissioningClusterHandler } from "./cluster/server/GeneralCommissioningServer.js";
import { createDefaultGeneralDiagnosticsClusterServer } from "./cluster/server/GeneralDiagnosticsServer.js";
import { GroupKeyManagementClusterHandler } from "./cluster/server/GroupKeyManagementServer.js";
import { OperationalCredentialsClusterHandler } from "./cluster/server/OperationalCredentialsServer.js";
import { RootEndpoint } from "./device/Device.js";
import { LegacyInteractionServer } from "./device/LegacyInteractionServer.js";
import { MatterNode } from "./MatterNode.js";
const logger = Logger.get("CommissioningServer");
const FORBIDDEN_PASSCODES = [
  0,
  11111111,
  22222222,
  33333333,
  44444444,
  55555555,
  66666666,
  77777777,
  88888888,
  99999999,
  12345678,
  87654321
];
class CommissioningServer extends MatterNode {
  /**
   * Creates a new CommissioningServer node and add all needed Root clusters
   *
   * @param options The options for the CommissioningServer node
   */
  constructor(options) {
    super();
    this.options = options;
    const {
      port,
      passcode,
      discriminator,
      flowType,
      nextEndpointId,
      delayedAnnouncement,
      basicInformation: { vendorId: vendorIdNumber, productId },
      generalCommissioning
    } = options;
    this.port = port;
    if (passcode !== void 0 && FORBIDDEN_PASSCODES.includes(passcode)) {
      throw new ImplementationError(`Passcode ${passcode} is not allowed.`);
    }
    this.passcode = passcode ?? PaseClient.generateRandomPasscode();
    this.discriminator = discriminator ?? PaseClient.generateRandomDiscriminator();
    this.flowType = flowType ?? CommissioningFlowType.Standard;
    this.nextEndpointId = EndpointNumber(nextEndpointId ?? 1);
    this.delayedAnnouncement = delayedAnnouncement;
    const vendorId = VendorId(vendorIdNumber);
    const basicInformationAttributes = {
      dataModelRevision: Specification.DATA_MODEL_REVISION,
      nodeLabel: "",
      hardwareVersion: 0,
      hardwareVersionString: "0",
      location: "XX",
      localConfigDisabled: false,
      softwareVersion: 1,
      softwareVersionString: "v1",
      capabilityMinima: {
        caseSessionsPerFabric: 3,
        // TODO get that limit from Sessionmanager or such or sync with it, add limit? Just a minima?
        subscriptionsPerFabric: 3
        // TODO get that limit from Interactionserver? Respect it? It is just a minima?
      },
      serialNumber: `matter.js-${Bytes.toHex(Crypto.get().getRandomData(4))}`,
      specificationVersion: Specification.SPECIFICATION_VERSION,
      maxPathsPerInvoke: 1,
      ...options.basicInformation,
      vendorId
      // Just for TS
    };
    const reachabilitySupported = basicInformationAttributes.reachable !== void 0;
    const basicInformationCluster = ClusterServer(
      BasicInformationCluster,
      basicInformationAttributes,
      {},
      {
        startUp: true,
        shutDown: true,
        reachableChanged: reachabilitySupported,
        leave: true
      }
    );
    this.rootEndpoint.addClusterServer(basicInformationCluster);
    if (reachabilitySupported) {
      basicInformationCluster.subscribeReachableAttribute(
        (newValue) => basicInformationCluster.triggerReachableChangedEvent?.({ reachableNewValue: newValue })
      );
    }
    let { certificates } = options;
    if (certificates == void 0) {
      const paa = new AttestationCertificateManager(vendorId);
      const { keyPair: dacKeyPair, dac } = paa.getDACert(productId);
      const declaration = CertificationDeclarationManager.generate(vendorId, productId);
      certificates = {
        privateKey: dacKeyPair.privateKey,
        certificate: dac,
        intermediateCertificate: paa.getPAICert(),
        declaration
      };
    }
    this.productDescription = {
      name: options.deviceName,
      deviceType: options.deviceType,
      vendorId,
      productId
    };
    this.rootEndpoint.addClusterServer(
      ClusterServer(
        OperationalCredentialsCluster,
        {
          nocs: [],
          fabrics: [],
          supportedFabrics: 254,
          // maximum number of fabrics. Also FabricBuilder uses 254 as max!
          commissionedFabrics: 0,
          trustedRootCertificates: [],
          currentFabricIndex: FabricIndex.NO_FABRIC
        },
        OperationalCredentialsClusterHandler(certificates, this.productDescription)
      )
    );
    this.rootEndpoint.addClusterServer(
      ClusterServer(
        GeneralCommissioningCluster,
        {
          breadcrumb: generalCommissioning?.breadcrumb ?? BigInt(0),
          basicCommissioningInfo: generalCommissioning?.basicCommissioningInfo ?? {
            failSafeExpiryLengthSeconds: 60,
            maxCumulativeFailsafeSeconds: 900
          },
          regulatoryConfig: generalCommissioning?.regulatoryConfig ?? GeneralCommissioning.RegulatoryLocationType.Outdoor,
          // Default is the most restrictive one
          locationCapability: generalCommissioning?.locationCapability ?? GeneralCommissioning.RegulatoryLocationType.IndoorOutdoor,
          supportsConcurrentConnection: generalCommissioning?.supportsConcurrentConnection ?? true
        },
        GeneralCommissioningClusterHandler({
          allowCountryCodeChange: generalCommissioning?.allowCountryCodeChange ?? true,
          countryCodeWhitelist: generalCommissioning?.countryCodeWhitelist ?? void 0
        })
      )
    );
    this.rootEndpoint.addClusterServer(createDefaultAccessControlClusterServer());
    this.rootEndpoint.addClusterServer(
      ClusterServer(
        GroupKeyManagementCluster,
        {
          groupKeyMap: [],
          groupTable: [],
          maxGroupsPerFabric: 0,
          // TODO: Increase once we add group support, for now only IPK is supported
          maxGroupKeysPerFabric: 1
        },
        GroupKeyManagementClusterHandler()
      )
    );
    this.rootEndpoint.addClusterServer(
      ClusterServer(
        AdministratorCommissioningCluster,
        {
          windowStatus: AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen,
          adminFabricIndex: null,
          adminVendorId: null
        },
        AdministratorCommissioningHandler()
      )
    );
    this.endpointStructure = new InteractionEndpointStructure();
    this.endpointStructure.change.on(() => {
      if (this.storage === void 0 || this.eventHandler === void 0) {
        throw new InternalError("Endpoint structure reports change prior to server initialization");
      }
      for (const endpoint of this.endpointStructure.endpoints.values()) {
        for (const cluster of endpoint.getAllClusterServers()) {
          new CommissioningServerClusterDatasource(
            endpoint,
            cluster,
            this.storage,
            this.eventHandler,
            () => this.deviceInstance.getFabrics()
          );
        }
      }
    });
  }
  ipv4Disabled;
  port;
  passcode;
  discriminator;
  flowType;
  productDescription;
  storage;
  endpointStructureStorage;
  mdnsScanner;
  mdnsBroadcaster;
  mdnsInstanceBroadcaster;
  deviceInstance;
  eventHandler;
  endpointStructure;
  interactionServer;
  rootEndpoint = new RootEndpoint();
  nextEndpointId;
  delayedAnnouncement;
  commandHandler = new NamedHandler();
  /**
   * Get a cluster server from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterServer to get or undefined if not existing
   */
  getRootClusterServer(cluster) {
    return this.rootEndpoint.getClusterServer(cluster);
  }
  /**
   * Add a cluster client to the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterClient object to add
   */
  addRootClusterClient(cluster) {
    this.rootEndpoint.addClusterClient(cluster);
  }
  /**
   * Get a cluster client from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param cluster ClusterClient to get or undefined if not existing
   */
  getRootClusterClient(cluster) {
    return this.rootEndpoint.getClusterClient(cluster);
  }
  /**
   * Get the root endpoint of the node.
   */
  getRootEndpoint() {
    return this.rootEndpoint;
  }
  /**
   * Add a child endpoint to the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param endpoint Endpoint to add
   * @protected
   */
  addEndpoint(endpoint) {
    this.rootEndpoint.addChildEndpoint(endpoint);
  }
  /**
   * Get a child endpoint from the root endpoint. This is mainly used internally and not needed to be called by the user.
   *
   * @param endpointId Endpoint ID of the child endpoint to get
   * @protected
   */
  getChildEndpoint(endpointId) {
    return this.rootEndpoint.getChildEndpoint(endpointId);
  }
  /**
   * Add a new cluster server to the root endpoint
   * BasicInformationCluster and OperationalCredentialsCluster cannot be added via this method because they are
   * added in the constructor
   *
   * @param cluster
   */
  addRootClusterServer(cluster) {
    if (cluster.id === BasicInformationCluster.id) {
      throw new ImplementationError(
        "BasicInformationCluster cannot be modified, provide all details in constructor options!"
      );
    }
    if (cluster.id === OperationalCredentialsCluster.id) {
      throw new ImplementationError(
        "OperationalCredentialsCluster cannot be modified, provide the certificates in constructor options!"
      );
    }
    this.rootEndpoint.addClusterServer(cluster);
  }
  /**
   * Advertise the node via all available interfaces (Ethernet/MDNS, BLE, ...) and start the commissioning process
   *
   * @param limitTo Limit the advertisement to the given discovery capabilities. Default is to advertise on ethernet
   *                and BLE if configured
   */
  async advertise(limitTo) {
    if (this.mdnsBroadcaster === void 0 || this.mdnsScanner === void 0 || this.storage === void 0 || this.eventHandler === void 0 || this.endpointStructureStorage === void 0 || this.port === void 0) {
      throw new ImplementationError("Add the node to the Matter instance before!");
    }
    if (this.interactionServer !== void 0 && this.deviceInstance !== void 0) {
      logger.debug("Device already initialized, just advertise the instance again ...");
      await this.deviceInstance.announce();
      return;
    }
    this.mdnsInstanceBroadcaster = this.mdnsBroadcaster.createInstanceBroadcaster(this.port);
    this.rootEndpoint.addClusterServer(await createDefaultGeneralDiagnosticsClusterServer(this.commandHandler));
    const basicInformation = this.getRootClusterServer(BasicInformationCluster);
    if (basicInformation == void 0) {
      throw new ImplementationError("BasicInformationCluster needs to be set!");
    }
    const maxPathsPerInvoke = basicInformation.getMaxPathsPerInvokeAttribute();
    this.nextEndpointId = this.endpointStructureStorage.get("nextEndpointId", this.nextEndpointId);
    this.assignEndpointIds();
    this.rootEndpoint.updatePartsList();
    this.rootEndpoint.setStructureChangedCallback(() => this.updateStructure());
    this.endpointStructure.initializeFromEndpoint(this.rootEndpoint);
    const deviceInstance = await MatterDevice.create(
      this.storage.createContext("SessionManager"),
      this.storage.createContext("FabricManager"),
      () => ({
        enabled: true,
        productDescription: this.productDescription,
        passcode: this.passcode,
        discriminator: this.discriminator,
        flowType: this.flowType,
        additionalBleAdvertisementData: this.options.additionalBleAdvertisementData,
        // We don't use this
        ble: false
      }),
      basicInformation.getCapabilityMinimaAttribute().caseSessionsPerFabric,
      // Internally it is "Session and Node", so we support even more
      (fabricIndex) => {
        const fabricsCount = this.deviceInstance?.getFabrics().length ?? 0;
        if (fabricsCount === 1) {
          if (this.mdnsInstanceBroadcaster !== void 0 && !this.deviceInstance?.hasBroadcaster(this.mdnsInstanceBroadcaster)) {
            this.deviceInstance?.addBroadcaster(this.mdnsInstanceBroadcaster);
          }
        }
        if (fabricsCount === 0) {
          this.factoryReset().then(() => this.options.commissioningChangedCallback?.(fabricIndex)).catch((error) => logger.error("Error while doing factory reset of the device", error));
        } else {
          this.options.commissioningChangedCallback?.(fabricIndex);
        }
      },
      (fabricIndex) => this.options.activeSessionsChangedCallback?.(fabricIndex),
      { maxPathsPerInvoke }
    );
    deviceInstance.addTransportInterface(
      await UdpInterface.create(Network.get(), "udp6", this.port, this.options.listeningAddressIpv6)
    );
    this.interactionServer = new LegacyInteractionServer({
      sessions: deviceInstance.sessionManager,
      structure: this.endpointStructure,
      subscriptionOptions: {
        maxIntervalSeconds: this.options.subscriptionMaxIntervalSeconds,
        minIntervalSeconds: this.options.subscriptionMinIntervalSeconds,
        randomizationWindowSeconds: this.options.subscriptionRandomizationWindowSeconds
      },
      maxPathsPerInvoke,
      initiateExchange: (address, protocolId) => {
        return deviceInstance.initiateExchange(address, protocolId);
      }
    });
    deviceInstance.addProtocolHandler(this.interactionServer);
    this.deviceInstance = deviceInstance;
    if (!this.ipv4Disabled) {
      deviceInstance.addTransportInterface(
        await UdpInterface.create(Network.get(), "udp4", this.port, this.options.listeningAddressIpv4)
      );
    }
    if (this.isCommissioned()) {
      const fabrics = deviceInstance.getFabrics();
      for (const fabric of fabrics) {
        if (genericFabricScopedAttributeGetterFromFabric(
          fabric,
          AccessControl.Cluster,
          "acl",
          void 0
        ) === void 0) {
          genericFabricScopedAttributeSetterForFabric(fabric, AccessControl.Cluster, "acl", [
            {
              fabricIndex: fabric.fabricIndex,
              privilege: AccessControl.AccessControlEntryPrivilege.Administer,
              authMode: AccessControl.AccessControlEntryAuthMode.Case,
              subjects: [fabric.rootNodeId],
              targets: null
              // entire node
            }
          ]);
          logger.warn(
            "Added missing ACL entry for fabric",
            fabric.fabricIndex,
            "for Node ID",
            fabric.rootNodeId,
            ". This should only happen once after upgrading to matter.js 0.9.1"
          );
        }
      }
      limitTo = { onIpNetwork: true };
    } else {
      try {
        const ble = Ble.get();
        deviceInstance.addTransportInterface(ble.getBlePeripheralInterface());
        if (limitTo === void 0 || limitTo.ble) {
          deviceInstance.addBroadcaster(ble.getBleBroadcaster(this.options.additionalBleAdvertisementData));
        }
      } catch (error) {
        NoProviderError.accept(error);
        logger.debug("Ble not enabled");
      }
    }
    if (limitTo === void 0 || limitTo.onIpNetwork) {
      deviceInstance.addBroadcaster(this.mdnsInstanceBroadcaster);
    }
    await deviceInstance.start();
    basicInformation.triggerStartUpEvent({ softwareVersion: basicInformation.getSoftwareVersionAttribute() });
    const generalDiagnostics = this.getRootClusterServer(GeneralDiagnosticsCluster);
    if (generalDiagnostics !== void 0) {
      this.getRootClusterServer(GeneralDiagnosticsCluster)?.triggerBootReasonEvent({
        bootReason: generalDiagnostics.getBootReasonAttribute?.() ?? GeneralDiagnostics.BootReason.Unspecified
      });
    }
  }
  updateStructure() {
    logger.debug("Endpoint structure got updated ...");
    this.assignEndpointIds();
    this.rootEndpoint.updatePartsList();
    this.endpointStructure.initializeFromEndpoint(this.rootEndpoint);
  }
  getNextEndpointId(increase = true) {
    if (increase) {
      this.nextEndpointId++;
    }
    return this.nextEndpointId;
  }
  assignEndpointIds() {
    const rootUniqueIdPrefix = this.rootEndpoint.determineUniqueID();
    this.initializeEndpointIdsFromStorage(this.rootEndpoint, rootUniqueIdPrefix);
    this.fillAndStoreEndpointIds(this.rootEndpoint, rootUniqueIdPrefix);
    this.endpointStructureStorage?.set("nextEndpointId", this.nextEndpointId);
  }
  initializeEndpointIdsFromStorage(endpoint, parentUniquePrefix = "") {
    if (this.endpointStructureStorage === void 0) {
      throw new ImplementationError("Storage manager must be initialized to enable initialization from storage.");
    }
    const endpoints = endpoint.getChildEndpoints();
    for (let endpointIndex = 0; endpointIndex < endpoints.length; endpointIndex++) {
      let endpointUniquePrefix = parentUniquePrefix;
      const endpoint2 = endpoints[endpointIndex];
      const thisUniqueId = endpoint2.determineUniqueID();
      if (thisUniqueId === void 0) {
        if (endpoint2.number === void 0) {
          logger.debug(
            `No unique id found for endpoint on index ${endpointIndex} / device ${endpoint2.name} - using index as unique identifier!`
          );
        }
        endpointUniquePrefix += `${endpointUniquePrefix === "" ? "" : "-"}index_${endpointIndex}`;
      } else {
        endpointUniquePrefix += `${endpointUniquePrefix === "" ? "" : "-"}${thisUniqueId}`;
      }
      if (endpoint2.number === void 0) {
        if (this.endpointStructureStorage.has(endpointUniquePrefix)) {
          endpoint2.number = this.endpointStructureStorage.get(endpointUniquePrefix);
          logger.debug(
            `Restored endpoint id ${endpoint2.number} for endpoint with ${endpointUniquePrefix} / device ${endpoint2.name} from storage`
          );
        }
      }
      if (endpoint2.number !== void 0 && endpoint2.number > this.nextEndpointId) {
        this.nextEndpointId = EndpointNumber(endpoint2.number + 1);
      }
      this.initializeEndpointIdsFromStorage(endpoint2, endpointUniquePrefix);
    }
  }
  fillAndStoreEndpointIds(endpoint, parentUniquePrefix = "") {
    if (this.endpointStructureStorage === void 0) {
      throw new ImplementationError("endpointStructureStorage not set!");
    }
    const endpoints = endpoint.getChildEndpoints();
    for (let endpointIndex = 0; endpointIndex < endpoints.length; endpointIndex++) {
      let endpointUniquePrefix = parentUniquePrefix;
      endpoint = endpoints[endpointIndex];
      const thisUniqueId = endpoint.determineUniqueID();
      if (thisUniqueId === void 0) {
        endpointUniquePrefix += `${endpointUniquePrefix === "" ? "" : "-"}index_${endpointIndex}`;
      } else {
        endpointUniquePrefix += `${endpointUniquePrefix === "" ? "" : "-"}${thisUniqueId}`;
      }
      if (endpoint.number === void 0) {
        endpoint.number = EndpointNumber(this.nextEndpointId++);
        this.endpointStructureStorage.set(endpointUniquePrefix, endpoint.number);
        logger.debug(
          `Assigned endpoint id ${endpoint.number} for endpoint with ${endpointUniquePrefix} / device ${endpoint.name} and stored it`
        );
      }
      this.fillAndStoreEndpointIds(endpoint, endpointUniquePrefix);
    }
  }
  /**
   * Return info if the device is paired with at least one controller
   */
  isCommissioned() {
    return this.deviceInstance?.isCommissioned() ?? false;
  }
  /**
   * Return the pairing information for the device
   */
  getPairingCode(discoveryCapabilities) {
    const basicInformation = this.getRootClusterServer(BasicInformationCluster);
    if (basicInformation == void 0) {
      throw new ImplementationError("BasicInformationCluster needs to be set!");
    }
    const vendorId = basicInformation.attributes.vendorId.getLocal();
    const productId = basicInformation.attributes.productId.getLocal();
    let bleEnabled = false;
    try {
      bleEnabled = !!Ble.get();
    } catch (error) {
      NoProviderError.accept(error);
    }
    const qrPairingCode = QrPairingCodeCodec.encode([
      {
        version: 0,
        vendorId,
        productId,
        flowType: this.flowType,
        discriminator: this.discriminator,
        passcode: this.passcode,
        discoveryCapabilities: DiscoveryCapabilitiesSchema.encode(
          discoveryCapabilities ?? {
            ble: bleEnabled,
            onIpNetwork: true
          }
        )
      }
    ]);
    return {
      manualPairingCode: ManualPairingCodeCodec.encode({
        discriminator: this.discriminator,
        passcode: this.passcode
      }),
      qrPairingCode
    };
  }
  /**
   * Set the MDNS Scanner instance. Should be only used internally
   *
   * @param mdnsScanner MdnsScanner instance
   */
  setMdnsScanner(mdnsScanner) {
    this.mdnsScanner = mdnsScanner;
  }
  /**
   * Set the MDNS Broadcaster instance. Should be only used internally
   *
   * @param mdnsBroadcaster MdnsBroadcaster instance
   */
  setMdnsBroadcaster(mdnsBroadcaster) {
    if (this.port === void 0) {
      throw new ImplementationError("Port must be set before setting the MDNS broadcaster!");
    }
    this.mdnsBroadcaster = mdnsBroadcaster;
  }
  /**
   * Set the StorageManager instance. Should be only used internally
   * @param storage
   */
  async setStorage(storage) {
    this.storage = storage;
    this.endpointStructureStorage = this.storage.createContext("EndpointStructure");
    this.eventHandler = await EventHandler.create(this.storage.createContext("EventHandler"));
  }
  /**
   * Add a new device to the node
   *
   * @param device Device or Aggregator instance to add
   */
  addDevice(device) {
    this.addEndpoint(device);
  }
  /**
   * Return the port the device is listening on
   */
  getPort() {
    return this.port;
  }
  /** Set the port the device is listening on. Can only be called before the device is initialized. */
  setPort(port) {
    if (port === this.port) return;
    if (this.deviceInstance !== void 0 || this.mdnsInstanceBroadcaster !== void 0) {
      throw new ImplementationError("Port cannot be changed after device is initialized!");
    }
    this.port = port;
  }
  /**
   * Close network connections of the device and stop responding to requests
   */
  async close() {
    this.rootEndpoint.getClusterServer(BasicInformationCluster)?.triggerShutDownEvent?.();
    await this.interactionServer?.close();
    this.interactionServer = void 0;
    this.endpointStructure.close();
    await this.deviceInstance?.close();
    this.deviceInstance = void 0;
    await this.mdnsInstanceBroadcaster?.close();
    this.mdnsInstanceBroadcaster = void 0;
  }
  async factoryReset() {
    if (this.storage === void 0) {
      throw new ImplementationError(
        "Storage not initialized. The instance was not added to a Matter instance yet."
      );
    }
    const wasStarted = this.interactionServer !== void 0 || this.deviceInstance !== void 0;
    let fabrics = new Array();
    if (wasStarted) {
      fabrics = this.isCommissioned() ? this.deviceInstance?.getFabrics() ?? [] : [];
      await this.close();
    }
    this.storage.clearAll();
    if (wasStarted) {
      await this.advertise();
      fabrics.forEach((fabric) => this.options.commissioningChangedCallback?.(fabric.fabricIndex));
    }
    logger.info(`The device was factory reset${wasStarted ? " and restarted" : ""}.`);
  }
  /**
   * Add a new command handler for the given command
   *
   * @param command Command to add the handler for
   * @param handler Handler function to add
   */
  addCommandHandler(command, handler) {
    this.commandHandler.addHandler(command, handler);
  }
  /**
   * Remove a command handler for the given command
   *
   * @param command Command to remove the handler for
   * @param handler Handler function to remove
   */
  removeCommandHandler(command, handler) {
    this.commandHandler.removeHandler(command, handler);
  }
  /**
   * Set the reachability of the commissioning server aka "the main matter device". This call only has effect when
   * the reachability flag was set in the BasicInformationCluster or in the BasicInformation data in the constructor!
   *
   * @param reachable true if reachable, false otherwise
   */
  setReachability(reachable) {
    const basicInformationCluster = this.getRootClusterServer(BasicInformationCluster);
    if (basicInformationCluster === void 0) {
      throw new ImplementationError("BasicInformationCluster needs to be set!");
    }
    if (basicInformationCluster.attributes.reachable !== void 0) {
      basicInformationCluster.setReachableAttribute(reachable);
    }
  }
  /** used internally by MatterServer to initialize the state of the device. */
  initialize(ipv4Disabled) {
    if (this.ipv4Disabled !== void 0 && this.ipv4Disabled !== ipv4Disabled) {
      throw new ImplementationError(
        "Changing the IPv4 disabled flag after starting the device is not supported."
      );
    }
    this.ipv4Disabled = ipv4Disabled;
  }
  /** Starts the Matter device and advertises it. */
  async start() {
    if (this.ipv4Disabled === void 0) {
      throw new ImplementationError("Add the device to the MatterServer first.");
    }
    if (this.delayedAnnouncement !== true) {
      return this.advertise();
    }
  }
  /**
   * Get some basic details of all Fabrics the server is commissioned to.
   *
   * @param fabricIndex Optional fabric index to filter for. If not set all fabrics are returned.
   */
  getCommissionedFabricInformation(fabricIndex) {
    if (!this.isCommissioned()) return [];
    const allFabrics = this.deviceInstance?.getFabrics() ?? [];
    const fabrics = fabricIndex === void 0 ? allFabrics : allFabrics.filter((f) => f.fabricIndex === fabricIndex);
    return fabrics.map((fabric) => fabric.externalInformation) ?? [];
  }
  /**
   * Get some basic details of all currently active sessions.
   *
   * @param fabricIndex Optional fabric index to filter for. If not set all sessions are returned.
   */
  getActiveSessionInformation(fabricIndex) {
    if (!this.isCommissioned()) return [];
    const allSessions = this.deviceInstance?.getActiveSessionInformation() ?? [];
    return allSessions.filter(({ fabric }) => fabricIndex === void 0 || fabric?.fabricIndex === fabricIndex);
  }
}
class CommissioningServerClusterDatasource {
  #version;
  #clusterDescription;
  #storage;
  #eventHandler;
  #getFabrics;
  constructor(endpoint, cluster, storage, eventHandler, getFabrics) {
    this.#eventHandler = eventHandler;
    this.#clusterDescription = `cluster ${cluster.name} (${cluster.id})`;
    this.#storage = storage = storage.createContext(`Cluster-${endpoint.number}-${cluster.id}`);
    this.#getFabrics = getFabrics;
    this.#version = cluster.datasource?.version ?? Crypto.getRandomUInt32();
    for (const attributeName in cluster.attributes) {
      const attribute = cluster.attributes[attributeName];
      if (!attribute) {
        continue;
      }
      if (!this.#storage.has(attributeName)) continue;
      try {
        const value = storage.get(attributeName);
        logger.debug(`Restoring attribute ${attributeName} (${attribute.id}) in ${this.#clusterDescription}`);
        attribute.init(value);
      } catch (error) {
        logger.warn(
          `Failed to restore attribute ${attributeName} (${attribute.id}) in ${this.#clusterDescription}`,
          error
        );
        storage.delete(attribute.name);
      }
    }
    cluster.datasource = this;
  }
  get version() {
    return this.#version;
  }
  get eventHandler() {
    return this.#eventHandler;
  }
  get fabrics() {
    return this.#getFabrics();
  }
  increaseVersion() {
    if (this.#version === 4294967295) {
      this.#version = -1;
    }
    return ++this.#version;
  }
  changed(attributeName, value) {
    if (value === void 0) return;
    logger.debug(`Storing attribute ${attributeName} in ${this.#clusterDescription}`);
    this.#storage?.set(attributeName, value);
  }
}
export {
  CommissioningServer,
  FORBIDDEN_PASSCODES
};
//# sourceMappingURL=CommissioningServer.js.map
