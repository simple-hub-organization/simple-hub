/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ImplementationError, Logger } from "#general";
import {
  ControllerDiscovery,
  MdnsService
} from "#protocol";
import {
  configureNetwork as configureControllerNetwork
} from "./CommissioningController.js";
import { MatterController } from "./MatterController.js";
const logger = new Logger("PaseCommissioner");
class PaseCommissioner {
  /**
   * Creates a new CommissioningController instance
   *
   * @param options The options for the CommissioningController
   */
  constructor(options) {
    this.options = options;
    if (options.environment === void 0) {
      throw new ImplementationError("You need to prove an environment for the commissioner.");
    }
    const { environment } = options.environment;
    this.environment = environment;
  }
  environment;
  controllerInstance;
  get nodeId() {
    return this.controllerInstance?.nodeId;
  }
  assertControllerIsStarted(errorText) {
    if (this.controllerInstance === void 0) {
      throw new ImplementationError(
        errorText ?? "Controller instance not yet started. Please call start() first."
      );
    }
    return this.controllerInstance;
  }
  /** Internal method to initialize a MatterController instance. */
  async initializeController() {
    if (this.controllerInstance !== void 0) {
      return this.controllerInstance;
    }
    const { certificateAuthorityConfig: rootCertificateData, fabricConfig } = this.options;
    let mdnsScanner;
    let ipv4Disabled = false;
    try {
      const mdnsService = await this.environment.load(MdnsService);
      ipv4Disabled = !mdnsService.enableIpv4;
      mdnsScanner = mdnsService.scanner;
    } catch {
      logger.debug("No networking available, using only BLE");
    }
    const { scanners, netInterfaces } = await configureControllerNetwork({
      mdnsScanner,
      ipv4Disabled,
      ...this.options
    });
    return await MatterController.createAsPaseCommissioner({
      certificateAuthorityConfig: rootCertificateData,
      fabricConfig,
      scanners,
      netInterfaces
    });
  }
  /**
   * Commissions/Pairs a new device into the controller fabric. The method returns the NodeId of the commissioned node.
   *
   * Use the connectNodeAfterCommissioning callback to implement an own logic to do the operative device discovery and
   * to complete the commissioning process.
   * Return true when the commissioning process is completed successfully, false on error.
   */
  async commissionNode(nodeOptions, completeCommissioningCallback) {
    const controller = this.assertControllerIsStarted();
    return await controller.commission(nodeOptions, completeCommissioningCallback);
  }
  /** Disconnects all connected nodes and Closes the network connections and other resources of the controller. */
  async close() {
    await this.controllerInstance?.close();
    this.controllerInstance = void 0;
  }
  /** Initialize the controller. */
  async start() {
    const runtime = this.environment.runtime;
    runtime.add(this);
    if (this.controllerInstance === void 0) {
      this.controllerInstance = await this.initializeController();
    }
  }
  cancelCommissionableDeviceDiscovery(identifierData, discoveryCapabilities) {
    const controller = this.assertControllerIsStarted();
    controller.collectScanners(discoveryCapabilities).forEach(
      (scanner) => ControllerDiscovery.cancelCommissionableDeviceDiscovery(scanner, identifierData)
    );
  }
  async discoverCommissionableDevices(identifierData, discoveryCapabilities, discoveredCallback, timeoutSeconds = 900) {
    const controller = this.assertControllerIsStarted();
    return await ControllerDiscovery.discoverCommissionableDevices(
      controller.collectScanners(discoveryCapabilities),
      timeoutSeconds,
      identifierData,
      discoveredCallback
    );
  }
}
export {
  PaseCommissioner
};
//# sourceMappingURL=PaseCommissioner.js.map
