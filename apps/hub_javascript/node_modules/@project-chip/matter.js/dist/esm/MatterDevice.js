/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  Construction,
  InternalError,
  ObserverGroup,
  TransportInterfaceSet,
  asyncNew
} from "#general";
import {
  ChannelManager,
  CommissioningConfigProvider,
  DeviceAdvertiser,
  DeviceCommissioner,
  ExchangeManager,
  FabricAction,
  FabricManager,
  SecureChannelProtocol,
  SessionManager
} from "#protocol";
class MatterDevice {
  constructor(sessionStorage, fabricStorage, getCommissioningConfig, minimumCaseSessionsPerFabricAndNode, commissioningChangedCallback, sessionChangedCallback, sessionParameters = {}) {
    this.sessionStorage = sessionStorage;
    this.fabricStorage = fabricStorage;
    this.commissioningChangedCallback = commissioningChangedCallback;
    this.sessionChangedCallback = sessionChangedCallback;
    this.#channelManager = new ChannelManager(minimumCaseSessionsPerFabricAndNode);
    this.#fabricManager = new FabricManager(fabricStorage);
    this.#observers.on(
      this.#fabricManager.events.deleted,
      async ({ fabricIndex }) => this.commissioningChangedCallback(fabricIndex, FabricAction.Removed)
    );
    this.#observers.on(
      this.#fabricManager.events.updated,
      ({ fabricIndex }) => this.commissioningChangedCallback(fabricIndex, FabricAction.Updated)
    );
    this.#sessionManager = new SessionManager({
      fabrics: this.#fabricManager,
      storage: sessionStorage,
      parameters: sessionParameters,
      owner: this
    });
    this.#transportInterfaces = new TransportInterfaceSet();
    this.#exchangeManager = new ExchangeManager({
      transportInterfaces: this.#transportInterfaces,
      sessionManager: this.#sessionManager,
      channelManager: this.#channelManager
    });
    const secureChannelProtocol = new SecureChannelProtocol(this.#sessionManager, this.#fabricManager);
    this.#exchangeManager.addProtocolHandler(secureChannelProtocol);
    this.#observers.on(this.#sessionManager.sessions.added, (session) => {
      if (session.fabric) {
        this.sessionChangedCallback(session.fabric.fabricIndex);
      }
    });
    this.#observers.on(this.#sessionManager.sessions.deleted, async (session) => {
      const currentFabricIndex = session.fabric?.fabricIndex;
      if (currentFabricIndex !== void 0) {
        this.sessionChangedCallback(currentFabricIndex);
      }
    });
    this.#observers.on(this.#sessionManager.subscriptionsChanged, (session, _subscription) => {
      const currentFabric = session.fabric;
      if (currentFabric !== void 0) {
        this.sessionChangedCallback(currentFabric.fabricIndex);
      }
    });
    this.#advertiser = new DeviceAdvertiser({
      fabrics: this.fabricManager,
      sessions: this.sessionManager
    });
    this.#commissioner = new DeviceCommissioner({
      fabrics: this.fabricManager,
      sessions: this.sessionManager,
      advertiser: this.#advertiser,
      secureChannelProtocol,
      commissioningConfig: new class extends CommissioningConfigProvider {
        get values() {
          return getCommissioningConfig();
        }
      }()
    });
    this.#construction = Construction(this, async () => {
      await this.#fabricManager.construction.ready;
      this.#observers.on(
        this.#fabricManager.events.added,
        ({ fabricIndex }) => this.commissioningChangedCallback(fabricIndex, FabricAction.Added)
      );
      await this.#sessionManager.construction.ready;
    });
  }
  #exchangeManager;
  #fabricManager;
  #sessionManager;
  #commissioner;
  #advertiser;
  #transportInterfaces;
  #channelManager;
  #observers = new ObserverGroup();
  #isClosing = false;
  #construction;
  get construction() {
    return this.#construction;
  }
  static async create(sessionStorage, fabricStorage, getCommissioningConfig, minimumCaseSessionsPerFabricAndNode = 3, commissioningChangedCallback, sessionChangedCallback, sessionParameters) {
    return asyncNew(
      MatterDevice,
      sessionStorage,
      fabricStorage,
      getCommissioningConfig,
      minimumCaseSessionsPerFabricAndNode,
      commissioningChangedCallback,
      sessionChangedCallback,
      sessionParameters
    );
  }
  get fabricManager() {
    return this.#fabricManager;
  }
  get sessionManager() {
    return this.#sessionManager;
  }
  get exchangeManager() {
    return this.#exchangeManager;
  }
  get advertiser() {
    return this.#advertiser;
  }
  get commissioner() {
    return this.#commissioner;
  }
  get failsafeContext() {
    return this.#commissioner.failsafeContext;
  }
  get isClosing() {
    return this.#isClosing;
  }
  async beginTimed(failsafeContext) {
    return this.#commissioner.beginTimed(failsafeContext);
  }
  assertFailSafeArmed(message) {
    return this.#commissioner.assertFailsafeArmed(message);
  }
  isFailsafeArmed() {
    return this.#commissioner.isFailsafeArmed;
  }
  hasBroadcaster(broadcaster) {
    return this.#advertiser.hasBroadcaster(broadcaster);
  }
  addBroadcaster(broadcaster) {
    this.#advertiser.addBroadcaster(broadcaster);
    return this;
  }
  async deleteBroadcaster(broadcaster) {
    return this.#advertiser.deleteBroadcaster(broadcaster);
  }
  addTransportInterface(transport) {
    this.#transportInterfaces.add(transport);
    return this;
  }
  async deleteTransportInterface(transport) {
    this.#transportInterfaces.delete(transport);
  }
  hasProtocolHandler(protocolId) {
    return this.exchangeManager.hasProtocolHandler(protocolId);
  }
  addProtocolHandler(protocol) {
    this.exchangeManager.addProtocolHandler(protocol);
    return this;
  }
  async start() {
    await this.startAnnouncement();
  }
  async startAnnouncement() {
    return this.#advertiser.startAdvertising();
  }
  async announce(announceOnce = false) {
    return this.#advertiser.advertise(announceOnce);
  }
  reAnnounceAsCommissionable() {
    this.#commissioner.reactivateAdvertiser();
  }
  findFabricFromDestinationId(destinationId, peerRandom) {
    return this.#fabricManager.findFabricFromDestinationId(destinationId, peerRandom);
  }
  async sendFabricAnnouncements(fabrics, expireCommissioningAnnouncement = false) {
    return this.#advertiser.advertiseFabrics(fabrics, expireCommissioningAnnouncement);
  }
  getFabricByIndex(fabricIndex) {
    return this.#fabricManager.findByIndex(fabricIndex);
  }
  initiateExchange(address, protocolId) {
    return this.#exchangeManager.initiateExchange(address, protocolId);
  }
  getFabrics() {
    return this.#fabricManager.fabrics;
  }
  isCommissioned() {
    return !!this.#fabricManager.length;
  }
  async allowEnhancedCommissioning(discriminator, paseServer, commissioningEndCallback) {
    return this.#commissioner.allowEnhancedCommissioning(discriminator, paseServer, commissioningEndCallback);
  }
  async allowBasicCommissioning(commissioningEndCallback) {
    return this.#commissioner.allowBasicCommissioning(commissioningEndCallback);
  }
  async endCommissioning() {
    return this.#commissioner.endCommissioning();
  }
  existsOpenPaseSession() {
    return !!this.#sessionManager.getPaseSession();
  }
  async close() {
    this.#isClosing = true;
    this.#observers.close();
    await this.#commissioner.close();
    await this.#advertiser.close();
    await this.exchangeManager.close();
    await this.#sessionManager.close();
    await this.#channelManager.close();
    await this.#transportInterfaces.close();
  }
  getActiveSessionInformation() {
    return this.#sessionManager.getActiveSessionInformation();
  }
  static of(session) {
    if (session === void 0) {
      throw new InternalError("Device operation without session");
    }
    const device = session.owner;
    if (!(device instanceof MatterDevice)) {
      throw new InternalError("Device operation on non-device session");
    }
    return device;
  }
}
export {
  MatterDevice
};
//# sourceMappingURL=MatterDevice.js.map
