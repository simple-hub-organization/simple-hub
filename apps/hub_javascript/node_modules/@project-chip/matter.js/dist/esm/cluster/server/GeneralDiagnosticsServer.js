/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { GeneralDiagnostics, GeneralDiagnosticsCluster } from "#clusters";
import {
  Bytes,
  ipv4ToBytes,
  ipv6ToBytes,
  Network,
  NotImplementedError,
  Time
} from "#general";
import { WrapCommandHandler } from "../../device/Device.js";
import { ClusterServer } from "./ClusterServer.js";
const GeneralDiagnosticsClusterHandler = async () => {
  let bootUpTime = 0;
  let totalOperationalHoursAttribute = void 0;
  const totalOperationalHoursUpdateTimer = Time.getPeriodicTimer(
    "GeneralDiagnosticsCluster.totalOperationalHoursUpdate",
    60 * 601e3,
    () => {
      if (totalOperationalHoursAttribute === void 0) return;
      totalOperationalHoursAttribute.setLocal(totalOperationalHoursAttribute.getLocal() + 1);
    }
  );
  const network = Network.get();
  const interfaces = await network.getNetInterfaces();
  const interfaceDetails = new Array();
  for (const { name, type } of interfaces) {
    const details = await network.getIpMac(name);
    if (details !== void 0) {
      interfaceDetails.push({ name, type, ...details });
    }
  }
  return {
    initializeClusterServer: ({ attributes: { totalOperationalHours, networkInterfaces } }) => {
      bootUpTime = Time.nowMs();
      if (totalOperationalHours?.getLocal() !== void 0) {
        totalOperationalHoursAttribute = totalOperationalHours;
        totalOperationalHoursUpdateTimer.start();
      }
      networkInterfaces.setLocal(
        interfaceDetails.filter(({ mac }) => mac !== "00:00:00:00:00:00").slice(0, 8).map(({ name, mac, ipV4, ipV6, type }) => ({
          name: name.substring(0, 32),
          isOperational: true,
          offPremiseServicesReachableIPv4: null,
          // null means unknown or not supported
          offPremiseServicesReachableIPv6: null,
          // null means unknown or not supported
          hardwareAddress: Bytes.fromHex(mac.replace(/[^\da-fA-F]/g, "")),
          iPv4Addresses: ipV4.slice(0, 4).map((ip) => ipv4ToBytes(ip)),
          iPv6Addresses: ipV6.slice(0, 8).map((ip) => ipv6ToBytes(ip)),
          type: type ?? GeneralDiagnostics.InterfaceType.Ethernet
        }))
      );
    },
    destroyClusterServer: () => {
      totalOperationalHoursUpdateTimer.stop();
    },
    upTimeAttributeGetter: () => {
      return Math.round((Time.nowMs() - bootUpTime) / 1e3);
    },
    testEventTrigger: () => {
    },
    timeSnapshot: () => {
      throw new NotImplementedError();
    }
  };
};
const createDefaultGeneralDiagnosticsClusterServer = async (commandHandler) => ClusterServer(
  GeneralDiagnosticsCluster,
  {
    networkInterfaces: [],
    rebootCount: 0,
    upTime: 0,
    totalOperationalHours: 0,
    bootReason: GeneralDiagnostics.BootReason.Unspecified,
    activeHardwareFaults: [],
    activeRadioFaults: [],
    activeNetworkFaults: [],
    testEventTriggersEnabled: false
  },
  WrapCommandHandler(await GeneralDiagnosticsClusterHandler(), commandHandler),
  {
    bootReason: true
  }
);
export {
  GeneralDiagnosticsClusterHandler,
  createDefaultGeneralDiagnosticsClusterServer
};
//# sourceMappingURL=GeneralDiagnosticsServer.js.map
