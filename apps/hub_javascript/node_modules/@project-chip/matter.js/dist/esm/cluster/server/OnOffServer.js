/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { OnOff } from "#clusters";
import { NotImplementedError, Time } from "#general";
import { WrapCommandHandler } from "../../device/Device.js";
import { ClusterServer } from "./ClusterServer.js";
const Cluster = OnOff.Cluster.with("Lighting");
const OnOffClusterDefaultHandler = () => {
  let timedOnTimer;
  let delayedOffTimer;
  const getTimedOnTimer = (onTime, onOff) => {
    if (timedOnTimer === void 0) {
      timedOnTimer = Time.getPeriodicTimer("Delayed on", 100, () => {
        let time = onTime.getLocal() ?? 0 - 0.1;
        if (time <= 0) {
          time = 0;
          timedOnTimer?.stop();
          onOff.setLocal(false);
        }
        onTime.setLocal(time);
      });
    }
    return timedOnTimer;
  };
  const getDelayedOffTimer = (offWaitTime) => {
    if (delayedOffTimer === void 0) {
      delayedOffTimer = Time.getTimer("Delayed off", 100, () => {
        let time = offWaitTime.getLocal() ?? 0 - 0.1;
        if (time <= 0) {
          time = 0;
          delayedOffTimer?.stop();
        }
        offWaitTime.setLocal(time);
      });
    }
    return delayedOffTimer;
  };
  return {
    initializeClusterServer: ({ attributes: { onOff, startUpOnOff } }) => {
      const startUpOnOffValue = startUpOnOff?.getLocal() ?? null;
      if (startUpOnOffValue !== null) {
        const currentOnOffStatus = onOff.getLocal();
        const targetOnOffValue = startUpOnOffValue === OnOff.StartUpOnOff.Toggle ? !currentOnOffStatus : startUpOnOffValue === OnOff.StartUpOnOff.On;
        if (targetOnOffValue !== currentOnOffStatus) {
          onOff.setLocal(targetOnOffValue);
        }
      }
    },
    destroyClusterServer: () => {
      timedOnTimer?.stop();
      delayedOffTimer?.stop();
    },
    on: async ({ attributes: { onOff } }) => {
      onOff.setLocal(true);
    },
    off: async ({ attributes: { onOff } }) => {
      onOff.setLocal(false);
    },
    toggle: async ({ attributes: { onOff } }) => {
      if (onOff.getLocal()) {
        onOff.setLocal(false);
      } else {
        onOff.setLocal(true);
      }
    },
    offWithEffect: async () => {
      throw new NotImplementedError("Not implemented");
    },
    onWithRecallGlobalScene: async () => {
      throw new NotImplementedError("Not implemented");
    },
    onWithTimedOff: async ({
      request: { onOffControl, onTime: reqOnTime, offWaitTime: reqOffWaitTime },
      attributes: { onOff, onTime, offWaitTime }
    }) => {
      if (onTime === void 0 || offWaitTime === void 0) return;
      const timedOnTimer2 = getTimedOnTimer(onTime, onOff);
      const delayedOffTimer2 = getDelayedOffTimer(offWaitTime);
      const onOffState = onOff.getLocal();
      if (!onOffState && onOffControl.acceptOnlyWhenOn) {
        return;
      }
      if (delayedOffTimer2.isRunning && !onOffState) {
        offWaitTime.setLocal(Math.min(reqOffWaitTime ?? 0, offWaitTime.getLocal() ?? 0));
        delayedOffTimer2.start();
        timedOnTimer2.stop();
      } else {
        onTime.setLocal(Math.max(reqOnTime ?? 0, onTime.getLocal() ?? 0));
        offWaitTime.setLocal(reqOffWaitTime);
        timedOnTimer2.start();
        delayedOffTimer2.stop();
      }
    }
  };
};
const createDefaultOnOffClusterServer = (commandHandler, attributeInitialValues, isLighting = false) => {
  if (isLighting) {
    return ClusterServer(
      OnOff.Cluster.with(OnOff.Feature.Lighting),
      {
        onOff: false,
        globalSceneControl: false,
        onTime: 0,
        offWaitTime: 0,
        startUpOnOff: null,
        ...attributeInitialValues
      },
      WrapCommandHandler(OnOffClusterDefaultHandler(), commandHandler)
    );
  }
  return ClusterServer(
    OnOff.Cluster,
    {
      onOff: false,
      ...attributeInitialValues
    },
    WrapCommandHandler(
      OnOffClusterDefaultHandler(),
      commandHandler
    )
  );
};
export {
  OnOffClusterDefaultHandler,
  createDefaultOnOffClusterServer
};
//# sourceMappingURL=OnOffServer.js.map
