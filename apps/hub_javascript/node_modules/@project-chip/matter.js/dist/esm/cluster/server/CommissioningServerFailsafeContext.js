/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { BasicInformation, GeneralCommissioning, NetworkCommissioning, OperationalCredentials } from "#clusters";
import { asyncNew } from "#general";
import { FailsafeContext } from "#protocol";
class CommissioningServerFailsafeContext extends FailsafeContext {
  #rootEndpoint;
  #storedNetworkClusterState = /* @__PURE__ */ new Map();
  constructor(rootEndpoint, options) {
    super(options);
    this.#rootEndpoint = rootEndpoint;
  }
  static async create(rootEndpoint, options) {
    return asyncNew(this, rootEndpoint, options);
  }
  async storeEndpointState() {
    await this.#storeEndpointState(this.#rootEndpoint);
  }
  async restoreFabric(fabric) {
    await super.restoreFabric(fabric);
    const operationalCredentialsCluster = this.#rootEndpoint.getClusterServer(OperationalCredentials.Cluster);
    operationalCredentialsCluster?.attributes.nocs.updatedLocalForFabric(fabric);
    operationalCredentialsCluster?.attributes.fabrics.updatedLocalForFabric(fabric);
  }
  async restoreNetworkState() {
    await this.#restoreEndpointState(this.#rootEndpoint);
  }
  async revokeFabric(fabric) {
    const basicInformationCluster = this.#rootEndpoint.getClusterServer(BasicInformation.Cluster);
    basicInformationCluster?.triggerLeaveEvent?.({ fabricIndex: fabric.fabricIndex });
    await fabric.remove();
    const operationalCredentialsCluster = this.#rootEndpoint.getClusterServer(OperationalCredentials.Cluster);
    operationalCredentialsCluster?.attributes.nocs.updatedLocalForFabric(fabric);
    operationalCredentialsCluster?.attributes.commissionedFabrics.updatedLocal();
    operationalCredentialsCluster?.attributes.fabrics.updatedLocalForFabric(fabric);
    operationalCredentialsCluster?.attributes.trustedRootCertificates.updatedLocal();
  }
  async restoreBreadcrumb() {
    const generalCommissioningCluster = this.#rootEndpoint.getClusterServer(GeneralCommissioning.Cluster);
    generalCommissioningCluster?.setBreadcrumbAttribute(0);
  }
  async #storeEndpointState(endpoint) {
    const networkCluster = endpoint.getClusterServer(NetworkCommissioning.Complete);
    if (networkCluster !== void 0) {
      this.#storedNetworkClusterState.set(endpoint.getNumber(), networkCluster.getNetworksAttribute());
    }
    for (const childEndpoint of endpoint.getChildEndpoints()) {
      await this.#storeEndpointState(childEndpoint);
    }
  }
  async #restoreEndpointState(endpoint) {
    const endpointId = endpoint.getNumber();
    const networkState = this.#storedNetworkClusterState.get(endpointId);
    if (networkState !== void 0) {
      const networkCluster = endpoint.getClusterServer(NetworkCommissioning.Complete);
      if (networkCluster !== void 0) {
        networkCluster.setNetworksAttribute(networkState);
      }
      this.#storedNetworkClusterState.delete(endpointId);
    }
    for (const childEndpoint of endpoint.getChildEndpoints()) {
      await this.#restoreEndpointState(childEndpoint);
    }
  }
}
export {
  CommissioningServerFailsafeContext
};
//# sourceMappingURL=CommissioningServerFailsafeContext.js.map
