/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { GroupsCluster, IdentifyCluster } from "#clusters";
import { assertSecureSession } from "#protocol";
import { StatusCode } from "#types";
import { ClusterServer } from "./ClusterServer.js";
class GroupsManager {
  static async setGroup(fabric, endpointId, groupId, groupName) {
    let endpointGroups = fabric.getScopedClusterDataValue(
      GroupsCluster,
      endpointId.toString()
    );
    if (endpointGroups === void 0) {
      endpointGroups = /* @__PURE__ */ new Map();
    }
    endpointGroups.set(groupId, groupName || "");
    await fabric.setScopedClusterDataValue(GroupsCluster, endpointId.toString(), endpointGroups);
  }
  static getGroupName(fabric, endpointId, groupId) {
    const endpointGroups = fabric.getScopedClusterDataValue(
      GroupsCluster,
      endpointId.toString()
    );
    return endpointGroups?.get(groupId);
  }
  static hasGroup(fabric, endpointId, groupId) {
    const endpointGroups = fabric.getScopedClusterDataValue(
      GroupsCluster,
      endpointId.toString()
    );
    return endpointGroups?.has(groupId) ?? false;
  }
  static getGroups(fabric, endpointId) {
    return fabric.getScopedClusterDataValue(GroupsCluster, endpointId.toString()) ?? /* @__PURE__ */ new Map();
  }
  static async removeGroup(fabric, endpointId, groupId) {
    const endpointGroups = fabric.getScopedClusterDataValue(
      GroupsCluster,
      endpointId.toString()
    );
    if (endpointGroups !== void 0) {
      if (endpointGroups.delete(groupId)) {
        await fabric.persist(false);
        return true;
      }
    }
    return false;
  }
  static async removeAllGroups(fabric, endpointId) {
    await fabric.deleteScopedClusterDataValue(GroupsCluster, endpointId.toString());
  }
}
const GroupsClusterHandler = () => {
  const addGroupLogic = async (groupId, groupName, fabric, endpointId) => {
    if (groupId < 1) {
      return { status: StatusCode.ConstraintError, groupId };
    }
    if (groupName.length > 16) {
      return { status: StatusCode.ConstraintError, groupId };
    }
    await GroupsManager.setGroup(fabric, endpointId, groupId, groupName);
    return { status: StatusCode.Success, groupId };
  };
  return {
    addGroup: async ({ request: { groupId, groupName }, session, endpoint }) => {
      assertSecureSession(session);
      return addGroupLogic(groupId, groupName, session.associatedFabric, endpoint.getNumber());
    },
    viewGroup: async ({ request: { groupId }, session, endpoint }) => {
      if (groupId < 1) {
        return { status: StatusCode.ConstraintError, groupId, groupName: "" };
      }
      assertSecureSession(session);
      const groupName = GroupsManager.getGroupName(session.associatedFabric, endpoint.getNumber(), groupId);
      if (groupName !== void 0) {
        return { status: StatusCode.Success, groupId, groupName };
      }
      return { status: StatusCode.NotFound, groupId, groupName: "" };
    },
    getGroupMembership: async ({ request: { groupList }, session, endpoint }) => {
      assertSecureSession(session);
      const endpointGroups = GroupsManager.getGroups(session.associatedFabric, endpoint.getNumber());
      const fabricGroupsList = Array.from(endpointGroups.keys());
      const capacity = fabricGroupsList.length < 255 ? 254 - fabricGroupsList.length : 0;
      if (groupList.length === 0) {
        return { capacity, groupList: fabricGroupsList };
      }
      const filteredGroupsList = groupList.filter((groupId) => endpointGroups.get(groupId));
      if (filteredGroupsList.length === 0) {
        return { capacity, groupList: [] };
      }
      return { capacity, groupList: filteredGroupsList };
    },
    removeGroup: async ({ request: { groupId }, session, endpoint }) => {
      if (groupId < 1) {
        return { status: StatusCode.ConstraintError, groupId };
      }
      assertSecureSession(session);
      if (await GroupsManager.removeGroup(session.associatedFabric, endpoint.getNumber(), groupId)) {
        return { status: StatusCode.Success, groupId };
      }
      return { status: StatusCode.NotFound, groupId };
    },
    removeAllGroups: async ({ session, endpoint }) => {
      assertSecureSession(session);
      const fabric = session.associatedFabric;
      await GroupsManager.removeAllGroups(fabric, endpoint.getNumber());
      return;
    },
    addGroupIfIdentifying: async ({ request: { groupId, groupName }, session, endpoint }) => {
      const identifyCluster = endpoint.getClusterServer(IdentifyCluster);
      if (identifyCluster) {
        if (identifyCluster.attributes.identifyTime.getLocal() > 0) {
          assertSecureSession(session);
          await addGroupLogic(groupId, groupName, session.associatedFabric, endpoint.getNumber());
        }
      }
    }
  };
};
const createDefaultGroupsClusterServer = () => ClusterServer(
  GroupsCluster,
  {
    nameSupport: {
      nameSupport: true
    }
  },
  GroupsClusterHandler()
);
export {
  GroupsClusterHandler,
  GroupsManager,
  createDefaultGroupsClusterServer
};
//# sourceMappingURL=GroupsServer.js.map
