/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { capitalize, ImplementationError, InternalError, Logger, MaybePromise } from "#general";
import { AccessLevel } from "#model";
import {
  CommandServer,
  createAttributeServer,
  createEventServer
} from "#protocol";
import {
  AttributeId,
  TlvNoResponse
} from "#types";
const logger = Logger.get("ClusterServer");
function isConditionMatching(featureSets, supportedFeatures) {
  for (const features of featureSets) {
    if (Object.keys(features).every((feature) => !!features[feature] === !!supportedFeatures[feature])) {
      return true;
    }
  }
  return false;
}
function ClusterServer(clusterDef, attributesInitialValues, handlers, supportedEvents = {}, ignoreMissingElements = false) {
  const {
    id: clusterId,
    name,
    commands: commandDef,
    attributes: attributeDef,
    events: eventDef,
    supportedFeatures
  } = clusterDef;
  let datasource;
  const sceneAttributeList = new Array();
  const attributes = {};
  const commands = {};
  const events = {};
  let assignedEndpoint = void 0;
  const datasourceProxy = {
    get version() {
      return datasource?.version ?? 0;
    },
    get eventHandler() {
      return datasource?.eventHandler;
    },
    get fabrics() {
      return datasource?.fabrics ?? [];
    },
    increaseVersion() {
      return datasource?.increaseVersion() ?? 0;
    },
    changed(key, value) {
      datasource?.changed(key, value);
    }
  };
  const result = {
    id: clusterId,
    name,
    _type: "ClusterServer",
    attributes,
    commands,
    events,
    get datasource() {
      return datasource;
    },
    set datasource(newDatasource) {
      if (newDatasource === void 0) {
        throw new InternalError("Cluster datasource cannot be unset");
      }
      datasource = newDatasource;
      if (assignedEndpoint === void 0) {
        throw new InternalError(
          "The Endpoint always needs to be existing before storage is initialized for an Endpoint."
        );
      }
      if (typeof handlers.initializeClusterServer === "function") {
        handlers.initializeClusterServer({
          attributes,
          events,
          endpoint: assignedEndpoint
        });
      }
      if (datasource.eventHandler) {
        for (const eventName in events) {
          const bindResult = events[eventName].bindToEventHandler(datasource.eventHandler);
          if (bindResult !== void 0 && MaybePromise.is(bindResult)) {
            throw new InternalError("Binding events to event handler should never return a promise");
          }
        }
      }
    },
    _assignToEndpoint: (endpoint) => {
      for (const name2 in attributes) {
        attributes[name2].assignToEndpoint(endpoint);
      }
      for (const name2 in events) {
        events[name2].assignToEndpoint(endpoint);
      }
      assignedEndpoint = endpoint;
    },
    _close: () => {
      if (typeof handlers.destroyClusterServer === "function") {
        handlers.destroyClusterServer();
      }
    },
    isAttributeSupported: (attributeId) => {
      return attributes.attributeList.getLocal().includes(attributeId);
    },
    isAttributeSupportedByName: (attributeName) => {
      return attributesInitialValues[attributeName] !== void 0;
    },
    isEventSupported: (eventId) => {
      return eventList.includes(eventId);
    },
    isEventSupportedByName: (eventName) => {
      return supportedEvents[eventName] === true;
    },
    isCommandSupported: (commandId) => {
      return attributes.acceptedCommandList.getLocal().includes(commandId);
    },
    isCommandSupportedByName: (commandName) => {
      return commands[commandName] !== void 0;
    }
  };
  attributesInitialValues = {
    ...attributesInitialValues,
    clusterRevision: clusterDef.revision,
    featureMap: supportedFeatures,
    attributeList: new Array(),
    acceptedCommandList: new Array(),
    generatedCommandList: new Array()
  };
  const attributeList = new Array();
  for (const attributeName in attributeDef) {
    const capitalizedAttributeName = capitalize(attributeName);
    if (attributeDef[attributeName].isConditional) {
      const { mandatoryIf, optionalIf } = attributeDef[attributeName];
      let conditionHasMatched = false;
      if (mandatoryIf !== void 0 && mandatoryIf.length > 0) {
        const conditionMatched = isConditionMatching(mandatoryIf, supportedFeatures);
        if (conditionMatched && attributesInitialValues[attributeName] === void 0) {
          logger.warn(
            `InitialAttributeValue for "${clusterDef.name}/${attributeName}" is REQUIRED by supportedFeatures: ${Logger.toJSON(
              supportedFeatures
            )} but is not set!`
          );
        }
        conditionHasMatched = conditionHasMatched || conditionMatched;
      }
      if (!conditionHasMatched && optionalIf !== void 0 && optionalIf.length > 0) {
        const conditionMatched = isConditionMatching(optionalIf, supportedFeatures);
        if (conditionMatched && attributesInitialValues[attributeName] === void 0) {
          logger.debug(
            `InitialAttributeValue for "${clusterDef.name}/${attributeName}" is optional by supportedFeatures: ${Logger.toJSON(
              supportedFeatures
            )} and is not set!`
          );
        }
        conditionHasMatched = conditionHasMatched || conditionMatched;
      }
      if (!conditionHasMatched && attributesInitialValues[attributeName] !== void 0) {
        logger.warn(
          `InitialAttributeValue for "${clusterDef.name}/${attributeName}" is provided but it's neither optional or mandatory for supportedFeatures: ${Logger.toJSON(
            supportedFeatures
          )} but is set!`
        );
      }
    }
    const { id, persistent, fabricScoped, scene, fixed } = attributeDef[attributeName];
    if (attributesInitialValues[attributeName] !== void 0) {
      const getter = handlers[`${attributeName}AttributeGetter`];
      const setter = handlers[`${attributeName}AttributeSetter`];
      const validator = handlers[`${attributeName}AttributeValidator`];
      attributes[attributeName] = createAttributeServer(
        clusterDef,
        attributeDef[attributeName],
        attributeName,
        attributesInitialValues[attributeName],
        datasourceProxy,
        getter ? (session, endpoint, isFabricFiltered, message) => getter({
          attributes,
          endpoint,
          session,
          isFabricFiltered,
          message
        }) : void 0,
        setter ? (value, session, endpoint, message) => setter(value, {
          attributes,
          endpoint,
          session,
          message
        }) : void 0,
        validator ? (value, session, endpoint) => validator(value, {
          attributes,
          endpoint,
          session
        }) : void 0
      );
      if (fixed) {
        result[`get${capitalizedAttributeName}Attribute`] = () => attributes[attributeName].getLocal();
      } else if (fabricScoped) {
        result[`get${capitalizedAttributeName}Attribute`] = (fabric) => attributes[attributeName].getLocalForFabric(fabric);
        result[`set${capitalizedAttributeName}Attribute`] = (value, fabric) => attributes[attributeName].setLocalForFabric(value, fabric);
        result[`subscribe${capitalizedAttributeName}Attribute`] = (listener) => attributes[attributeName].addValueSetListener(listener);
      } else {
        if (scene) {
          sceneAttributeList.push(attributeName);
        }
        result[`get${capitalizedAttributeName}Attribute`] = () => attributes[attributeName].getLocal();
        result[`set${capitalizedAttributeName}Attribute`] = (value) => attributes[attributeName].setLocal(value);
        result[`subscribe${capitalizedAttributeName}Attribute`] = (listener) => attributes[attributeName].addValueSetListener(listener);
      }
      if (persistent || getter || setter) {
        const listener = (value) => datasource?.changed(attributeName, fabricScoped || getter || setter ? void 0 : value);
        attributes[attributeName].addValueChangeListener(listener);
      }
      attributeList.push(AttributeId(id));
    } else {
      result[`get${capitalizedAttributeName}Attribute`] = () => void 0;
      if (!fixed) {
        result[`set${capitalizedAttributeName}Attribute`] = () => {
          throw new ImplementationError(
            `Attribute ${attributeName} is optional and not initialized. To use it please initialize it first.`
          );
        };
        result[`subscribe${capitalizedAttributeName}Attribute`] = () => {
          throw new ImplementationError(
            `Attribute ${attributeName} is optional and not initialized. To use it please initialize it first.`
          );
        };
      }
    }
  }
  attributes.attributeList.setLocal(attributeList.sort((a, b) => a - b));
  const acceptedCommandList = new Array();
  const generatedCommandList = new Array();
  for (const name2 in commandDef) {
    const handler = handlers[name2];
    if (commandDef[name2].isConditional) {
      const { mandatoryIf, optionalIf } = commandDef[name2];
      let conditionHasMatched = false;
      if (mandatoryIf !== void 0 && mandatoryIf.length > 0) {
        const conditionMatched = isConditionMatching(mandatoryIf, supportedFeatures);
        if (conditionMatched && handler === void 0) {
          logger.warn(
            `Command "${clusterDef.name}/${name2}" is REQUIRED by supportedFeatures: ${Logger.toJSON(
              supportedFeatures
            )} but is not set!`
          );
        }
        conditionHasMatched = conditionHasMatched || conditionMatched;
      }
      if (!conditionHasMatched && optionalIf !== void 0 && optionalIf.length > 0) {
        const conditionMatched = isConditionMatching(optionalIf, supportedFeatures);
        if (conditionMatched && handler === void 0) {
          logger.debug(
            `Command "${clusterDef.name}/${name2}" is optional by supportedFeatures: ${Logger.toJSON(
              supportedFeatures
            )} and is not set!`
          );
        }
        conditionHasMatched = conditionHasMatched || conditionMatched;
      }
      if (!conditionHasMatched && handler !== void 0) {
        logger.warn(
          `Command "${clusterDef.name}/${name2}" is provided but it's neither optional nor mandatory for supportedFeatures: ${Logger.toJSON(
            supportedFeatures
          )} but is set!`
        );
      }
    }
    if (handler === void 0) continue;
    const { requestId, requestSchema, responseId, responseSchema, timed, invokeAcl } = commandDef[name2];
    commands[name2] = new CommandServer(
      requestId,
      responseId,
      name2,
      requestSchema,
      responseSchema,
      timed,
      invokeAcl ?? AccessLevel.Operate,
      //????
      (request, session, message, endpoint) => handler({
        request,
        attributes,
        events,
        session,
        message,
        endpoint
      })
    );
    if (!acceptedCommandList.includes(requestId)) {
      acceptedCommandList.push(requestId);
    }
    if (responseSchema !== TlvNoResponse) {
      if (!generatedCommandList.includes(responseId)) {
        generatedCommandList.push(responseId);
      }
    }
  }
  attributes.acceptedCommandList.setLocal(acceptedCommandList.sort((a, b) => a - b));
  attributes.generatedCommandList.setLocal(generatedCommandList.sort((a, b) => a - b));
  const eventList = new Array();
  for (const eventName in eventDef) {
    const { id, schema, priority, optional, readAcl } = eventDef[eventName];
    if (!optional && supportedEvents[eventName] !== true) {
      if (!ignoreMissingElements) {
        throw new ImplementationError(
          `Event ${eventName} needs be supported by cluster ${name} (${clusterId})`
        );
      }
      logger.warn(
        `Event ${eventName} should be supported by cluster ${name} (${clusterId}) but not present and ignored.`
      );
      continue;
    }
    if (eventDef[eventName].isConditional) {
      const { mandatoryIf, optionalIf } = eventDef[eventName];
      let conditionHasMatched = false;
      if (mandatoryIf !== void 0) {
        const conditionMatched = isConditionMatching(mandatoryIf, supportedFeatures);
        if (conditionMatched && supportedEvents[eventName] === void 0) {
          logger.warn(
            `Event "${clusterDef.name}/${eventName}" is REQUIRED by supportedFeatures: ${Logger.toJSON(
              supportedFeatures
            )} but is not set!`
          );
        }
        conditionHasMatched = conditionHasMatched || conditionMatched;
      }
      if (!conditionHasMatched && optionalIf !== void 0 && optionalIf.length > 0) {
        const conditionMatched = isConditionMatching(optionalIf, supportedFeatures);
        if (conditionMatched && supportedEvents[eventName] === void 0) {
          logger.debug(
            `Event "${clusterDef.name}/${eventName}" is optional by supportedFeatures: ${Logger.toJSON(
              supportedFeatures
            )} and is not set!`
          );
        }
        conditionHasMatched = conditionHasMatched || conditionMatched;
      }
      if (!conditionHasMatched && supportedEvents[eventName] !== void 0) {
        logger.warn(
          `Event "${clusterDef.name}/${eventName}" is provided but it's neither optional or mandatory for supportedFeatures: ${Logger.toJSON(
            supportedFeatures
          )} but is set!`
        );
      }
    }
    if (supportedEvents[eventName] === true) {
      events[eventName] = createEventServer(
        clusterDef,
        eventDef[eventName],
        eventName,
        schema,
        priority,
        readAcl
      );
      const capitalizedEventName = capitalize(eventName);
      result[`trigger${capitalizedEventName}Event`] = (event) => events[eventName].triggerEvent(event);
      eventList.push(id);
    }
  }
  return result;
}
export {
  ClusterServer
};
//# sourceMappingURL=ClusterServer.js.map
