/**
 * @license
 * Copyright 2022-2024 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { GeneralCommissioning } from "#clusters";
import { CachedClientNodeStore } from "#device/CachedClientNodeStore.js";
import {
  Bytes,
  ChannelType,
  Construction,
  Crypto,
  CRYPTO_SYMMETRIC_KEY_LENGTH,
  ImplementationError,
  Logger,
  NetInterfaceSet,
  serverAddressToString,
  StorageBackendMemory,
  StorageManager
} from "#general";
import { LegacyControllerStore } from "#LegacyControllerStore.js";
import {
  CertificateAuthority,
  ChannelManager,
  ClusterClient,
  CommissioningError,
  ControllerCommissioner,
  DEFAULT_ADMIN_VENDOR_ID,
  DEFAULT_FABRIC_ID,
  DeviceAdvertiser,
  ExchangeManager,
  Fabric,
  FabricBuilder,
  FabricManager,
  NodeDiscoveryType,
  PeerAddressStore,
  PeerSet,
  RetransmissionLimitReachedError,
  SecureChannelProtocol,
  SessionManager,
  SubscriptionClient,
  UnknownNodeError
} from "#protocol";
import {
  EndpointNumber,
  FabricId,
  FabricIndex,
  NodeId
} from "#types";
const DEFAULT_FABRIC_INDEX = FabricIndex(1);
const CONTROLLER_CONNECTIONS_PER_FABRIC_AND_NODE = 3;
const CONTROLLER_MAX_PATHS_PER_INVOKE = 10;
const logger = Logger.get("MatterController");
class MatterController {
  static async create(options) {
    const {
      controllerStore,
      scanners,
      netInterfaces,
      sessionClosedCallback,
      adminVendorId,
      adminFabricId = FabricId(DEFAULT_FABRIC_ID),
      adminFabricIndex = FabricIndex(DEFAULT_FABRIC_INDEX),
      caseAuthenticatedTags
    } = options;
    const ca = await CertificateAuthority.create(controllerStore.caStorage);
    const fabricStorage = controllerStore.fabricStorage;
    let controller = void 0;
    if (await fabricStorage.has("fabric")) {
      const fabric = new Fabric(await fabricStorage.get("fabric"));
      if (Bytes.areEqual(fabric.rootCert, ca.rootCert)) {
        logger.info("Loaded existing fabric from storage");
        controller = new MatterController({
          controllerStore,
          scanners,
          netInterfaces,
          certificateManager: ca,
          fabric,
          sessionClosedCallback
        });
      } else {
        logger.info("Fabric CA certificate changed ...");
        if (await controllerStore.nodesStorage.has("commissionedNodes")) {
          throw new Error(
            "Fabric certificate changed, but commissioned nodes are still present. Please clear the storage."
          );
        }
      }
    }
    if (controller === void 0) {
      logger.info("Creating new fabric");
      const rootNodeId = NodeId.randomOperationalNodeId();
      const ipkValue = Crypto.getRandomData(CRYPTO_SYMMETRIC_KEY_LENGTH);
      const fabricBuilder = new FabricBuilder().setRootCert(ca.rootCert).setRootNodeId(rootNodeId).setIdentityProtectionKey(ipkValue).setRootVendorId(adminVendorId ?? DEFAULT_ADMIN_VENDOR_ID);
      fabricBuilder.setOperationalCert(
        ca.generateNoc(fabricBuilder.publicKey, adminFabricId, rootNodeId, caseAuthenticatedTags)
      );
      const fabric = await fabricBuilder.build(adminFabricIndex);
      controller = new MatterController({
        controllerStore,
        scanners,
        netInterfaces,
        certificateManager: ca,
        fabric,
        sessionClosedCallback
      });
    }
    await controller.construction;
    return controller;
  }
  static async createAsPaseCommissioner(options) {
    const { certificateAuthorityConfig, fabricConfig, scanners, netInterfaces, sessionClosedCallback } = options;
    if (!netInterfaces.hasInterfaceFor(ChannelType.BLE)) {
      if (!scanners.hasScannerFor(ChannelType.UDP) || !netInterfaces.hasInterfaceFor(ChannelType.UDP, "::")) {
        throw new ImplementationError(
          "Ble must be initialized to create a Sub Commissioner without an IP network!"
        );
      }
      logger.info("BLE is not enabled. Using only IP network for commissioning.");
    }
    const certificateManager = await CertificateAuthority.create(certificateAuthorityConfig);
    const storageManager = new StorageManager(new StorageBackendMemory());
    await storageManager.initialize();
    const fabric = new Fabric(fabricConfig);
    const controller = new MatterController({
      controllerStore: new LegacyControllerStore(storageManager.createContext("Commissioner")),
      scanners,
      netInterfaces,
      certificateManager,
      fabric,
      sessionClosedCallback
    });
    await controller.construction;
    return controller;
  }
  sessionManager;
  netInterfaces = new NetInterfaceSet();
  channelManager = new ChannelManager(CONTROLLER_CONNECTIONS_PER_FABRIC_AND_NODE);
  exchangeManager;
  peers;
  commissioner;
  #construction;
  #store;
  nodesStore;
  scanners;
  ca;
  fabric;
  sessionClosedCallback;
  #advertiser;
  get construction() {
    return this.#construction;
  }
  constructor(options) {
    const { controllerStore, scanners, netInterfaces, certificateManager, fabric, sessionClosedCallback } = options;
    this.#store = controllerStore;
    this.scanners = scanners;
    this.netInterfaces = netInterfaces;
    this.ca = certificateManager;
    this.fabric = fabric;
    this.sessionClosedCallback = sessionClosedCallback;
    const fabricManager = new FabricManager();
    fabricManager.addFabric(fabric);
    this.sessionManager = new SessionManager({
      fabrics: fabricManager,
      storage: controllerStore.sessionStorage,
      parameters: {
        maxPathsPerInvoke: CONTROLLER_MAX_PATHS_PER_INVOKE
      }
    });
    this.sessionManager.sessions.deleted.on(async (session) => {
      this.sessionClosedCallback?.(session.peerNodeId);
    });
    this.exchangeManager = new ExchangeManager({
      sessionManager: this.sessionManager,
      channelManager: this.channelManager,
      transportInterfaces: this.netInterfaces
    });
    this.exchangeManager.addProtocolHandler(new SecureChannelProtocol(this.sessionManager, fabricManager));
    this.exchangeManager.addProtocolHandler(new SubscriptionClient());
    this.nodesStore = new CommissionedNodeStore(controllerStore, fabric);
    this.nodesStore.peers = this.peers = new PeerSet({
      sessions: this.sessionManager,
      channels: this.channelManager,
      exchanges: this.exchangeManager,
      scanners: this.scanners,
      netInterfaces: this.netInterfaces,
      store: this.nodesStore
    });
    this.commissioner = new ControllerCommissioner({
      peers: this.peers,
      scanners: this.scanners,
      netInterfaces: this.netInterfaces,
      exchanges: this.exchangeManager,
      sessions: this.sessionManager,
      ca: this.ca
    });
    this.#advertiser = new DeviceAdvertiser({
      fabrics: fabricManager,
      sessions: this.sessionManager
    });
    this.#construction = Construction(this, async () => {
      await this.peers.construction.ready;
      await this.sessionManager.construction.ready;
    });
  }
  get nodeId() {
    return this.fabric.rootNodeId;
  }
  get caConfig() {
    return this.ca.config;
  }
  get fabricConfig() {
    return this.fabric.config;
  }
  getFabrics() {
    return [this.fabric];
  }
  hasBroadcaster(broadcaster) {
    return this.#advertiser.hasBroadcaster(broadcaster);
  }
  addBroadcaster(broadcaster) {
    this.#advertiser.addBroadcaster(broadcaster);
  }
  async deleteBroadcaster(broadcaster) {
    await this.#advertiser.deleteBroadcaster(broadcaster);
  }
  collectScanners(discoveryCapabilities = { onIpNetwork: true }) {
    return this.scanners.filter(
      (scanner) => scanner.type === ChannelType.UDP || discoveryCapabilities.ble && scanner.type === ChannelType.BLE
    );
  }
  /**
   * Commission a device by its identifier and the Passcode. If a known address is provided this is tried first
   * before discovering devices in the network. If multiple addresses or devices are found, they are tried all after
   * each other. It returns the NodeId of the commissioned device.
   * If it throws an PairRetransmissionLimitReachedError that means that no found device responded to the pairing
   * request or the passode did not match to any discovered device/address.
   *
   * Use the connectNodeAfterCommissioning callback to implement an own logic to do the operative device discovery and
   * to complete the commissioning process.
   * Return true when the commissioning process is completed successfully, false on error.
   */
  async commission(options, completeCommissioningCallback) {
    const commissioningOptions = {
      ...options.commissioning,
      fabric: this.fabric,
      discovery: options.discovery,
      passcode: options.passcode
    };
    if (completeCommissioningCallback) {
      commissioningOptions.finalizeCommissioning = async (peerAddress, discoveryData) => {
        const result = await completeCommissioningCallback(peerAddress.nodeId, discoveryData);
        if (!result) {
          throw new RetransmissionLimitReachedError("Device could not be discovered");
        }
      };
    }
    const address = await this.commissioner.commissionWithDiscovery(commissioningOptions);
    await this.#store.fabricStorage.set("fabric", this.fabric.config);
    return address.nodeId;
  }
  async disconnect(nodeId) {
    return this.peers.disconnect(this.fabric.addressOf(nodeId));
  }
  async removeNode(nodeId) {
    return this.peers.delete(this.fabric.addressOf(nodeId));
  }
  /**
   * Method to complete the commissioning process to a node which was initialized with a PASE secure channel.
   */
  async completeCommissioning(peerNodeId, discoveryData) {
    const interactionClient = await this.connect(
      peerNodeId,
      {
        discoveryType: NodeDiscoveryType.TimedDiscovery,
        timeoutSeconds: 120,
        discoveryData
      },
      true
    );
    const generalCommissioningClusterClient = ClusterClient(
      GeneralCommissioning.Cluster,
      EndpointNumber(0),
      interactionClient
    );
    const { errorCode, debugText } = await generalCommissioningClusterClient.commissioningComplete(void 0, {
      useExtendedFailSafeMessageResponseTimeout: true
    });
    if (errorCode !== GeneralCommissioning.CommissioningError.Ok) {
      await this.peers.delete(this.fabric.addressOf(peerNodeId));
      throw new CommissioningError(`Commission error on commissioningComplete: ${errorCode}, ${debugText}`);
    }
    await this.#store.fabricStorage.set("fabric", this.fabric.config);
  }
  isCommissioned() {
    return this.peers.size > 0;
  }
  getCommissionedNodes() {
    return this.peers.map((peer) => peer.address.nodeId);
  }
  getCommissionedNodesDetails() {
    return this.peers.map((peer) => {
      const { address, operationalAddress, discoveryData, deviceData } = peer;
      return {
        nodeId: address.nodeId,
        operationalAddress: operationalAddress ? serverAddressToString(operationalAddress) : void 0,
        advertisedName: discoveryData?.DN,
        discoveryData,
        deviceData
      };
    });
  }
  getCommissionedNodeDetails(nodeId) {
    const nodeDetails = this.peers.get(this.fabric.addressOf(nodeId));
    if (nodeDetails === void 0) {
      throw new Error(`Node ${nodeId} is not commissioned.`);
    }
    const { address, operationalAddress, discoveryData, deviceData } = nodeDetails;
    return {
      nodeId: address.nodeId,
      operationalAddress: operationalAddress ? serverAddressToString(operationalAddress) : void 0,
      advertisedName: discoveryData?.DN,
      discoveryData,
      deviceData
    };
  }
  async enhanceCommissionedNodeDetails(nodeId, deviceData) {
    const nodeDetails = this.peers.get(this.fabric.addressOf(nodeId));
    if (nodeDetails === void 0) {
      throw new Error(`Node ${nodeId} is not commissioned.`);
    }
    nodeDetails.deviceData = deviceData;
    await this.nodesStore.save();
  }
  /**
   * Connect to the device by opening a channel and creating a new CASE session if necessary.
   * Returns a InteractionClient on success.
   */
  async connect(peerNodeId, discoveryOptions, allowUnknownPeer) {
    return this.peers.connect(this.fabric.addressOf(peerNodeId), discoveryOptions, allowUnknownPeer);
  }
  createInteractionClient(peerNodeId, discoveryOptions) {
    return this.peers.initializeInteractionClient(this.fabric.addressOf(peerNodeId), discoveryOptions);
  }
  async getNextAvailableSessionId() {
    return this.sessionManager.getNextAvailableSessionId();
  }
  getResumptionRecord(resumptionId) {
    return this.sessionManager.findResumptionRecordById(resumptionId);
  }
  findResumptionRecordByNodeId(nodeId) {
    return this.sessionManager.findResumptionRecordByAddress(this.fabric.addressOf(nodeId));
  }
  async saveResumptionRecord(resumptionRecord) {
    return this.sessionManager.saveResumptionRecord(resumptionRecord);
  }
  announce() {
    return this.#advertiser.advertise();
  }
  async close() {
    await this.peers.close();
    await this.exchangeManager.close();
    await this.sessionManager.close();
    await this.channelManager.close();
    await this.netInterfaces.close();
    await this.#advertiser.close();
  }
  getActiveSessionInformation() {
    return this.sessionManager.getActiveSessionInformation();
  }
  async getStoredClusterDataVersions(nodeId, filterEndpointId, filterClusterId) {
    const peer = this.peers.get(this.fabric.addressOf(nodeId));
    if (peer === void 0) {
      throw new UnknownNodeError(`Node ${nodeId} is not commissioned.`);
    }
    if (peer.dataStore === void 0) {
      return [];
    }
    await peer.dataStore.construction;
    return peer.dataStore.getClusterDataVersions(filterEndpointId, filterClusterId);
  }
  async retrieveStoredAttributes(nodeId, endpointId, clusterId) {
    const peer = this.peers.get(this.fabric.addressOf(nodeId));
    if (peer === void 0) {
      throw new UnknownNodeError(`Node ${nodeId} is not commissioned.`);
    }
    if (peer.dataStore === void 0) {
      return [];
    }
    await peer.dataStore.construction;
    return peer.dataStore.retrieveAttributes(endpointId, clusterId);
  }
}
class CommissionedNodeStore extends PeerAddressStore {
  constructor(controllerStore, fabric) {
    super();
    this.fabric = fabric;
    this.#controllerStore = controllerStore;
  }
  #controllerStore;
  async createNodeStore(address, load = true) {
    return new CachedClientNodeStore(await this.#controllerStore.clientNodeStore(address.nodeId.toString()), load);
  }
  async loadPeers() {
    if (!await this.#controllerStore.nodesStorage.has("commissionedNodes")) {
      return [];
    }
    const commissionedNodes = await this.#controllerStore.nodesStorage.get("commissionedNodes");
    const nodes = new Array();
    for (const [nodeId, { operationalServerAddress, discoveryData, deviceData }] of commissionedNodes) {
      const address = this.fabric.addressOf(nodeId);
      nodes.push({
        address,
        operationalAddress: operationalServerAddress,
        discoveryData,
        deviceData,
        dataStore: await this.createNodeStore(address)
      });
    }
    return nodes;
  }
  async updatePeer() {
    return this.save();
  }
  async deletePeer(address) {
    await (await this.#controllerStore.clientNodeStore(address.nodeId.toString())).clearAll();
    return this.save();
  }
  async save() {
    await this.#controllerStore.nodesStorage.set(
      "commissionedNodes",
      this.peers.map((peer) => {
        const {
          address,
          operationalAddress: operationalServerAddress,
          discoveryData,
          deviceData
        } = peer;
        return [
          address.nodeId,
          { operationalServerAddress, discoveryData, deviceData }
        ];
      })
    );
  }
}
export {
  MatterController
};
//# sourceMappingURL=MatterController.js.map
